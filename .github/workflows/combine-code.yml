name: Generate & Publish Combined Code File

on:
  push:
    branches:
      - master
  workflow_dispatch:

env:
  # ğŸ’¡ è¨­å®šã¯ã“ã“ã§ä¸€å…ƒç®¡ç†
  OUTPUT_FILENAME: combined.txt
  TARGET_BRANCH: combine-code
  TARGET_EXTENSIONS: .cpp,.h,.hpp
  EXCLUDE_DIRS: externals,resources

jobs:
  publish:
    runs-on: ubuntu-latest

    # ğŸ’¡ æ¨©é™è¨­å®š
    permissions:
      contents: write # ãƒªãƒã‚¸ãƒˆãƒªã¸ã®æ›¸ãè¾¼ã¿æ¨©é™ã‚’è¨±å¯
      pull-requests: write # ãƒ—ãƒ«ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®ä½œæˆ/æ›´æ–°æ¨©é™ã‚’è¨±å¯ï¼ˆä»Šå›ã¯å¿…é ˆã§ã¯ãªã„ãŒå®‰å…¨ã®ãŸã‚ï¼‰
    
    steps:
      - name: Checkout master (Shallow depth)
        # ğŸ’¡ ã¾ãšã¯æœ€æ–°ã®masterã®ã‚³ãƒ¼ãƒ‰ã‚’å–å¾—ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§shallow cloneï¼‰
        uses: actions/checkout@v4 

      # 1. ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰çµåˆãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆcombined.txtï¼‰ã®ç”Ÿæˆ
      - name: Generate Code Summary
        id: generate
        shell: python
        run: |
          import os
          import hashlib
          
          # --- ç’°å¢ƒå¤‰æ•°ã‹ã‚‰ã®è¨­å®šèª­ã¿è¾¼ã¿ ---
          target_extensions = tuple(os.environ['TARGET_EXTENSIONS'].split(','))
          exclude_dirs = set(os.environ['EXCLUDE_DIRS'].split(','))
          output_file = os.environ['OUTPUT_FILENAME']
          root_dir = '.'
          exclude_dirs.update({'.git', '.github', '.vs', 'build', 'out'})
          # -----------------------------------
          
          # [å¤‰æ›´ç‚¹A] ãƒ•ã‚¡ã‚¤ãƒ«ç”Ÿæˆãƒ­ã‚¸ãƒƒã‚¯ã¯çœç•¥ï¼ˆå‰å›ã®ã‚‚ã®ã‚’ãã®ã¾ã¾ä½¿ç”¨ï¼‰
          # ... (Pythonã®ãƒ•ã‚¡ã‚¤ãƒ«ç”Ÿæˆãƒ­ã‚¸ãƒƒã‚¯) ...
          
          def is_excluded(dir_name):
              return dir_name in exclude_dirs

          def process_directory(current_path, outfile):
              try:
                  items = sorted(os.listdir(current_path))
              except OSError:
                  return

              for item in items:
                  full_path = os.path.join(current_path, item)
                  
                  if os.path.isdir(full_path):
                      if not is_excluded(item):
                          process_directory(full_path, outfile)
                  else:
                      if item.endswith(target_extensions):
                          rel_path = os.path.relpath(full_path, root_dir)
                          outfile.write(f"\n{'='*60}\n")
                          outfile.write(f"File Path: {rel_path}\n")
                          outfile.write(f"{'='*60}\n")
                          
                          try:
                              with open(full_path, 'r', encoding='utf-8', errors='replace') as f:
                                  outfile.write(f.read())
                          except Exception as e:
                              outfile.write(f"[Error reading file: {e}]\n")
                          outfile.write("\n")

          print(f"Generating {output_file}...")
          with open(output_file, 'w', encoding='utf-8') as outfile:
              process_directory(root_dir, outfile)
          print("Done.")


          # [å¤‰æ›´ç‚¹B] ç”Ÿæˆãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒãƒƒã‚·ãƒ¥å€¤ã‚’å‡ºåŠ›
          with open(output_file, 'rb') as f:
              file_hash = hashlib.sha256(f.read()).hexdigest()
          
          print(f"::set-output name=file_hash::{file_hash}")
          print(f"::set-output name=output_file::{output_file}")


      # 1.5. æ—¢å­˜ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ãƒã‚§ãƒƒã‚¯ã¨ã‚¹ã‚­ãƒƒãƒ—
      - name: Check for Content Changes and Skip Push
        id: check_changes
        run: |
          OUTPUT_FILENAME="${{ steps.generate.outputs.output_file }}"
          CURRENT_HASH="${{ steps.generate.outputs.file_hash }}"
          TARGET_BRANCH="${{ env.TARGET_BRANCH }}"
          
          # ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ–ãƒ©ãƒ³ãƒãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ã€å¿…ãšã‚³ãƒŸãƒƒãƒˆã™ã‚‹ãŸã‚ã‚¹ã‚­ãƒƒãƒ—ã—ãªã„
          if ! git ls-remote --heads origin "$TARGET_BRANCH" | grep "$TARGET_BRANCH"; then
            echo "Target branch does not exist. Must commit."
            echo "::set-output name=skip_commit::false"
            exit 0
          fi
          
          # ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ–ãƒ©ãƒ³ãƒã‚’ãƒ•ã‚§ãƒƒãƒã—ã€ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã®ãƒãƒƒã‚·ãƒ¥å€¤ã‚’å–å¾—
          git fetch origin "$TARGET_BRANCH"
          
          # ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ–ãƒ©ãƒ³ãƒã®æœ€æ–°ã‚³ãƒŸãƒƒãƒˆã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒãƒƒã‚·ãƒ¥å€¤ã‚’å–å¾—
          # ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆã‚„ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯ãƒãƒƒã‚·ãƒ¥å€¤ãŒç©ºã«ãªã‚‹
          EXISTING_HASH=$(git show origin/"$TARGET_BRANCH":"$OUTPUT_FILENAME" | sha256sum | awk '{print $1}' || echo "")
          
          echo "Current file hash: $CURRENT_HASH"
          echo "Existing file hash: $EXISTING_HASH"
          
          if [ "$CURRENT_HASH" = "$EXISTING_HASH" ]; then
            echo "âœ… Content unchanged. Skipping commit and push."
            echo "::set-output name=skip_commit::true"
          else
            echo "ğŸ”„ Content changed. Proceeding with commit."
            echo "::set-output name=skip_commit::false"
          fi

      # 2. ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ–ãƒ©ãƒ³ãƒã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã¨ã‚³ãƒŸãƒƒãƒˆ
      # ğŸ’¡ if: æ¡ä»¶ã‚’ä»˜åŠ ã—ã€ã‚¹ã‚­ãƒƒãƒ—ãƒ•ãƒ©ã‚°ãŒtrueã§ãªã„å ´åˆã®ã¿å®Ÿè¡Œ
      - name: Setup Target Branch and Commit (Hybrid Logic)
        if: steps.check_changes.outputs.skip_commit == 'false'
        run: |
          TARGET_BRANCH="${{ env.TARGET_BRANCH }}"
          OUTPUT_FILENAME="${{ steps.generate.outputs.output_file }}"
          # ... (ä»¥å‰ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®æ®‹ã‚Šã®éƒ¨åˆ†ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã¯OUTPUT_FILENAMEå¤‰æ•°ã‚’ä½¿ç”¨) ...
          
          # 1. ç”Ÿæˆã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¸€æ™‚çš„ã«ä¿å­˜
          cp "$OUTPUT_FILENAME" /tmp/"$OUTPUT_FILENAME"
          
          # 2. ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ–ãƒ©ãƒ³ãƒã®å­˜åœ¨ãƒã‚§ãƒƒã‚¯ã¨åˆ‡ã‚Šæ›¿ãˆ
          BRANCH_EXISTS=$(git ls-remote --heads origin "$TARGET_BRANCH" | wc -l)

          if [ "$BRANCH_EXISTS" -ne 0 ]; then
            # --- A. ãƒ–ãƒ©ãƒ³ãƒãŒå­˜åœ¨ã™ã‚‹å ´åˆ ---
            echo "Target branch '$TARGET_BRANCH' exists. Checking out."
            git fetch origin "$TARGET_BRANCH"
            # æ—¢å­˜ãƒ–ãƒ©ãƒ³ãƒã‚’ãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆã™ã‚‹å‰ã«ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤ã—è¡çªå›é¿
            if [ -f "$OUTPUT_FILENAME" ]; then
              rm "$OUTPUT_FILENAME"
            fi
            git checkout "$TARGET_BRANCH"
          else
            # --- B. ãƒ–ãƒ©ãƒ³ãƒãŒå­˜åœ¨ã—ãªã„å ´åˆ ---
            echo "Target branch '$TARGET_BRANCH' does not exist. Creating from initial commit."
            
            echo "Fetching full history..."
            git fetch --unshallow || git fetch origin master --depth=0
            
            INITIAL_COMMIT_ID=$(git rev-list --max-parents=0 HEAD)
            
            git checkout -b "$TARGET_BRANCH" "$INITIAL_COMMIT_ID"
            
            git rm -rf . || true
          fi
          
          # 3. å…±é€šå‡¦ç†: ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å¾©å…ƒã—ã¦ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ³ã‚°
          cp /tmp/"$OUTPUT_FILENAME" .
          git add "$OUTPUT_FILENAME"
          
          # 4. ã‚³ãƒŸãƒƒãƒˆã¨ãƒ—ãƒƒã‚·ãƒ¥
          git config user.name github-actions[bot]
          git config user.email 41898282+github-actions[bot]@users.noreply.github.com
          
          git commit -m "Auto: Update summary for AI review (${{ github.sha }})"
          
          # å¼·åˆ¶ãƒ—ãƒƒã‚·ãƒ¥ã§ãƒªãƒ¢ãƒ¼ãƒˆãƒ–ãƒ©ãƒ³ãƒã‚’æ›´æ–°/ä½œæˆ
          git push -u origin "$TARGET_BRANCH" --force
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}