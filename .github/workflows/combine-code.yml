name: Generate & Publish Combined Code File

on:
  push:
    branches:
      - master
  workflow_dispatch:

env:
  # ğŸ’¡ è¨­å®šã¯ã“ã“ã§ä¸€å…ƒç®¡ç†
  OUTPUT_FILENAME: combined.txt # ğŸ‘ˆ ãƒ¦ãƒ¼ã‚¶ãƒ¼æŒ‡å®š
  TARGET_BRANCH: combine-code    # ğŸ‘ˆ ãƒ¦ãƒ¼ã‚¶ãƒ¼æŒ‡å®š
  TARGET_EXTENSIONS: .cpp,.h,.hpp
  EXCLUDE_DIRS: externals,resources

jobs:
  publish:
    runs-on: ubuntu-latest

    # ğŸ’¡ æ¨©é™è¨­å®š
    permissions:
      contents: write # ãƒªãƒã‚¸ãƒˆãƒªã¸ã®æ›¸ãè¾¼ã¿æ¨©é™ã‚’è¨±å¯
      pull-requests: write # ãƒ—ãƒ«ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®ä½œæˆ/æ›´æ–°æ¨©é™ã‚’è¨±å¯ï¼ˆä»Šå›ã¯å¿…é ˆã§ã¯ãªã„ãŒå®‰å…¨ã®ãŸã‚ï¼‰
    
    steps:
      - name: Checkout master (Shallow depth)
        # ğŸ’¡ ã¾ãšã¯æœ€æ–°ã®masterã®ã‚³ãƒ¼ãƒ‰ã‚’å–å¾—ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§shallow cloneï¼‰
        uses: actions/checkout@v4 

      # 1. ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰çµåˆãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆcombined.txtï¼‰ã®ç”Ÿæˆ
      - name: Generate Code Summary
        shell: python
        run: |
          import os
          
          # --- ç’°å¢ƒå¤‰æ•°ã‹ã‚‰ã®è¨­å®šèª­ã¿è¾¼ã¿ ---
          target_extensions = tuple(os.environ['TARGET_EXTENSIONS'].split(','))
          exclude_dirs = set(os.environ['EXCLUDE_DIRS'].split(','))
          output_file = os.environ['OUTPUT_FILENAME']
          root_dir = '.'
          exclude_dirs.update({'.git', '.github', '.vs', 'build', 'out'})
          # -----------------------------------

          def is_excluded(dir_name):
              return dir_name in exclude_dirs

          def process_directory(current_path, outfile):
              try:
                  items = sorted(os.listdir(current_path))
              except OSError:
                  return

              for item in items:
                  full_path = os.path.join(current_path, item)
                  
                  if os.path.isdir(full_path):
                      if not is_excluded(item):
                          process_directory(full_path, outfile)
                  else:
                      if item.endswith(target_extensions):
                          rel_path = os.path.relpath(full_path, root_dir)
                          outfile.write(f"\n{'='*60}\n")
                          outfile.write(f"File Path: {rel_path}\n")
                          outfile.write(f"{'='*60}\n")
                          
                          try:
                              with open(full_path, 'r', encoding='utf-8', errors='replace') as f:
                                  outfile.write(f.read())
                          except Exception as e:
                              outfile.write(f"[Error reading file: {e}]\n")
                          outfile.write("\n")

          print(f"Generating {output_file}...")
          with open(output_file, 'w', encoding='utf-8') as outfile:
              process_directory(root_dir, outfile)
          print("Done.")

      # 2. ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ–ãƒ©ãƒ³ãƒã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã¨ã‚³ãƒŸãƒƒãƒˆ
      - name: Setup Target Branch and Commit (Hybrid Logic)
        run: |
          TARGET_BRANCH="${{ env.TARGET_BRANCH }}"
          OUTPUT_FILENAME="${{ env.OUTPUT_FILENAME }}"
          
          # 1. ç”Ÿæˆã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¸€æ™‚çš„ã«ä¿å­˜
          cp "$OUTPUT_FILENAME" /tmp/"$OUTPUT_FILENAME"
          
          # ğŸ’¡ [ä¿®æ­£ç‚¹]: ãƒ­ãƒ¼ã‚«ãƒ«ã§ç”Ÿæˆã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤ã—ã¦è¡çªã‚’å›é¿
          if [ -f "$OUTPUT_FILENAME" ]; then
            echo "Removing locally generated $OUTPUT_FILENAME to avoid checkout conflict."
            rm "$OUTPUT_FILENAME"
          fi

          # 2. ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ–ãƒ©ãƒ³ãƒã®å­˜åœ¨ãƒã‚§ãƒƒã‚¯ã¨åˆ‡ã‚Šæ›¿ãˆ
          BRANCH_EXISTS=$(git ls-remote --heads origin "$TARGET_BRANCH" | wc -l)

          if [ "$BRANCH_EXISTS" -ne 0 ]; then
            # --- A. ãƒ–ãƒ©ãƒ³ãƒãŒå­˜åœ¨ã™ã‚‹å ´åˆ (åŠ¹ç‡çš„ãªæ›´æ–°) ---
            echo "Target branch '$TARGET_BRANCH' exists. Checking out."
            git fetch origin "$TARGET_BRANCH"
            git checkout "$TARGET_BRANCH"
          else
            # --- B. ãƒ–ãƒ©ãƒ³ãƒãŒå­˜åœ¨ã—ãªã„å ´åˆ (ã‚¯ãƒªãƒ¼ãƒ³ãªåˆå›ä½œæˆ) ---
            echo "Target branch '$TARGET_BRANCH' does not exist. Creating from initial commit."
            
            # å…¨å±¥æ­´ã‚’å–å¾— (fetch-depth: 0 ç›¸å½“)
            echo "Fetching full history..."
            git fetch --unshallow || git fetch origin master --depth=0
            
            # masterã®åˆæœŸã‚³ãƒŸãƒƒãƒˆIDã‚’å–å¾—
            INITIAL_COMMIT_ID=$(git rev-list --max-parents=0 HEAD)
            echo "Initial Commit ID: $INITIAL_COMMIT_ID"
            
            # åˆæœŸã‚³ãƒŸãƒƒãƒˆã‹ã‚‰æ–°ã—ã„ãƒ–ãƒ©ãƒ³ãƒã‚’ä½œæˆã—ã€ãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆ
            git checkout -b "$TARGET_BRANCH" "$INITIAL_COMMIT_ID"
            
            # åˆæœŸã‚³ãƒŸãƒƒãƒˆã‹ã‚‰åˆ†å²ã—ãŸãŸã‚ã€ä½œæ¥­ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
            git rm -rf . || true
          fi
          
          # 3. å…±é€šå‡¦ç†: ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å¾©å…ƒã—ã¦ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ³ã‚°
          cp /tmp/"$OUTPUT_FILENAME" .
          git add "$OUTPUT_FILENAME"
          
          # 4. ã‚³ãƒŸãƒƒãƒˆã¨ãƒ—ãƒƒã‚·ãƒ¥
          git config user.name github-actions[bot]
          git config user.email 41898282+github-actions[bot]@users.noreply.github.com
          
          git commit -m "Auto: Update summary for AI review (${{ github.sha }})"
          
          # å¼·åˆ¶ãƒ—ãƒƒã‚·ãƒ¥ã§ãƒªãƒ¢ãƒ¼ãƒˆãƒ–ãƒ©ãƒ³ãƒã‚’æ›´æ–°/ä½œæˆ
          git push -u origin "$TARGET_BRANCH" --force
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}