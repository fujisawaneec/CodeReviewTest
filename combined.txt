### ðŸŒ³ Codebase File Tree (Excluding ignored directories)

â”œâ”€â”€ Resources/
â””â”€â”€ â”œâ”€â”€ 555/
â””â”€â”€ â”œâ”€â”€ Shader/
â””â”€â”€ â”œâ”€â”€ UVBall/
â””â”€â”€ â”œâ”€â”€ arrow/
â””â”€â”€ â”œâ”€â”€ bit/
â””â”€â”€ â”œâ”€â”€ boneTest/
â””â”€â”€ â”œâ”€â”€ boxobj/
â””â”€â”€ â”œâ”€â”€ enemy/
â””â”€â”€ â”œâ”€â”€ ground/
â””â”€â”€ â”œâ”€â”€ maru/
â””â”€â”€ â”œâ”€â”€ muso/
â””â”€â”€ â”œâ”€â”€ player/
â””â”€â”€ â”œâ”€â”€ skydome/
â””â”€â”€ â”œâ”€â”€ sphere/
â”œâ”€â”€ SKNEngine.vcxproj
â”œâ”€â”€ SKNEngine.vcxproj.filters
â”œâ”€â”€ SourceCode/
â””â”€â”€ â”œâ”€â”€ App/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BulletManager.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BulletManager.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Camera.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Camera.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Collision.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Collision.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CollisionPrimitive.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ DeathParticle.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ DeathParticle.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Enemy/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BossEnemy.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BossEnemy.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ EnemyMine.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ EnemyMine.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ EnemyNormalBullet.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ EnemyNormalBullet.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Field.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Field.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ GameScene.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ GameScene.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Player/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Player.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Player.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ PlayerBullet.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ PlayerBullet.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ StuructTransform.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ StuructTransform.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ UI.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ UI.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ main.cpp
â””â”€â”€ â””â”€â”€ Engine/
â””â”€â”€     â”œâ”€â”€ Buffer/
â””â”€â”€     â””â”€â”€ â”œâ”€â”€ ConstBuffer.cpp
â””â”€â”€     â””â”€â”€ â”œâ”€â”€ ConstBuffer.h
â””â”€â”€     â””â”€â”€ â”œâ”€â”€ IndexBuffer.cpp
â””â”€â”€     â””â”€â”€ â”œâ”€â”€ IndexBuffer.h
â””â”€â”€     â””â”€â”€ â”œâ”€â”€ VertexBuffer.cpp
â””â”€â”€     â””â”€â”€ â””â”€â”€ VertexBuffer.h
â””â”€â”€     â”œâ”€â”€ Core/
â””â”€â”€     â””â”€â”€ â”œâ”€â”€ DescriptorHeap.cpp
â””â”€â”€     â””â”€â”€ â”œâ”€â”€ DescriptorHeap.h
â””â”€â”€     â””â”€â”€ â”œâ”€â”€ DirectXCommon.cpp
â””â”€â”€     â””â”€â”€ â”œâ”€â”€ DirectXCommon.h
â””â”€â”€     â””â”€â”€ â”œâ”€â”€ DxWindow.cpp
â””â”€â”€     â””â”€â”€ â”œâ”€â”€ DxWindow.h
â””â”€â”€     â””â”€â”€ â”œâ”€â”€ FPS.cpp
â””â”€â”€     â””â”€â”€ â”œâ”€â”€ FPS.h
â””â”€â”€     â””â”€â”€ â”œâ”€â”€ Input.cpp
â””â”€â”€     â””â”€â”€ â”œâ”€â”€ Input.h
â””â”€â”€     â””â”€â”€ â”œâ”€â”€ Pipeline.cpp
â””â”€â”€     â””â”€â”€ â”œâ”€â”€ Pipeline.h
â””â”€â”€     â””â”€â”€ â”œâ”€â”€ ViewProjection.cpp
â””â”€â”€     â””â”€â”€ â”œâ”€â”€ ViewProjection.h
â””â”€â”€     â””â”€â”€ â”œâ”€â”€ WorldTronsform.cpp
â””â”€â”€     â””â”€â”€ â””â”€â”€ WorldTronsform.h
â””â”€â”€     â”œâ”€â”€ Draw/
â””â”€â”€     â””â”€â”€ â”œâ”€â”€ 2D/
â””â”€â”€     â””â”€â”€ â””â”€â”€ â”œâ”€â”€ DrawCommon.cpp
â””â”€â”€     â””â”€â”€ â””â”€â”€ â”œâ”€â”€ DrawCommon.h
â””â”€â”€     â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Sprite.cpp
â””â”€â”€     â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Sprite.h
â””â”€â”€     â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Sprite2D.cpp
â””â”€â”€     â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Sprite2D.h
â””â”€â”€     â””â”€â”€ â””â”€â”€ â”œâ”€â”€ SpriteCommon.cpp
â””â”€â”€     â””â”€â”€ â””â”€â”€ â””â”€â”€ SpriteCommon.h
â””â”€â”€     â””â”€â”€ â”œâ”€â”€ 3D/
â””â”€â”€     â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Draw3DLine.cpp
â””â”€â”€     â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Draw3DLine.h
â””â”€â”€     â””â”€â”€ â””â”€â”€ â”œâ”€â”€ FbxLoader.cpp
â””â”€â”€     â””â”€â”€ â””â”€â”€ â”œâ”€â”€ FbxLoader.h
â””â”€â”€     â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Model.cpp
â””â”€â”€     â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Model.h
â””â”€â”€     â””â”€â”€ â””â”€â”€ â”œâ”€â”€ OBJ3D.cpp
â””â”€â”€     â””â”€â”€ â””â”€â”€ â”œâ”€â”€ OBJ3D.h
â””â”€â”€     â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ObjModel.cpp
â””â”€â”€     â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ObjModel.h
â””â”€â”€     â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Object3D.cpp
â””â”€â”€     â””â”€â”€ â””â”€â”€ â””â”€â”€ Object3D.h
â””â”€â”€     â””â”€â”€ â”œâ”€â”€ ParticleManager.cpp
â””â”€â”€     â””â”€â”€ â”œâ”€â”€ ParticleManager.h
â””â”€â”€     â””â”€â”€ â”œâ”€â”€ PostEffect.cpp
â””â”€â”€     â””â”€â”€ â”œâ”€â”€ PostEffect.h
â””â”€â”€     â””â”€â”€ â”œâ”€â”€ TextureManager.cpp
â””â”€â”€     â””â”€â”€ â””â”€â”€ TextureManager.h
â””â”€â”€     â”œâ”€â”€ Light/
â””â”€â”€     â””â”€â”€ â”œâ”€â”€ DirectionLight.cpp
â””â”€â”€     â””â”€â”€ â”œâ”€â”€ DirectionLight.h
â””â”€â”€     â””â”€â”€ â”œâ”€â”€ LightGroup.cpp
â””â”€â”€     â””â”€â”€ â”œâ”€â”€ LightGroup.h
â””â”€â”€     â””â”€â”€ â”œâ”€â”€ PointLight.cpp
â””â”€â”€     â””â”€â”€ â””â”€â”€ PointLight.h
â””â”€â”€     â””â”€â”€ Math/
â””â”€â”€         â”œâ”€â”€ Easing.cpp
â””â”€â”€         â”œâ”€â”€ Easing.h
â””â”€â”€         â”œâ”€â”€ Float4.cpp
â””â”€â”€         â”œâ”€â”€ Float4.h
â””â”€â”€         â”œâ”€â”€ Matrix4.cpp
â””â”€â”€         â”œâ”€â”€ Matrix4.h
â””â”€â”€         â”œâ”€â”€ Vector2.cpp
â””â”€â”€         â”œâ”€â”€ Vector2.h
â””â”€â”€         â”œâ”€â”€ Vector3.cpp
â””â”€â”€         â”œâ”€â”€ Vector3.h
â””â”€â”€         â”œâ”€â”€ myMath.cpp
â””â”€â”€         â””â”€â”€ myMath.h
â””â”€â”€ test.cpp
================================================================================


============================================================
File Path: SKNEngine.vcxproj
============================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{335b45cd-bc6d-4c7d-ae53-6d26b754d7a6}</ProjectGuid>
    <RootNamespace>SKNEngine</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(VC_IncludePath);$(WindowsSDK_IncludePath);$(SolutionDir)DirectXTex;$(ProjectDir)lib\fbx_sdk\include</IncludePath>
    <LibraryPath>$(ProjectDir)lib\fbx_sdk\lib;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(VC_IncludePath);$(WindowsSDK_IncludePath);$(SolutionDir)DirectXTex;$(ProjectDir)lib\fbx_sdk\include</IncludePath>
    <LibraryPath>$(ProjectDir)lib\fbx_sdk\lib;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <AdditionalIncludeDirectories>$(ProjectDir)SourceCode;$(ProjectDir)SourceCode\Engine\Draw;$(ProjectDir)SourceCode\Engine\Buffer;$(ProjectDir)SourceCode\Imgui;$(ProjectDir)SourceCode\Engine\Light;$(ProjectDir)SourceCode\Engine\Math;$(ProjectDir)SourceCode\Engine\Core;$(ProjectDir)SourceCode\App\Player;$(ProjectDir)SourceCode\App;$(ProjectDir)SourceCode\App\Enemy;$(ProjectDir)SourceCode\Engine;$(ProjectDir)SourceCode\Engine\Draw\3D;$(ProjectDir)SourceCode\Engine\Draw\2D;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <TreatWarningAsError>true</TreatWarningAsError>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <AdditionalOptions>/utf-8 %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>libfbxsdk-md.lib;libxml2-md.lib;zlib-md.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalOptions>/IGNORE:4099 %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <AdditionalIncludeDirectories>$(ProjectDir)SourceCode;$(ProjectDir)SourceCode\Engine\Draw;$(ProjectDir)SourceCode\Engine\Buffer;$(ProjectDir)SourceCode\Imgui;$(ProjectDir)SourceCode\Engine\Light;$(ProjectDir)SourceCode\Engine\Math;$(ProjectDir)SourceCode\Engine\Core;$(ProjectDir)SourceCode\App\Player;$(ProjectDir)SourceCode\App;$(ProjectDir)SourceCode\App\Enemy;$(ProjectDir)SourceCode\Engine;$(ProjectDir)SourceCode\Engine\Draw\3D;$(ProjectDir)SourceCode\Engine\Draw\2D;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <TreatWarningAsError>true</TreatWarningAsError>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <AdditionalOptions>/utf-8 %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>libfbxsdk-mt.lib;libxml2-mt.lib;zlib-mt.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalOptions>/IGNORE:4099 %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ProjectReference Include="DirectXTex\DirectXTex_Desktop_2022_Win10.vcxproj">
      <Project>{371b9fa9-4c90-4ac6-a123-aced756d6c77}</Project>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="SourceCode\App\BulletManager.cpp" />
    <ClCompile Include="SourceCode\App\Enemy\EnemyMine.cpp" />
    <ClCompile Include="SourceCode\App\DeathParticle.cpp" />
    <ClCompile Include="SourceCode\App\Field.cpp" />
    <ClCompile Include="SourceCode\Engine\Math\Easing.cpp" />
    <ClCompile Include="SourceCode\Engine\Math\myMath.cpp" />
    <ClCompile Include="SourceCode\Engine\Draw\PostEffect.cpp" />
    <ClCompile Include="SourceCode\App\Enemy\EnemyNormalBullet.cpp" />
    <ClCompile Include="SourceCode\Engine\Draw\3D\Draw3DLine.cpp" />
    <ClCompile Include="SourceCode\App\Player\PlayerBullet.cpp" />
    <ClCompile Include="SourceCode\App\Camera.cpp" />
    <ClCompile Include="SourceCode\Engine\Math\Float4.cpp" />
    <ClCompile Include="SourceCode\Engine\Math\Matrix4.cpp" />
    <ClCompile Include="SourceCode\App\Enemy\BossEnemy.cpp" />
    <ClCompile Include="SourceCode\App\Player\Player.cpp" />
    <ClCompile Include="SourceCode\Engine\Draw\3D\OBJ3D.cpp" />
    <ClCompile Include="SourceCode\Engine\Draw\3D\ObjModel.cpp" />
    <ClCompile Include="SourceCode\App\GameScene.cpp" />
    <ClCompile Include="SourceCode\App\Collision.cpp" />
    <ClCompile Include="SourceCode\Engine\Draw\3D\FbxLoader.cpp" />
    <ClCompile Include="SourceCode\Engine\Buffer\ConstBuffer.cpp" />
    <ClCompile Include="SourceCode\Engine\Core\DescriptorHeap.cpp" />
    <ClCompile Include="SourceCode\Engine\Core\DirectXCommon.cpp" />
    <ClCompile Include="SourceCode\Engine\Draw\2D\DrawCommon.cpp" />
    <ClCompile Include="SourceCode\Engine\Core\DxWindow.cpp" />
    <ClCompile Include="SourceCode\Engine\Core\FPS.cpp" />
    <ClCompile Include="SourceCode\Imgui\ImGuiManager.cpp" />
    <ClCompile Include="SourceCode\Imgui\imgui.cpp">
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|x64'">MinSpace</Optimization>
    </ClCompile>
    <ClCompile Include="SourceCode\Imgui\imgui_demo.cpp">
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|x64'">MinSpace</Optimization>
    </ClCompile>
    <ClCompile Include="SourceCode\Imgui\imgui_draw.cpp">
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|x64'">MinSpace</Optimization>
    </ClCompile>
    <ClCompile Include="SourceCode\Imgui\imgui_impl_dx12.cpp">
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|x64'">MinSpace</Optimization>
    </ClCompile>
    <ClCompile Include="SourceCode\Imgui\imgui_impl_win32.cpp">
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|x64'">MinSpace</Optimization>
    </ClCompile>
    <ClCompile Include="SourceCode\Imgui\imgui_tables.cpp">
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|x64'">MinSpace</Optimization>
    </ClCompile>
    <ClCompile Include="SourceCode\Imgui\imgui_widgets.cpp">
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|x64'">MinSpace</Optimization>
    </ClCompile>
    <ClCompile Include="SourceCode\Engine\Buffer\IndexBuffer.cpp" />
    <ClCompile Include="SourceCode\Engine\Core\Input.cpp" />
    <ClCompile Include="SourceCode\Engine\Light\DirectionLight.cpp" />
    <ClCompile Include="SourceCode\Engine\Light\LightGroup.cpp" />
    <ClCompile Include="SourceCode\App\main.cpp" />
    <ClCompile Include="SourceCode\Engine\Draw\3D\Model.cpp" />
    <ClCompile Include="SourceCode\Engine\Draw\3D\Object3D.cpp" />
    <ClCompile Include="SourceCode\Engine\Draw\ParticleManager.cpp" />
    <ClCompile Include="SourceCode\Engine\Core\Pipeline.cpp" />
    <ClCompile Include="SourceCode\Engine\Light\PointLight.cpp" />
    <ClCompile Include="SourceCode\Engine\Draw\2D\Sprite.cpp" />
    <ClCompile Include="SourceCode\Engine\Draw\2D\Sprite2D.cpp" />
    <ClCompile Include="SourceCode\Engine\Draw\2D\SpriteCommon.cpp" />
    <ClCompile Include="SourceCode\Engine\Draw\TextureManager.cpp" />
    <ClCompile Include="SourceCode\Engine\Buffer\VertexBuffer.cpp" />
    <ClCompile Include="SourceCode\Engine\Core\ViewProjection.cpp" />
    <ClCompile Include="SourceCode\Engine\Core\WorldTronsform.cpp" />
    <ClCompile Include="SourceCode\Engine\Math\Vector2.cpp" />
    <ClCompile Include="SourceCode\Engine\Math\Vector3.cpp" />
    <ClCompile Include="SourceCode\App\StuructTransform.cpp" />
    <ClCompile Include="SourceCode\App\UI.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="SourceCode\App\BulletManager.h" />
    <ClInclude Include="SourceCode\App\Enemy\EnemyMine.h" />
    <ClInclude Include="SourceCode\App\DeathParticle.h" />
    <ClInclude Include="SourceCode\App\Field.h" />
    <ClInclude Include="SourceCode\Engine\Math\Easing.h" />
    <ClInclude Include="SourceCode\Engine\Math\myMath.h" />
    <ClInclude Include="SourceCode\App\Enemy\EnemyNormalBullet.h" />
    <ClInclude Include="SourceCode\Engine\Draw\3D\Draw3DLine.h" />
    <ClInclude Include="SourceCode\App\Player\PlayerBullet.h" />
    <ClInclude Include="SourceCode\App\Camera.h" />
    <ClInclude Include="SourceCode\Engine\Math\Float4.h" />
    <ClInclude Include="SourceCode\Engine\Math\Matrix4.h" />
    <ClInclude Include="SourceCode\App\Enemy\BossEnemy.h" />
    <ClInclude Include="SourceCode\App\Player\Player.h" />
    <ClInclude Include="SourceCode\Engine\Draw\3D\OBJ3D.h" />
    <ClInclude Include="SourceCode\Engine\Draw\3D\ObjModel.h" />
    <ClInclude Include="SourceCode\Engine\Draw\PostEffect.h" />
    <ClInclude Include="SourceCode\App\GameScene.h" />
    <ClInclude Include="SourceCode\App\Collision.h" />
    <ClInclude Include="SourceCode\App\CollisionPrimitive.h" />
    <ClInclude Include="SourceCode\Engine\Draw\3D\FbxLoader.h" />
    <ClInclude Include="SourceCode\Engine\Buffer\ConstBuffer.h" />
    <ClInclude Include="SourceCode\Engine\Core\DescriptorHeap.h" />
    <ClInclude Include="SourceCode\Engine\Core\DirectXCommon.h" />
    <ClInclude Include="SourceCode\Engine\Draw\2D\DrawCommon.h" />
    <ClInclude Include="SourceCode\Engine\Core\DxWindow.h" />
    <ClInclude Include="SourceCode\Engine\Core\FPS.h" />
    <ClInclude Include="SourceCode\Imgui\ImGuiManager.h" />
    <ClInclude Include="SourceCode\Imgui\imconfig.h" />
    <ClInclude Include="SourceCode\Imgui\imgui.h" />
    <ClInclude Include="SourceCode\Imgui\imgui_impl_dx12.h" />
    <ClInclude Include="SourceCode\Imgui\imgui_impl_win32.h" />
    <ClInclude Include="SourceCode\Imgui\imgui_internal.h" />
    <ClInclude Include="SourceCode\Imgui\imstb_rectpack.h" />
    <ClInclude Include="SourceCode\Imgui\imstb_textedit.h" />
    <ClInclude Include="SourceCode\Imgui\imstb_truetype.h" />
    <ClInclude Include="SourceCode\Engine\Buffer\IndexBuffer.h" />
    <ClInclude Include="SourceCode\Engine\Core\Input.h" />
    <ClInclude Include="SourceCode\Engine\Light\DirectionLight.h" />
    <ClInclude Include="SourceCode\Engine\Light\LightGroup.h" />
    <ClInclude Include="SourceCode\Engine\Draw\3D\Model.h" />
    <ClInclude Include="SourceCode\Engine\Draw\3D\Object3D.h" />
    <ClInclude Include="SourceCode\Engine\Draw\ParticleManager.h" />
    <ClInclude Include="SourceCode\Engine\Core\Pipeline.h" />
    <ClInclude Include="SourceCode\Engine\Light\PointLight.h" />
    <ClInclude Include="SourceCode\Engine\Draw\2D\Sprite.h" />
    <ClInclude Include="SourceCode\Engine\Draw\2D\Sprite2D.h" />
    <ClInclude Include="SourceCode\Engine\Draw\2D\SpriteCommon.h" />
    <ClInclude Include="SourceCode\Engine\Draw\TextureManager.h" />
    <ClInclude Include="SourceCode\Engine\Buffer\VertexBuffer.h" />
    <ClInclude Include="SourceCode\Engine\Core\ViewProjection.h" />
    <ClInclude Include="SourceCode\Engine\Core\WorldTronsform.h" />
    <ClInclude Include="SourceCode\Engine\Math\Vector2.h" />
    <ClInclude Include="SourceCode\Engine\Math\Vector3.h" />
    <ClInclude Include="SourceCode\App\StuructTransform.h" />
    <ClInclude Include="SourceCode\App\UI.h" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Shader\3DLine.hlsli" />
    <None Include="Resources\Shader\FBX.hlsli" />
    <None Include="Resources\Shader\Basic.hlsli" />
    <None Include="Resources\Shader\Obj.hlsli" />
    <None Include="Resources\Shader\Particle.hlsli" />
    <None Include="Resources\Shader\PostEffect.hlsli" />
  </ItemGroup>
  <ItemGroup>
    <FxCompile Include="Resources\Shader\3DLinePS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
    </FxCompile>
    <FxCompile Include="Resources\Shader\3DLineVS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Vertex</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
    </FxCompile>
    <FxCompile Include="Resources\Shader\FBXPS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
    </FxCompile>
    <FxCompile Include="Resources\Shader\FBXVS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Vertex</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
    </FxCompile>
    <FxCompile Include="Resources\Shader\BasicPS.hlsl">
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
    </FxCompile>
    <FxCompile Include="Resources\Shader\BasicVS.hlsl">
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Vertex</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Vertex</ShaderType>
    </FxCompile>
    <FxCompile Include="Resources\Shader\ObjPs.hlsl">
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
    </FxCompile>
    <FxCompile Include="Resources\Shader\ObjVs.hlsl">
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Vertex</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Vertex</ShaderType>
    </FxCompile>
    <FxCompile Include="Resources\Shader\ParticleGS.hlsl">
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Geometry</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Geometry</ShaderType>
    </FxCompile>
    <FxCompile Include="Resources\Shader\ParticlePS.hlsl">
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
    </FxCompile>
    <FxCompile Include="Resources\Shader\ParticleVS.hlsl">
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Vertex</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Vertex</ShaderType>
    </FxCompile>
    <FxCompile Include="Resources\Shader\PostEffectPS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
    </FxCompile>
    <FxCompile Include="Resources\Shader\PostEffectVS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Vertex</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
    </FxCompile>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

============================================================
File Path: SKNEngine.vcxproj.filters
============================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Draw">
      <UniqueIdentifier>{9d54e55c-0f9d-4e18-9ed5-642d55cbc355}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Core">
      <UniqueIdentifier>{77ce8447-efd4-48d7-9689-d9d2d0ad54be}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Core\Buff">
      <UniqueIdentifier>{c6fe266e-70c3-4365-b996-8e51e8613fbd}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Light">
      <UniqueIdentifier>{3401d413-dcd1-4be9-befc-780e286d1c72}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Colider">
      <UniqueIdentifier>{0faab10e-0a6e-4c5c-b944-862c0429f28c}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Draw\3D">
      <UniqueIdentifier>{4c00c98f-ab18-4d99-99c0-1d85d03f195e}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«">
      <UniqueIdentifier>{3e092d86-7bfc-4ec8-aa29-75a0a3d66a32}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Light">
      <UniqueIdentifier>{e6da4514-016e-424a-b910-6cf5888f8007}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\ImGui">
      <UniqueIdentifier>{ae288445-b3fd-4b77-8d7e-a813db61163c}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Draw">
      <UniqueIdentifier>{e924abe7-7692-4182-9bf0-763fca0b731f}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Draw\3D">
      <UniqueIdentifier>{e63c46e8-3fa7-4757-b910-a9073ff588ee}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Core">
      <UniqueIdentifier>{759e8d6f-6fbd-41d2-8b39-7be0b51d0c00}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Core\Buff">
      <UniqueIdentifier>{5e91cd97-467c-4942-8d92-e1909a496c18}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Colider">
      <UniqueIdentifier>{cdfa035b-e9c4-4da6-b634-24fe28a6a928}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Math">
      <UniqueIdentifier>{ca1ecb39-068f-4c32-8c97-47820f0fccb5}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Math">
      <UniqueIdentifier>{0c82af98-0703-4561-9afc-10cd7cd4cdbb}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Application">
      <UniqueIdentifier>{ba3e3440-3f02-4d71-acd3-b09d0eb71bc6}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Application">
      <UniqueIdentifier>{a1b050de-f4dc-4a8c-8be2-c9b5e64d48e0}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Application\Player">
      <UniqueIdentifier>{13722455-c04a-47b5-b6f8-11260d74bd92}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Application\Boss">
      <UniqueIdentifier>{936fcca4-26d5-40b7-a783-1c45430c6d69}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Application\Player">
      <UniqueIdentifier>{faf43234-2e25-47bd-abd0-79fcf7a085fd}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Application\Boss">
      <UniqueIdentifier>{287b7331-1827-49c2-9070-c65b6528bede}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Draw\2D">
      <UniqueIdentifier>{4cb83c5b-06e3-43d1-ab6d-7280b767827c}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Draw\2D">
      <UniqueIdentifier>{fe75b197-966d-4c6e-8e4d-6b0c49af6b6b}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="SourceCode\Engine\Core\DirectXCommon.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Core</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Engine\Core\DxWindow.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Core</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Engine\Core\DescriptorHeap.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Core</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Engine\Draw\TextureManager.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Draw</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Engine\Buffer\ConstBuffer.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Core\Buff</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Engine\Buffer\IndexBuffer.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Core\Buff</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Engine\Buffer\VertexBuffer.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Core\Buff</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Engine\Light\DirectionLight.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Light</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Engine\Light\LightGroup.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Light</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Engine\Light\PointLight.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Light</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Imgui\imgui.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\ImGui</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Imgui\imgui_demo.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\ImGui</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Imgui\imgui_draw.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\ImGui</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Imgui\imgui_tables.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\ImGui</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Imgui\imgui_widgets.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\ImGui</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Imgui\imgui_impl_dx12.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\ImGui</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Imgui\imgui_impl_win32.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\ImGui</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\App\Collision.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Colider</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Engine\Core\Pipeline.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Core</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Engine\Core\FPS.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Core</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Engine\Draw\ParticleManager.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Draw</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Engine\Core\ViewProjection.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Draw</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Engine\Core\WorldTronsform.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Draw</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Imgui\ImGuiManager.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Draw</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Engine\Core\Input.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Core</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\App\main.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Engine\Draw\3D\OBJ3D.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Draw\3D</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Engine\Draw\3D\ObjModel.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Draw\3D</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Engine\Draw\3D\Object3D.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Draw\3D</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Engine\Draw\3D\Model.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Draw\3D</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Engine\Draw\3D\FbxLoader.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Draw\3D</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Engine\Math\Vector2.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Math</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Engine\Math\Vector3.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Math</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Engine\Math\Matrix4.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Math</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Engine\Math\Float4.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Math</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\App\GameScene.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Application</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\App\Camera.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Application</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\App\StuructTransform.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Application</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\App\Enemy\BossEnemy.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Application\Boss</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\App\Player\Player.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Application\Player</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\App\Player\PlayerBullet.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Application\Player</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\App\Enemy\EnemyNormalBullet.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Application\Boss</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Engine\Draw\PostEffect.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Draw</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Engine\Math\myMath.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Math</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Engine\Math\Easing.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Math</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\App\Field.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Application</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Engine\Draw\3D\Draw3DLine.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Draw\3D</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Engine\Draw\2D\SpriteCommon.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Draw\2D</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Engine\Draw\2D\Sprite.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Draw\2D</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Engine\Draw\2D\Sprite2D.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Draw\2D</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\Engine\Draw\2D\DrawCommon.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Draw\2D</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\App\DeathParticle.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Application</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\App\Enemy\EnemyMine.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Application\Boss</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\App\BulletManager.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Application</Filter>
    </ClCompile>
    <ClCompile Include="SourceCode\App\UI.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\Application</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="SourceCode\Engine\Core\DirectXCommon.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Core</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Engine\Core\DxWindow.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Core</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Engine\Core\DescriptorHeap.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Core</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Engine\Draw\TextureManager.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Draw</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Engine\Buffer\ConstBuffer.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Core\Buff</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Engine\Buffer\IndexBuffer.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Core\Buff</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Engine\Buffer\VertexBuffer.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Core\Buff</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Engine\Light\DirectionLight.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Light</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Engine\Light\LightGroup.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Light</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Engine\Light\PointLight.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Light</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Imgui\imconfig.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\ImGui</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Imgui\imgui.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\ImGui</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Imgui\imgui_internal.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\ImGui</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Imgui\imstb_rectpack.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\ImGui</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Imgui\imstb_textedit.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\ImGui</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Imgui\imstb_truetype.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\ImGui</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Imgui\imgui_impl_dx12.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\ImGui</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Imgui\imgui_impl_win32.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\cppãƒ•ã‚¡ã‚¤ãƒ«\ImGui</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\App\CollisionPrimitive.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Colider</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\App\Collision.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Colider</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Engine\Core\Pipeline.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Core</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Engine\Core\FPS.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Core</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Imgui\ImGuiManager.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Draw</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Engine\Draw\ParticleManager.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Draw</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Engine\Core\ViewProjection.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Draw</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Engine\Core\WorldTronsform.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Draw</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Engine\Core\Input.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Core</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Engine\Draw\PostEffect.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Draw</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Engine\Draw\3D\OBJ3D.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Draw\3D</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Engine\Draw\3D\ObjModel.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Draw\3D</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Engine\Draw\3D\FbxLoader.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Draw\3D</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Engine\Draw\3D\Object3D.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Draw\3D</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Engine\Draw\3D\Model.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Draw\3D</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Engine\Math\Vector2.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Math</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Engine\Math\Vector3.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Math</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Engine\Math\Matrix4.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Math</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Engine\Math\Float4.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Math</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\App\Camera.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Application</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\App\GameScene.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Application</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\App\StuructTransform.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Application</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\App\Enemy\BossEnemy.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Application\Boss</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\App\Player\Player.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Application\Player</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\App\Player\PlayerBullet.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Application\Player</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\App\Enemy\EnemyNormalBullet.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Application\Boss</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Engine\Math\myMath.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Math</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Engine\Math\Easing.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Math</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\App\Field.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Application</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Engine\Draw\3D\Draw3DLine.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Draw\3D</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Engine\Draw\2D\Sprite2D.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Draw\2D</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Engine\Draw\2D\Sprite.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Draw\2D</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Engine\Draw\2D\SpriteCommon.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Draw\2D</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\Engine\Draw\2D\DrawCommon.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Draw\2D</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\App\DeathParticle.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Application</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\App\Enemy\EnemyMine.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Application\Boss</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\App\BulletManager.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Application</Filter>
    </ClInclude>
    <ClInclude Include="SourceCode\App\UI.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Application</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\Shader\Basic.hlsli">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </None>
    <None Include="Resources\Shader\Obj.hlsli">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </None>
    <None Include="Resources\Shader\Particle.hlsli">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </None>
    <None Include="Resources\Shader\FBX.hlsli">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </None>
    <None Include="Resources\Shader\PostEffect.hlsli">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </None>
    <None Include="Resources\Shader\3DLine.hlsli">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <FxCompile Include="Resources\Shader\BasicPS.hlsl">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\Shader\BasicVS.hlsl">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\Shader\ObjPs.hlsl">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\Shader\ObjVs.hlsl">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\Shader\ParticleGS.hlsl">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\Shader\ParticlePS.hlsl">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\Shader\ParticleVS.hlsl">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\Shader\FBXVS.hlsl">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\Shader\FBXPS.hlsl">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\Shader\PostEffectVS.hlsl">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\Shader\PostEffectPS.hlsl">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\Shader\3DLinePS.hlsl">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\Shader\3DLineVS.hlsl">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
  </ItemGroup>
</Project>

============================================================
File Path: SourceCode/App/BulletManager.cpp
============================================================
#include "BulletManager.h"

BulletManager::BulletManager()
{
}

BulletManager::~BulletManager()
{
}

void BulletManager::Initlize(const Vector3& position, const Vector3& rota, const Vector3& velocity)
{
	St->Wt.translation_ = position;
	St->Wt.rotation_ = rota;
	St->Wt.scale_ = { 0.5f,0.5f,0.5f };

	Velocity_ = velocity;
}

void BulletManager::Update()
{
}

void BulletManager::Draw()
{
}

void BulletManager::OnCollision()
{
	isDead_ = true;
}

Vector3 BulletManager::GetWorldPosition()
{
	return St->Wt.translation_;
}

Vector3 BulletManager::GetScale()
{
	return St->Wt.scale_;
}


============================================================
File Path: SourceCode/App/BulletManager.h
============================================================
#pragma once
#include "StuructTransform.h"
using namespace DirectX;

class BulletManager:public StuructTransform
{
public:


	BulletManager();
	virtual ~BulletManager();

	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="model">ãƒ¢ãƒ‡ãƒ«</param>
	/// <param name="position">åˆæœŸåº§æ¨™</param>
	/// <param name="velocity">é€Ÿåº¦</param>
	virtual void Initlize(const Vector3& position, const Vector3& rota, const Vector3& velocity);

	/// <summary>
	/// æ›´æ–°
	/// </summary>
	virtual void Update();

	/// <summary>
	/// æç”»
	/// </summary>
	/// <param name="viewProjection">ãƒ“ãƒ¥ãƒ¼ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³</param>
	virtual void Draw();

	virtual bool IsDead()const { return isDead_; }

	//è¡çªã‚’æ¤œå‡ºã—ãŸã‚‰å‘¼ã³å‡ºã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°
	virtual void OnCollision();

	Vector3 GetWorldPosition();
	Vector3 GetScale();
	Vector3 GetVec() { return Velocity_; }

private:


	//ãƒ¢ãƒ‡ãƒ«
	//StuructTransform bullet;


	//ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒãƒ³ãƒ‰ãƒ«


	//é€Ÿåº¦
	Vector3 Velocity_;


	//ãƒ‡ã‚¹ãƒ•ãƒ©ã‚°
	bool isDead_ = false;





};



============================================================
File Path: SourceCode/App/Camera.cpp
============================================================
#include "Camera.h"
#include <cmath>
#include"Input.h"

void Camera::Initialize(ID3D12Device* Device)
{
	wt.CreateConstBuffer(Device);
	wt.translation_ = { 0.0f,0.0f,0.0f };
	wt.rotation_ = { 0.0f,0.0f,0.0f };
	wt.scale_ = { 1.0f,1.0f,1.0f };
}

void Camera::Reset()
{
	wt.translation_ = { 0.0f,0.0f,0.0f };
	wt.rotation_ = { 0.0f,0.0f,0.0f };
	wt.scale_ = { 1.0f,1.0f,1.0f };
	setRotate({ 0,0,0 });
	viewProjection_.Initialize();

	cameraRotateX = 0;
	cameraRotateY = 0;
	rotateX = 0;
	rotateY = 0;

	/*if (targetWT)
	{
		interTarget = targetWT->translation_;
		wt.rotation_.y = targetWT->rotation_.y;
	}*/


	targetWT = nullptr;
}

void Camera::Update()
{

	wt.UpdateMatrix(&viewProjection_);

	viewProjection_.SetEye(wt.translation_);

	//ãƒ¯ãƒ¼ãƒ«ãƒ‰å‰æ–¹ãƒ™ã‚¯ãƒˆãƒ«
	forward = { 0.0f, 0.0f, 1.0f };

	//ãƒ¬ãƒ¼ãƒ«ã‚«ãƒ¡ãƒ©ã®å›žè»¢ã‚’åæ˜ 
	forward = forward*wt.matWorld_;

	//è¦–ç‚¹ã‹ã‚‰å‰æ–¹ã«é©å½“ãªè·é›¢é€²ã‚“ã ä½ç½®ãŒæ³¨è¦–ç‚¹
	viewProjection_.SetTarget(viewProjection_.Geteye() + forward);

	//ãƒ¯ãƒ¼ãƒ«ãƒ‰ä¸Šæ–¹ãƒ™ã‚¯ãƒˆãƒ«
	Vector3 up(0, 1, 0);

	//ãƒ¬ãƒ¼ãƒ«ã‚«ãƒ¡ãƒ©ã®å›žè»¢ã‚’åæ˜ (ãƒ¬ãƒ¼ãƒ«ã‚«ãƒ¡ãƒ©ã®ä¸Šæ–¹ãƒ™ã‚¯ãƒˆãƒ«)
	viewProjection_.SetUp(up*wt.matWorld_);

	if (targetWT)
	{
		Vector3 offset = { -20.0f,20.0f,-20.0f };

		Vector2 inputnum = Input::GetRStick(true, true);
		cameraRotateY += (float)inputnum.x * cameraDPI;
		if ((cameraRotateX < 0.27f && (float)inputnum.y / SHRT_MAX>0) || (cameraRotateX > -0.6f && (float)inputnum.y / SHRT_MAX < 0))
		{
			cameraRotateX += (float)inputnum.y * cameraDPI;
			
		}

		Vector3 cameraPoint = targetWT->translation_;

		cameraPoint.y += 5.0f;
		

		offset.x = offset.x * sinf(cameraRotateY);
		offset.z = offset.z * cosf(cameraRotateY);
		offset.y = offset.y * sinf(-cameraRotateX);



		
		viewProjection_.SetEye(cameraPoint + offset);
		
		viewProjection_.SetTarget(cameraPoint);

		forward = cameraPoint - (cameraPoint + offset);


	}


	viewProjection_.Update();

}

ViewProjection* Camera::getView()
{
	return &viewProjection_;
}

Matrix4 Camera::getMatWorld()
{
	return wt.matWorld_;
}

Vector3 Camera::getForwardVec()
{

	return forward.getnormalize();
}


void Camera::setPos(Vector3 pos)
{
	wt.translation_ = pos;
	wt.UpdateMatrix(&viewProjection_);
}

void Camera::setTarget(Vector3 Target)
{
	viewProjection_.SetTarget(Target);
}

void Camera::setRotate(Vector3 rotate)
{
	wt.rotation_ = rotate;
	wt.UpdateMatrix(&viewProjection_);
}

void Camera::setWorldMat(Matrix4 woeldMat)
{
	wt.matWorld_ = woeldMat;
}




============================================================
File Path: SourceCode/App/Camera.h
============================================================
#pragma once
#include <d3d12.h>
#include "WorldTronsform.h"
#include "ViewProjection.h"
#include"myMath.h"

class Camera
{
public:
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="worldTransform">ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™</param>
	/// <param name="Rot">å›žè»¢è§’(ãƒ©ã‚¸ã‚¢ãƒ³)</param>
	void Initialize(ID3D12Device* Device);

	void Reset();

	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void Update();

	ViewProjection* getView();

	Matrix4 getMatWorld();

	Vector3 getForwardVec();



	void setPos(Vector3 pos);

	void setTarget(Vector3 Target);
	/// <summary>
	/// ã‚«ãƒ¡ãƒ©ã«è¿½å¾“å…ˆã®ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã‚’æ¸¡ã™
	/// </summary>
	void setTarget(WorldTransform* target) { targetWT = target; }

	void setRotate(Vector3 rotate);

	void setWorldMat(Matrix4 woeldMat);

private:

	const WorldTransform* targetWT = nullptr;

	ViewProjection viewProjection_;

	//ãƒ¯ãƒ¼ãƒ«ãƒ‰å¤‰æ›ãƒ‡ãƒ¼ã‚¿(é©å½“èª­ã¿è¾¼ã¿)
	WorldTransform wt;

	//ãƒ“ãƒ¥ãƒ¼ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³

	Vector3 forward = { 0.0f, 0.0f, 1.0f };

	Vector3 interTarget = {};

	float cameraRotateX = 0;
	float cameraRotateY = 0;
	float rotateX = 0;
	float rotateY = 0;

	const float cameraDPI = 0.05f;

};



============================================================
File Path: SourceCode/App/Collision.cpp
============================================================
#include "Collision.h"

bool Collision::CheckSphere2Plane(const Sphere& sphere, const Plane& plane, Vector3* inter)
{
	float distV = sphere.center.dot(plane.normal);

	float dist = distV - plane.distance;

	if (fabsf(dist) > sphere.radius)
	{
		return false;
	}

	if (inter)
	{
		*inter = -dist * plane.normal + sphere.center;
	}

	return true;
}

void Collision::ClosestPtPoint2Triangle(const Vector3& point, const Triangle& triangle, Vector3* closest)
{
	Vector3 p0_p1 = triangle.p1 - triangle.p0;
	Vector3 p0_p2 = triangle.p2 - triangle.p0;
	Vector3 p0_pt = point - triangle.p0;

	float d1 = p0_p1.dot(p0_pt);
	float d2 = p0_p2.dot(p0_pt);

	if (d1 <= 0.0f && d2 <= 0.0f)
	{
		*closest = triangle.p0;
		return;
	}
	
	Vector3 p1_p0 = triangle.p0 - triangle.p1;
	Vector3 p1_p2 = triangle.p2 - triangle.p1;

	Vector3 p1_pt = point - triangle.p1;

	float d3 = p1_p0.dot(p1_pt);
	float d4 = p1_p2.dot(p1_pt);

	if (d3>= 0.0f && d4<= d3)
	{
		*closest = triangle.p1;
		return;
	}

	float vc = d1* d4 - d3 * d2;
	if (vc <= 0.0f && d1>= 0.0f && d3 <= 0.0f)
	{
		float v = d1/ (d1- d3);
		*closest = triangle.p0 + v * p0_p1;
		return;
	}
	Vector3 p2_p0 = triangle.p0 - triangle.p2;
	Vector3 p2_p1 = triangle.p1 - triangle.p2;

	
	Vector3 p2_pt = point - triangle.p2;

	float d5 = p2_p0.dot(p2_pt);
	float d6 = p2_p1.dot(p2_pt);
	if (d6>= 0.0f && d5<= d6)
	{
		*closest = triangle.p2;
		return;
	}

	float vb = d5* d2- d1 * d6;
	if (vb <= 0.0f && d2>= 0.0f && d6<= 0.0f)
	{
		float w = d2/ (d2- d6);
		*closest = triangle.p0 + w * p0_p2;
		return;
	}

	float va = d3 * d6 - d5 * d4;
	if (va <= 0.0f && (d4 - d3) >= 0.0f && (d5 - d6) >= 0.0f)
	{
		float w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
		*closest = triangle.p1 + w * (triangle.p2 - triangle.p1);
		return;
	}

	float denom = 1.0f / (va + vb + vc);
	float v = vb * denom;
	float w = vc * denom;
	*closest = triangle.p0 + p0_p1 * v + p0_p2 * w;
}

bool Collision::CheckSphere2Triangle(const Sphere& sphere, const Triangle& triangle, Vector3* inter)
{
	Vector3 p;

	ClosestPtPoint2Triangle(sphere.center, triangle, &p);

	Vector3 v = p - sphere.center;

	float vf = v.dot(v);

	if (vf > sphere.radius * sphere.radius)
	{
		return false;
	}
	if (inter)
	{
		*inter = p;
	}


	return true;
}

bool Collision::CheckRay2Plane(const Ray& ray, const Plane& plane, float* distance, Vector3* inter)
{
	const float epslion = 1.0e-5f;

	float d1 = plane.normal.dot(ray.dir);

	if (d1 > -epslion)
	{
		return false;
	}

	float d2 =plane.normal.dot(ray.start);

	float dist = d2 - plane.distance;

	float t = dist / -d1;

	if (t < 0)
	{
		return false;
	}

	if (distance)
	{
		*distance = t;
	}

	if (inter)
	{
		*inter = ray.start + t * ray.dir;
	}

	return true;
}

bool Collision::CheckRay2Triangle(const Ray& ray, const Triangle& triangle, float* distance, Vector3* inter)
{
	Plane plane;
	Vector3 interPlane;

	plane.normal = triangle.normal;

	plane.distance = triangle.normal.dot(triangle.p0);

	if (!CheckRay2Plane(ray, plane, distance, &interPlane))
	{
		return false;
	}

	const float epsilon = 1.0e-5f;
	Vector3 m;

	Vector3 pt_p0 = triangle.p0 - interPlane;
	Vector3 p0_p1 = triangle.p1 - triangle.p0;
	m = pt_p0.cross(p0_p1);
	if (m.dot(triangle.normal) < -epsilon)
	{
		return false;
	}
	Vector3 pt_p1 = triangle.p1 - interPlane;
	Vector3 p1_p2 = triangle.p2 - triangle.p1;
	m = pt_p1.cross(p1_p2);
	if (m.dot(triangle.normal) < -epsilon)
	{
		return false;
	}
	Vector3 pt_p2 = triangle.p2 - interPlane;
	Vector3 p2_p0 = triangle.p0 - triangle.p2;
	m = pt_p2.cross(p2_p0);
	if (m.dot(triangle.normal) < -epsilon)
	{
		return false;
	}

	if (inter)
	{
		*inter = interPlane;
	}


	return true;;
}

bool Collision::CheckRay2Sphere(const Ray& ray, const Sphere& sphere, float* distance, Vector3* inter)
{
	Vector3 m = ray.start - sphere.center;
	float b = m.dot( ray.dir);
	float c = m.dot( m) - sphere.radius * sphere.radius;

	if (c > 0.0f && b > 0.0f)
	{
		return false;
	}

	float discr = b * b - c;

	if (discr < 0.0f)
	{
		return false;
	}

	float t = -b - sqrtf(discr);

	if (t < 0)
	{
		t = 0.0f;
	}
	if(distance)
	{
		*distance = t;
	}
	if (inter)
	{
		*inter = ray.start + t * ray.dir;
	}
	


	return true;
}

bool Collision::CheckSphereToSphere(const Sphere& sphere, const Sphere& sphere2)
{

	Vector3 a = sphere2.center - sphere.center;

	


	if (a.length() < sphere.radius + sphere2.radius)
	{
		return true;
	}


	return false;
}


============================================================
File Path: SourceCode/App/Collision.h
============================================================
#pragma once
#include"CollisionPrimitive.h"

class Collision
{
public:
	static bool CheckSphere2Plane(const Sphere& sphere, const Plane& plane, Vector3* inter = nullptr);

	static void ClosestPtPoint2Triangle(const Vector3& point, const Triangle& triangle, Vector3* closest);

	static bool CheckSphere2Triangle(const Sphere& sphere, const Triangle& triangle, Vector3* inter = nullptr);

	static bool CheckRay2Plane(const Ray& ray, const Plane& plane, float* distance = nullptr, Vector3* inter = nullptr);

	static bool CheckRay2Triangle(const Ray& ray, const Triangle& triangle, float* distance = nullptr, Vector3* inter = nullptr);

	static bool CheckRay2Sphere(const Ray& ray, const Sphere& sphere, float* distance = nullptr, Vector3* inter = nullptr);

	static bool CheckSphereToSphere(const Sphere& sphere, const Sphere& sphere2);
};



============================================================
File Path: SourceCode/App/CollisionPrimitive.h
============================================================
#pragma once

#include"myMath.h"
struct Sphere
{
	Vector3 center = { 0,0,0};

	float radius = 1.0f;
};

struct Plane
{
	Vector3 normal = { 0,1,0};

	float distance = 0.0f;
};

class Triangle
{
public:
	Vector3 p0;
	Vector3 p1;
	Vector3 p2;

	Vector3 normal;
};

struct Ray
{
	Vector3 start = { 0,0,0};

	Vector3 dir = { 1,0,0};
};

============================================================
File Path: SourceCode/App/DeathParticle.cpp
============================================================
#include "DeathParticle.h"
#include <iostream>
#include <random>
#include"Easing.h"
#include"Player.h"
#include"myMath.h"
std::unique_ptr<ObjModel> DeathParticle::Premodel;

DeathParticle::DeathParticle()
{
	ModelInit(Premodel.get());
	Velocity_ = { 0,0,0 };
}

DeathParticle::~DeathParticle()
{
}

void DeathParticle::SetModel(ObjModel* model)
{
	Premodel.reset(model);
}

void DeathParticle::CreateDeathParticle(const Vector3& position, const Vector3& rota, const Vector3& velocity, float _scale, Float4 color)
{
	St->Wt.translation_ = position;
	St->Wt.rotation_ = rota;
	startScale = _scale;
	scale = 0;
	St->Wt.scale_ = { startScale,startScale,startScale };
	St->color =color;

	std::random_device rd;
	std::default_random_engine eng(rd());
	std::default_random_engine eng2(rd());
	std::default_random_engine eng3(rd());
	std::uniform_real_distribution<float> distr(-180.0f, 180.0f);

	romdom = { distr(eng),distr(eng2),distr(eng3) };

	romdom.normalize();
	romdom *= spead;

	mode = Pattern::SCATTER;

	Velocity_ = velocity;
}

void DeathParticle::CreateHitParticle(const Vector3& position, const Vector3& rota, const Vector3& velocity, float _scale, Float4 color)
{
	St->Wt.translation_ = position;
	St->Wt.rotation_ = rota;
	startScale = _scale;
	scale = 0;
	St->Wt.scale_ = { startScale,startScale,startScale };
	St->color = color;
	Velocity_ = velocity;
	Velocity_.y = 0;
	Velocity_.normalize();

	std::random_device rd;
	std::default_random_engine eng(rd());
	std::default_random_engine eng2(rd());
	std::default_random_engine eng3(rd());
	std::uniform_real_distribution<float> distr(-60.0f, 60.0f);

	romdom = { distr(eng),distr(eng2),distr(eng3) };

	Matrix4 rotaMat;

	

	rotaMat *= Matrix4::RotationY(distr(eng));
	rotaMat *= Matrix4::RotationX(distr(eng2));

	mode = Pattern::HIT;
	kLifeTime = 30;
	deathTimer_ = kLifeTime;

	Velocity_ = Velocity_ * rotaMat;

	Velocity_.normalize();
	romdom *= spead;
	Velocity_ *= (spead*2);
}

void DeathParticle::Update()
{
	switch (mode)
	{
	case Pattern::STRAIGHT:


		break;

	case Pattern::HIT:
		scale = easeInSine(0, startScale, static_cast<float>(deathTimer_), static_cast<float>(kLifeTime));
		//St->color.z = easeInSine(0, 1.0f, static_cast<float>(deathTimer_), static_cast<float>(kLifeTime));
		St->Wt.translation_ = St->Wt.translation_ + Velocity_;
		St->Wt.rotation_ = St->Wt.rotation_ + romdom;
		St->Wt.scale_ = { scale,scale,scale };

		break;
	case Pattern::SCATTER:

		scale = easeInSine(0, startScale, static_cast<float>(deathTimer_), static_cast<float>(kLifeTime));
		St->color.z= easeInSine(0, 1.0f, static_cast<float>(deathTimer_), static_cast<float>(kLifeTime));
		St->Wt.translation_ = St->Wt.translation_ + romdom;
		St->Wt.rotation_ = St->Wt.rotation_ + romdom;
		St->Wt.scale_ = { scale,scale,scale };
		break;
	}

	St->Update(camera->getView());
	if (deathTimer_ <= 0)
	{
		deathTimer_ = 0;
	}

	//ãƒ‡ã‚¹ã‚¿ã‚¤ãƒžãƒ¼ã‚’ã²ã„ã¦0ä»¥ä¸‹ã«ãªã£ãŸã‚‰ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
	if (--deathTimer_ <= 0)
	{
		isDead_ = true;
	}

}

void DeathParticle::Draw()
{
	St->Draw();
}

void DeathParticle::Death()
{
	isDead_ = true;
}


============================================================
File Path: SourceCode/App/DeathParticle.h
============================================================
#pragma once
#include "StuructTransform.h"
using namespace DirectX;

enum struct Pattern
{
	STRAIGHT,
	HIT,
	SCATTER
};

class DeathParticle :public StuructTransform
{

public:
	DeathParticle();
	~DeathParticle();

	static void SetModel(ObjModel* model);

	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="model">ãƒ¢ãƒ‡ãƒ«</param>
	/// <param name="position">åˆæœŸåº§æ¨™</param>
	/// <param name="velocity">é€Ÿåº¦</param>
	void CreateDeathParticle(const Vector3& position, const Vector3& rota, const Vector3& velocity,float _scale,Float4 color);

	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="model">ãƒ¢ãƒ‡ãƒ«</param>
	/// <param name="position">åˆæœŸåº§æ¨™</param>
	/// <param name="velocity">é€Ÿåº¦</param>
	void CreateHitParticle(const Vector3& position, const Vector3& rota, const Vector3& velocity, float _scale, Float4 color);

	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void Update();

	/// <summary>
	/// æç”»
	/// </summary>
	/// <param name="viewProjection">ãƒ“ãƒ¥ãƒ¼ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³</param>
	void Draw();

	bool IsDead()const { return isDead_; }

	//è¡çªã‚’æ¤œå‡ºã—ãŸã‚‰å‘¼ã³å‡ºã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°
	void Death();

private:

	static std::unique_ptr<ObjModel> Premodel;

	Vector3 romdom = { 0,0,0 };

	const float spead = 0.3f;

	float startScale = 0;

	float scale = 0;

	//ãƒ¢ãƒ‡ãƒ«
	//StuructTransform bullet;


	//ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒãƒ³ãƒ‰ãƒ«


	//é€Ÿåº¦
	Vector3 Velocity_;

	//å¯¿å‘½<frm>
	int32_t kLifeTime = 60;

	//ãƒ‡ã‚¹ã‚¿ã‚¤ãƒžãƒ¼
	int32_t deathTimer_ = kLifeTime;

	//ãƒ‡ã‚¹ãƒ•ãƒ©ã‚°
	bool isDead_ = false;

	Pattern mode = Pattern::SCATTER;

};



============================================================
File Path: SourceCode/App/Enemy/BossEnemy.cpp
============================================================
#include "BossEnemy.h"
#include"ImGuiManager.h"
#include"Easing.h"
#include"Field.h"
#include"myMath.h"
#include <random>
#include<cmath>

#include <iostream>     // cout
#include <ctime>        // time
#include <cstdlib>      // srand,rand

BossEnemy::BossEnemy()
{
}

void BossEnemy::Init()
{
	ModelInit("enemy");
	EnemyNormalBullet::SetModel(ObjModel::LoadFromOBJ("maru"));
	EnemyMine::SetModel(ObjModel::LoadFromOBJ("maru"));
	//St->Wt.scale_ = { 20.0f,20.0f,20.0f };
	St->color = { 1.0f,1.0f,1.0f,1.0f };
	LeserPoint.Init();
	HP = MaxHP;

	colBox.reset(OBJ3D::Create());
	colBox->SetModel(ObjModel::LoadFromOBJ("maru"));


	HpBarHandle = texMana->LoadTexture("Resources/HpBar.png");


	colBox->Wt.scale_ = St->Wt.scale_;
	colBox->color = { 1.0f,1.0f,1.0f,1.0f };


	sprite_HPbar = std::make_unique<Sprite2D>();
	sprite_HPbar->Initialize(spCommon, HpBarHandle);
	sprite_HPbar->Wt.translation_ = { DxWindow::window_width / 2.0f,DxWindow::window_height / 22.5f ,0.0f };
	sprite_HPbar->Wt.scale_.x = 30.0f;
	sprite_HPbar->Wt.color = { 1.0f,0.0f,0.0f,1.0f };

}

void BossEnemy::Reset()
{

	
	LeserPoint.Init();
	St->Wt.translation_ = { 0,0.0f,20.0f };
	HP = MaxHP;
	//ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚„å¼¾å‘¨ã‚Šã®åˆæœŸåŒ–
	const std::list<std::unique_ptr<EnemyNormalBullet>>& Bullets = GetBullets();
	for (const std::unique_ptr<EnemyNormalBullet>& bullet : Bullets)
	{

		bullet->OnCollision();

	}
	const std::list<std::unique_ptr<EnemyMine>>& Mines = GetMines();
	for (const std::unique_ptr<EnemyMine>& mine : Mines)
	{

		mine->Destoroy();

	}
	//å¼¾æ¶ˆã—é–¢æ•°
	Bulletremove();
	//æ­»äº¡æ™‚ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«åˆæœŸåŒ–
	const std::list<std::unique_ptr<DeathParticle>>& Dps = GetDps();
	for (const std::unique_ptr<DeathParticle>& Dp : Dps)
	{

		Dp->Death();

	}

	deathPaticles.remove_if([](std::unique_ptr<DeathParticle>& dp)
		{
			return dp->IsDead();
		});

	//å„ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿åˆæœŸåŒ–
	BossAtk = AtkPattern::MISSILE;
	BossMove = MovePattern::NONE;
	chargeMoveAniTimer = 0;
	chargeCool = 0;
	mineCool = 0;
	TargetTimer = 0;
	MoveTimer = 0;
	stopTimer = 0;
	WaitTimer = 0;
	endFlag = false;
	DeathTimer = 0;

	aimingTargetPos = { 0,0,0 };

	rotaVec = { 0,0,1.0f };
	DpRate = 0;
	scale = 4.0f;
	criAimTimer = 0;
	crossLine = 0;
	//St->Wt.scale_ = { scale,scale,scale };
}

void BossEnemy::Update(bool flag)
{
	//å¼¾ã‚„ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’æ¶ˆã—ã¦ã„ã
	Bulletremove();
	deathPaticles.remove_if([](std::unique_ptr<DeathParticle>& dp)
		{
			return dp->IsDead();
		});

	//æ­»ã‚“ã ã¨ã
	if (Death())
	{
		DeathAnimetion();
	}

	//å¹³é¢ä¸Šã®è·é›¢
	Vector3 plUnderPos = player->GetUnderPos() - St->Wt.translation_;
	Lange = plUnderPos.length();

	sprite_HPbar->Wt.scale_.x = (30.0f * HP / MaxHP);

	St->Wt.translation_.y -= 0.5f;

	//åœ°é¢æŠ¼ã—æˆ»ã—
	if (St->Wt.translation_.y - (St->Wt.scale_.y/3.0f) < 0.0f)
	{
		St->Wt.translation_.y = (St->Wt.scale_.y / 3.0f);
	}

	chargeCool--;
	mineCool--;

	//çªé€²ã—ã¦ãªã„ã¨ãã®åŸºæœ¬çš„ãªè¡Œå‹•ãƒ†ãƒ¼ãƒ–ãƒ«
	if (BossAtk != AtkPattern::CHARGE&&!flag&&!Death())
	{
		
		
		Vector3 Flont = { 0,0,1.0f };
		Flont.normalize();
		plUnderPos.normalize();
		

		float p_pos = atan2(plUnderPos.x, plUnderPos.z);
		float c_vec = atan2(Flont.x, Flont.z);

		St->Wt.rotation_.y = (p_pos + c_vec);

		//è¡Œå‹•state
		switch (BossMove)
		{
		case MovePattern::NONE:

			//stopTimer = stopTime;
			MoveTable();
			break;
		case MovePattern::BACK:
			BackMove();
			break;
		case MovePattern::CLOSEMOVE:
			CloseMove();
			break;
		}
	}

	if (!flag && !Death())
	{
		aiming();
		//æ”»æ’ƒstate
		switch (BossAtk)
		{
		case AtkPattern::NONE:

			AimMode = false;
			WaitTimer = WaitTimer;
			AtkTable();

			break;
		case AtkPattern::SIMPLESHOT:

			SimpleShot();

			break;
		case AtkPattern::CHARGE:


			ChargeAtk();
			break;
		case AtkPattern::HARDSHOT:
			HardShot();
			break;
		case AtkPattern::MISSILE:

			break;
		case AtkPattern::MINE:
			MineAttack();
			break;
		}
	}

	//å¼¾æ›´æ–°
	for (std::unique_ptr<EnemyNormalBullet>& bullet : Normalbullets_)
	{
		bullet->Update();
	}

	for (std::unique_ptr<EnemyMine>& mine : Mines_)
	{
		mine->Update();
	}


	//ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ›´æ–°
	for (std::unique_ptr<DeathParticle>& dp : deathPaticles)
	{
		dp->Update();
	}


#ifdef _DEBUG
	ImGuiSet();
#endif

	//ã‚¨ãƒªã‚¢å¤–è¡Œã‹ãªã„ã‚ˆã†ã«
	if (St->Wt.translation_.x + St->Wt.scale_.x > Field::GetArea() || St->Wt.translation_.x - St->Wt.scale_.x < -Field::GetArea())
	{
		St->Wt.translation_.x = Field::GetArea() - St->Wt.scale_.x * (abs(St->Wt.translation_.x) / St->Wt.translation_.x);
	}
	if (St->Wt.translation_.z + St->Wt.scale_.z >= Field::GetArea() || St->Wt.translation_.z - St->Wt.scale_.z <= -Field::GetArea())
	{
		St->Wt.translation_.z = Field::GetArea() - St->Wt.scale_.z * (abs(St->Wt.translation_.z) / St->Wt.translation_.z);
	}

	colBox->Wt = St->Wt;

	St->Update(camera->getView());
	colBox->Update(camera->getView());
	sprite_HPbar->Update();
}

void BossEnemy::Damege(float dmg)
{
	HP -= dmg;
}

void BossEnemy::Draw()
{
	for (std::unique_ptr<EnemyNormalBullet>& bullet : Normalbullets_)
	{
		bullet->Draw();
	}
	for (std::unique_ptr<EnemyMine>& mine : Mines_)
	{
		mine->Draw();
	}
	for (std::unique_ptr<DeathParticle>& dp : deathPaticles)
	{
		dp->Draw();
	}

	St->Draw();
	if (colLock)
	{

		colBox->Draw();
	}
	
	//ç™½ç·šæç”»
	if (AimMode)
	{
		LeserPoint.Draw(St->Wt.translation_, TargetPos);
	}
}

void BossEnemy::DrawUI()
{
	if (HP > 0)
	{
		sprite_HPbar->Draw();
	}
}

void BossEnemy::HitParticle(Vector3 vec)
{
	for (size_t i = 0; i < 10; i++)
	{
		std::unique_ptr <DeathParticle> newBullet = std::make_unique<DeathParticle>();
		newBullet->CreateHitParticle(St->Wt.translation_, St->Wt.rotation_, vec, 2.0f, { 1.f,0.0f,0.0f,1.0f });

		deathPaticles.push_back(std::move(newBullet));
	}
}

void BossEnemy::AtkTable()
{
	//æ”»æ’ƒé–“ã®ã‚¯ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ å‚ç…§
	if (WaitTimer < 0)
	{
		//çªé€²æ”»æ’ƒã®ãƒ¬ãƒ³ã‚¸ã«ã„ãªã„ã¨ã
		if (Lange > LangeMax)
		{
			mt19937 mt{ random_device{}() };

			uniform_int_distribution<int> dist(1, 6);

			int aktmode = dist(mt);

			if (aktmode >=2)
			{
				TargetTimer = TargetTime;
				BossAtk = AtkPattern::SIMPLESHOT;
				BurstTime = BurstNum * BurstRate;
			}
			else
			{
				TargetTimer = TargetTime;
				BossAtk = AtkPattern::HARDSHOT;
				BurstTime = BurstNum * BurstRate;
			}


			

		}
		//çªé€²æ”»æ’ƒç¯„å›²å†…
		if (Lange < LangeMax)
		{
			if (chargeCool < 0)
			{
				

				
				BossAtk = AtkPattern::CHARGE;
				prePos = St->Wt.translation_;
				prePos.y = 0;
				TargetVec = player->GetPos() - St->Wt.translation_;
				TargetVec.y = 0;
				chargeLenge = TargetVec.length();
				TargetVec.normalize();
				chargeCool = chargeCoolTime;
				chargeMoveAniTimer = chargeMoveAniTime;
				

				
			}
			else if(mineCool<0)
			{
				BossAtk = AtkPattern::MINE;
				TargetVec = player->GetPos() - St->Wt.translation_;
				TargetVec.y = 0;
				TargetVec.normalize();
				mineThrowTimer = 0;
				mineThrowDeg = 0;
				mineCool = mineCoolTime;

				

			}
			else if(mineCool>0&& chargeCool>0)
			{
				TargetTimer = TargetTime;
				BossAtk = AtkPattern::SIMPLESHOT;
				BurstTime = BurstNum * BurstRate;
			}


		}

	}
	//æ”»æ’ƒé–“ã®ã‚¯ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³
	WaitTimer--;
}

void BossEnemy::MoveTable()
{
	if (stopTimer < 0)
	{
		bool TimeRand = rand() % 1;
		if (Lange > LangeMax)
		{
			BossMove = MovePattern::CLOSEMOVE;
			
		}
		else
		{
			BossMove = MovePattern::BACK;
		}

		if (TimeRand)
		{
			MoveTimer = LongMoveTime;
		}
		else
		{
			MoveTimer = MidMoveTime;
		}
	}

	stopTimer--;

}

void BossEnemy::BackMove()
{
	Vector3 moveVec = St->Wt.translation_ - player->GetPos();
	moveVec.y = 0;

	moveVec.normalize();

	moveVec *= 0.4f;

	St->Wt.translation_ += moveVec;

	MoveTimer--;
	if (MoveTimer < 0) { BossMove = MovePattern::NONE; }
}

void BossEnemy::CloseMove()
{
	Vector3 moveVec = player->GetPos() - St->Wt.translation_;
	moveVec.y = 0;

	moveVec.normalize();

	moveVec *= 0.4f;

	St->Wt.translation_ += moveVec;


	MoveTimer--;
	if (MoveTimer < 0) { BossMove = MovePattern::NONE; }
}


void BossEnemy::SimpleShot()
{

	Vector3 BulletVec;
	//ç…§æº–æ™‚é–“
	if (TargetTimer > 0)
	{
		if (TargetTimer > 10)
		{
			TargetPos = player->GetPos();

		}
		TargetTimer--;
		AimMode = true;
	}
	else//ç…§æº–çµ‚ã‚ã‚Šæ™‚ã®æ”»æ’ƒ
	{
		

		AimMode = false;
		if (CriticalAim)
		{
			BulletVec = aimingTargetPos - St->Wt.translation_;
		}
		else
		{
			BulletVec = player->GetPos() - St->Wt.translation_;
		}
		BulletVec.normalize();

		BulletVec *= nBulletSpeed;
		
		

		//ç™ºå°„ãƒ¬ãƒ¼ãƒˆ
		if (BurstTime % BurstRate == 0)
		{
			std::unique_ptr <EnemyNormalBullet> newBullet = std::make_unique<EnemyNormalBullet>();
			newBullet->Initlize(St->Wt.translation_, St->Wt.rotation_, BulletVec);

			Normalbullets_.push_back(std::move(newBullet));

		}
		BurstTime--;
		//å°„æ’ƒæ™‚é–“çµ‚ã‚ã£ãŸã‚‰
		if (BurstTime <= 0)
		{
			BossAtk = AtkPattern::NONE;

		}
	}

}

void BossEnemy::ChargeAtk()
{


	Vector3 chargeMoved = St->Wt.translation_ - prePos;
	chargeMoved.y = 0;

	St->Wt.translation_ += TargetVec * 1.5f;

	if (chargeLenge + 5.0f < chargeMoved.length())
	{
		BossAtk = AtkPattern::NONE;
	}


}

void BossEnemy::HardShot()
{
	//ç…§æº–
	if (TargetTimer > 0)
	{
		if (TargetTimer > 10)
		{
			TargetPos = aimingTargetPos;

		}
		TargetTimer--;
		AimMode = true;
	}
	else
	{
		
		AimMode = false;
		Vector3 BulletVec = player->GetPos() - St->Wt.translation_;
		BulletVec.normalize();

		Matrix4 matRot[3];

		

		// ã‚¹ã‚±ãƒ¼ãƒ«ã€å›žè»¢ã€å¹³è¡Œç§»å‹•è¡Œåˆ—ã®è¨ˆç®—
		matRot[0] *= Matrix4::RotationX(5.0f);
		matRot[1] *= Matrix4::RotationX(-5.0f);;
		matRot[2] *= Matrix4::RotationX(0);

		for (size_t i = 0; i < 3; i++)
		{
			Vector3 HardBullet = BulletVec * matRot[i];
			HardBullet.normalize();
			HardBullet *= hBulletSpeed;

			std::unique_ptr <EnemyNormalBullet> newBullet = std::make_unique<EnemyNormalBullet>();
			newBullet->Initlize(St->Wt.translation_, St->Wt.rotation_, HardBullet);

			Normalbullets_.push_back(std::move(newBullet));

		}
		
		BossAtk = AtkPattern::NONE;

		
	}
}

void BossEnemy::MissileShot()
{




}

void BossEnemy::MineAttack()
{
	Vector3 throwVec = { 0,0,0 };

	

	if (mineThrowTimer == 0)
	{
		for (size_t i = 0; i < mineNum; i++)
		{

			size_t preMineNum = 60*i;

			float deg = XMConvertToRadians(static_cast<float>(preMineNum));

			throwVec.x = TargetVec.x * cosf(deg) - TargetVec.z * sinf(deg);

			throwVec.z = TargetVec.x * sinf(deg) + TargetVec.z * cosf(deg);

			throwVec.normalize();
			throwVec *= 1.0f;

			std::unique_ptr <EnemyMine> newMine = std::make_unique<EnemyMine>();
			newMine->Initlize(St->Wt.translation_, St->Wt.rotation_, throwVec);

			Mines_.push_back(std::move(newMine));

		}
	}

	mineThrowTimer++;
	
	mineThrowDeg = easeOutQuint(0.0, 360.0f, static_cast<float>(mineThrowTimer), static_cast<float>(mineThrowTime));

	St->Wt.rotation_.y += XMConvertToRadians(mineThrowDeg);

	
	

	if (mineThrowTimer >= mineThrowTime)
	{
		
		mineThrowTimer = mineThrowTime;
		mineThrowDeg = 0;
		BossAtk = AtkPattern::NONE;
	}


}

void BossEnemy::ImGuiSet()
{
	//ImguI
	ImGui::SetNextWindowPos({ ImGui::GetMainViewport()->WorkPos.x + 400, ImGui::GetMainViewport()->WorkPos.y + 10 }, ImGuiCond_Once);
	ImGui::SetNextWindowSize({ 400, 500 });

	ImGuiWindowFlags window_flags = 0;
	window_flags |= ImGuiWindowFlags_NoResize;
	ImGui::Begin("Boss", NULL, window_flags);
	ImGui::Text("Scale_X::%5.2f", St->Wt.scale_.x);
	ImGui::Text("Scale_Y::%5.2f", St->Wt.scale_.y);
	ImGui::Text("Scale_Z::%5.2f", St->Wt.scale_.z);
	ImGui::NewLine();
	ImGui::Text("colScale_X::%5.2f", colBox->Wt.scale_.x);
	ImGui::Text("colScale_Y::%5.2f", colBox->Wt.scale_.y);
	ImGui::Text("colScale_Z::%5.2f", colBox->Wt.scale_.z);

	ImGui::NewLine();
	ImGui::Text("Position");
	ImGui::DragFloat("X", &St->Wt.translation_.x, 0.5f);
	ImGui::DragFloat("Y", &St->Wt.translation_.y, 0.5f);
	ImGui::DragFloat("Z", &St->Wt.translation_.z, 0.5f);
	ImGui::NewLine();
	ImGui::Text("Lange::%5.2f", Lange);
	ImGui::DragFloat("Min", &LangeMin, 0.5f);
	ImGui::DragFloat("Max", &LangeMax, 0.5f);
	ImGui::NewLine();
	static int AtkmodeNum = 0;
	const char* AtkModes[] = { "NONE", "SIMPLESHOT", "CHARGE","HARDSHOT","MISSILE","MINE"};
	ImGui::Combo("##AtkmodeNumCombo", &AtkmodeNum, AtkModes, IM_ARRAYSIZE(AtkModes));
	ImGui::SameLine();
	if (ImGui::Button("Change"))
	{
		switch (AtkmodeNum)
		{
		case 0:
			BossAtk = AtkPattern::NONE;
			break;
		case 1:
			TargetTimer = TargetTime;
			BossAtk = AtkPattern::SIMPLESHOT;
			BurstTime = BurstNum * BurstRate;
			break;
		case 2:
			BossAtk = AtkPattern::CHARGE;
			break;
		case 3:
			BossAtk = AtkPattern::HARDSHOT;
			break;
		case 4:
			BossAtk = AtkPattern::MISSILE;
			break;
		case 5:
			BossAtk = AtkPattern::MINE;
			break;
		}

	}
	ImGui::Text("BossAtkPattern::%s", AtkModes[static_cast<int>(BossAtk)]);

	ImGui::NewLine();
	static int MovemodeNum = 0;
	const char* MoveModes[] = { "NONE", "BACK", "CLOSEMOVE" };
	ImGui::Combo("##MovemodeNumCombo", &MovemodeNum, MoveModes, IM_ARRAYSIZE(MoveModes));
	ImGui::SameLine();
	if (ImGui::Button("Change"))
	{
		switch (MovemodeNum)
		{
		case 0:
			BossMove = MovePattern::NONE;
			break;
		case 1:
			BossMove = MovePattern::BACK;
			break;
		case 2:
			BossMove = MovePattern::CLOSEMOVE;
			break;
		}

	}
	ImGui::Text("BossMoveMode::%s", MoveModes[static_cast<int>(BossMove)]);
	ImGui::NewLine();
	ImGui::Text("HP::%5.2f", HP);
	ImGui::DragFloat("HP", &HP, 0.2f);
	ImGui::Checkbox("CriticalAim", &CriticalAim);
	ImGui::Checkbox("colLock", &colLock);

	ImGui::End();
}

void BossEnemy::aiming()
{
	Vector3 criticalAimPos = LinePrediction2(St->Wt.translation_, player->GetPos(), player->GetPredictionPoint(), nBulletSpeed);

	float judgeLine = crossLine;

	aimingTargetPos = player->GetPos();

	aimingTargetPos = lerp(player->GetPos(), criticalAimPos, static_cast<float>(criAimTimer / criAimTime));

	criAimTimer++;
	/*LinePrediction2(St->Wt.translation_, player->GetPos(), player->GetPredictionPoint(), nBulletSpeed)*/
	if (criAimTimer > criAimTime)criAimTimer = criAimTime;

	Vector2 a = (player->GetPos() - St->Wt.translation_).GetXZ();
	Vector2 b = (criticalAimPos - St->Wt.translation_).GetXZ();

	a.normalize();
	b.normalize();

	crossLine = a.cross(b);
	if (myMath::sign(crossLine) != myMath::sign(judgeLine))criAimTimer = 0;

}

void BossEnemy::DeathAnimetion()
{

	DpRate++;
	DeathTimer++;

	scale = easeInSine(4.0f, 0, static_cast<float>(DeathTimer), static_cast<float>(DeathTime));

	St->Wt.scale_ = { scale,scale,scale };

	if (DpRate >= DpRateNum)
	{

		std::unique_ptr <DeathParticle> newBullet = std::make_unique<DeathParticle>();
		newBullet->CreateDeathParticle(St->Wt.translation_, St->Wt.rotation_, -rotaVec,scale/3.0f, { 1.0f,0.0f,0.0f,1.0f });

		deathPaticles.push_back(std::move(newBullet));
		DpRate = 0;
	}
	if (DeathTimer >= DeathTime)
	{
		endFlag = true;
		DeathTimer = DeathTime;
	}

	
}

Vector3 BossEnemy::LinePrediction2(Vector3 shotPosition, Vector3 targetPosition, Vector3 targetPrePosition, float bulletSpeed)
{
	
	Vector3 v3_Mv = targetPosition - targetPrePosition;
	Vector3 v3_Pos = targetPosition - shotPosition;

	
	float A = (v3_Mv.x * v3_Mv.x + v3_Mv.y * v3_Mv.y + v3_Mv.z * v3_Mv.z) - bulletSpeed * bulletSpeed;
	float B = 2 * (v3_Pos.x * v3_Mv.x + v3_Pos.y * v3_Mv.y + v3_Pos.z * v3_Mv.z);
	float C = (v3_Pos.x * v3_Pos.x + v3_Pos.y * v3_Pos.y + v3_Pos.z * v3_Pos.z);

	
	if (A == 0)
	{
		if (B == 0)
		{
			return targetPosition;
		}
		else
		{
			return targetPosition + v3_Mv * (-C / B);
		}
	}

	
	float flame1, flame2;
	float D = B * B - 4 * A * C;
	if (D > 0)
	{
		float E = sqrtf(D);
		flame1 = (-B - E) / (2 * A);
		flame2 = (-B + E) / (2 * A);
		
		flame1 = PlusMin(flame1, flame2);
	}
	else
	{
		
		flame1 = 0;
	}

	
	return targetPosition + v3_Mv * flame1;
}

void BossEnemy::Bulletremove()
{
	Normalbullets_.remove_if([](std::unique_ptr<EnemyNormalBullet>& bullet)
		{
			return bullet->IsDead();
		});
	Mines_.remove_if([](std::unique_ptr<EnemyMine>& mine)
		{
			return mine->IsDead();
		});

}

============================================================
File Path: SourceCode/App/Enemy/BossEnemy.h
============================================================
#pragma once
//æ•µ
#include"StuructTransform.h"
#include"EnemyNormalBullet.h"
#include"EnemyMine.h"
#include"Draw3DLine.h"
#include"Player.h"
#include"DeathParticle.h"

enum struct AtkPattern
{
	NONE,
	SIMPLESHOT,
	CHARGE,
	HARDSHOT,
	MISSILE,
	MINE
};

enum struct MovePattern
{
	NONE,
	BACK,
	CLOSEMOVE,
};

class BossEnemy : public StuructTransform
{
public:

	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	BossEnemy();

	/// <summary>
	/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒã‚¤ãƒ³ã‚¿
	/// </summary>
	/// <param name="pl"></param>
	void SetPlayer(Player* pl)
	{
		player = pl;
	}


	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	void Init();

	/// <summary>
	/// ãƒªã‚»ãƒƒãƒˆ
	/// </summary>
	void Reset();

	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void Update(bool flag=false);

	/// <summary>
	/// è¢«ãƒ€ãƒ¡
	/// </summary>
	/// <param name="dmg"></param>
	void Damege(float dmg);

	/// <summary>
	/// æç”»
	/// </summary>
	void Draw();

	/// <summary>
	/// UIæç”»
	/// </summary>
	void DrawUI();

	/// <summary>
	/// æ”»æ’ƒãƒ‘ã‚¿ãƒ¼ãƒ³å–å¾—
	/// </summary>
	/// <returns></returns>
	AtkPattern GetAtkPattern()
	{
		return BossAtk;
	}

	/// <summary>
	/// å¼¾å‰Šé™¤
	/// </summary>
	void Bulletremove();
	const std::list<std::unique_ptr<EnemyNormalBullet>>& GetBullets() { return Normalbullets_; }
	const std::list<std::unique_ptr<EnemyMine>>& GetMines() { return Mines_; };

	/// <summary>
	/// ç”Ÿãã¦ã‚‹ã‹
	/// </summary>
	/// <returns></returns>
	bool Death()
	{
		if (HP <= 0)
		{
			return true;
		}
		else
		{
			return false;
		}
	}

	/// <summary>
	/// ã‚²ãƒ¼ãƒ ã‚¨ãƒ³ãƒ‰æ™‚
	/// </summary>
	/// <returns></returns>
	bool GameEnd()
	{
		return endFlag;
	}

	/// <summary>
	/// è¢«å¼¾æ™‚ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
	/// </summary>
	/// <param name="vec"></param>
	void HitParticle(Vector3 vec);

	const std::list<std::unique_ptr<DeathParticle>>& GetDps() { return deathPaticles; };

	/// <summary>
	/// åº§æ¨™å–å¾—
	/// </summary>
	/// <returns></returns>
	Vector3 GetPos()
	{
		return St->Wt.translation_;
	}
private:

	/// <summary>
	/// æ”»æ’ƒãƒ†ãƒ¼ãƒ–ãƒ«
	/// </summary>
	void AtkTable();

	/// <summary>
	/// ç§»å‹•ãƒ†ãƒ¼ãƒ–ãƒ«
	/// </summary>
	void MoveTable();

	/// <summary>
	/// å¾Œé€€
	/// </summary>
	void BackMove();

	/// <summary>
	/// æŽ¥è¿‘
	/// </summary>
	void CloseMove();

	/// <summary>
	/// é€šå¸¸å°„æ’ƒ
	/// </summary>
	void SimpleShot();

	/// <summary>
	/// çªé€²æ”»æ’ƒ
	/// </summary>
	void ChargeAtk();

	/// <summary>
	/// å¼·å°„æ’ƒ
	/// </summary>
	void HardShot();

	/// <summary>
	/// ãƒŸã‚µã‚¤ãƒ«
	/// </summary>
	void MissileShot();

	/// <summary>
	/// åœ°é›·
	/// </summary>
	void MineAttack();

	/// <summary>
	/// ImGuié–¢ä¿‚
	/// </summary>
	void ImGuiSet();

	void aiming();

	/// <summary>
	/// æ­»äº¡æ™‚ã®å‹•ã
	/// </summary>
	void DeathAnimetion();

	Vector3 LinePrediction2(Vector3 shotPosition, Vector3 targetPosition, Vector3 targetPrePosition, float bulletSpeed);

	float PlusMin(float a, float b)
	{
		if (a < 0 && b < 0) return 0;
		if (a < 0) return b;
		if (b < 0) return a;
		return a < b ? a : b;
	}

private:

	std::unique_ptr<OBJ3D> colBox;
	bool colLock = false;

	//æ¼”å‡ºå‘¨ã‚Š

	std::list<std::unique_ptr<DeathParticle>> deathPaticles;

	//--------

	Vector3 rotaVec = { 0,0,0 };

	float scale = 4.0f;
	int DpRate = 0;
	const int DpRateNum = 1;

	int DeathTimer = 0;

	const int DeathTime = 120;

	int SceneCameraTimer = 0;

	const int SceneCameraTime = 120;

	bool startFlag = false;

	bool endFlag = false;

	//æ±Žç”¨
	Vector3 prePos = { 0,0,0 };
	Player* player;

	Vector3 aimingTargetPos = { 0,0,0 };
	//æ”»æ’ƒãƒ‘ã‚¿ãƒ¼ãƒ³
	AtkPattern BossAtk = AtkPattern::NONE;

	//HP
	std::unique_ptr<Sprite2D> sprite_HPbar;

	uint32_t HpBarHandle;
	const float MaxHP = 100.0f;
	float HP = 0.0f;

	//è¡Œå‹•ãƒ‘ã‚¿ãƒ¼ãƒ³
	MovePattern BossMove = MovePattern::NONE;

	const int LongMoveTime = 60 * 6;

	const int MidMoveTime = 60 * 3;

	int MoveTimer = 0;

	float Angle = 0;

	Draw3DLine LeserPoint;

	int stopTimer = 0;
	const int stopTime = 120;

	int WaitTimer = 0;
	const int WaitTime = 180;

	//å¼¾é–¢é€£
	std::list<std::unique_ptr<EnemyNormalBullet>> Normalbullets_;

	std::list<std::unique_ptr<EnemyMine>> Mines_;

	const float nBulletSpeed = 2.0f;
	const float hBulletSpeed = 5.0f;

	//ç…§æº–å‘¨ã‚Š
	Vector3 TargetPos = { 0,0,0 };

	const int TargetTime = 60 * 2;

	int TargetTimer = 0;

	bool AimMode = false;

	//é€šå¸¸å°„æ’ƒ

	const int BurstRate = 3;
	const int BurstNum = 40;
	int BurstTime = BurstNum * BurstRate;

	bool CriticalAim = true;

	//äºˆæ¸¬æ’ƒã¡é–¢ä¿‚
	const size_t criAimTime = 30;
	size_t criAimTimer = 0;

	float crossLine = 0;


	//çªé€²æ”»æ’ƒ
	Vector3 TargetVec = { 0,0,0 };
	float chargeLenge = 0;
	int chargeCool = 0;
	const int chargeCoolTime = 600;

	int chargeMoveAniTimer = 0;

	const int chargeMoveAniTime = 30;

	//èªçŸ¥ç¯„å›²
	float Lange = 0;
	float LangeMax = 50;
	float LangeMin = 10;

	//åœ°é›·
	const size_t mineNum = 6;

	float mineThrowDeg = 0;

	size_t mineThrowTimer = 0;

	const size_t mineThrowTime = 40;

	int mineCool = 0;
	const int mineCoolTime = 300;

	

};

============================================================
File Path: SourceCode/App/Enemy/EnemyMine.cpp
============================================================
#include "EnemyMine.h"
#include <random>
#include "Field.h"
#include"Easing.h"


std::unique_ptr<ObjModel> EnemyMine::Premodel;


EnemyMine::EnemyMine()
{

	ModelInit(Premodel.get());
	Velocity_ = { 0,0,0 };
}

EnemyMine::~EnemyMine()
{
}

void EnemyMine::SetModel(ObjModel* _model)
{
	Premodel.reset(_model);
}

void EnemyMine::Initlize(const Vector3& position, const Vector3& rota, const Vector3& velocity)
{
	St->Wt.translation_ = position;
	St->Wt.rotation_ = rota;
	St->Wt.scale_ = { scale,scale,scale };
	St->color = { 1.0f,0.6f,0.0f,1.0f };

	mineTimer = mineTime;
	stopCounter = stopCount;
	explodeTimer = 0;
	Velocity_ = velocity;

	Velocity_.y = -0.2f;
}

void EnemyMine::Update()
{

	

	if (St->Wt.translation_.y <= 0)
	{
		St->Wt.translation_.y = 0;
		onField = true;
		
	}
	
	if(!onField)
	{
		St->Wt.translation_ = St->Wt.translation_ + Velocity_;
	}
	
	if (onField)
	{
		switch (state)
		{
		case WAIT:
			mineTimer--;
			if (mineTimer <= 0)
			{
				state = mineState::EXPLOSION;
				explode = true;
			}
			break;
		case EXPLOSION:
			explodeTimer++;
			scale = easeOutQuint(1.0f, 4.0f, static_cast<float>(explodeTimer), static_cast<float>(explodeTime));

			if (explodeTimer >= explodeTime)state = mineState::STOPEXPLOSION;
			break;
		case STOPEXPLOSION:
			stopCounter--;
			if (stopCounter <= 0)
			{
				state = mineState::END;
				explodeTimer = 0;
			}
			break;
		case END:
			explodeTimer++;
			scale = easeInQuint(4.0f, 0.0f, static_cast<float>(explodeTimer), static_cast<float>(explodeTime));

			if (explodeTimer >= explodeTime)isDead_ = true;
			break;
		}
		
	}

	St->Wt.scale_ = { scale,scale,scale };


	St->Update(camera->getView());

	
}

void EnemyMine::Draw()
{
	St->Draw();
}

bool EnemyMine::IsHit() const
{
	if (!hited && explode)
	{
		return true;
	}
	return false;
}

void EnemyMine::Destoroy()
{
	isDead_ = true;
}

void EnemyMine::OnCol()
{
	hited = true;
}


============================================================
File Path: SourceCode/App/Enemy/EnemyMine.h
============================================================
#pragma once
#include "StuructTransform.h"
using namespace DirectX;

enum mineState
{
	WAIT,
	EXPLOSION,
	STOPEXPLOSION,
	END

};

class EnemyMine:public StuructTransform
{
public:

	EnemyMine();
	~EnemyMine();

	static void SetModel(ObjModel* _model);

	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="model">ãƒ¢ãƒ‡ãƒ«</param>
	/// <param name="position">åˆæœŸåº§æ¨™</param>
	/// <param name="velocity">é€Ÿåº¦</param>
	void Initlize(const Vector3& position, const Vector3& rota, const Vector3& velocity);

	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void Update();

	/// <summary>
	/// æç”»
	/// </summary>
	/// <param name="viewProjection">ãƒ“ãƒ¥ãƒ¼ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³</param>
	void Draw();

	bool IsDead()const { return isDead_; }

	bool IsHit()const;

	//è¡çªã‚’æ¤œå‡ºã—ãŸã‚‰å‘¼ã³å‡ºã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°
	void Destoroy();

	void OnCol();



	Vector3 GetWorldPosition() { return St->Wt.translation_; }
	Vector3 GetScale() { return St->Wt.scale_; }
	Vector3 GetVec() { return Velocity_; }




private:

	static std::unique_ptr<ObjModel> Premodel;

	//ãƒ¢ãƒ‡ãƒ«
	//StuructTransform bullet;


	//ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒãƒ³ãƒ‰ãƒ«


	//é€Ÿåº¦
	Vector3 Velocity_;

	//ãƒ‡ã‚¹ãƒ•ãƒ©ã‚°
	bool isDead_ = false;

	size_t mineTimer = 0;
	const size_t mineTime = 60;

	size_t explodeTimer = 0;
	const size_t explodeTime = 20;

	size_t stopCounter = 0;
	const size_t stopCount = 120;

	bool onField = false;

	mineState state = mineState::WAIT;

	float scale = 1.0f;

	bool hited = false;
	bool explode = false;

};



============================================================
File Path: SourceCode/App/Enemy/EnemyNormalBullet.cpp
============================================================
#include "EnemyNormalBullet.h"

std::unique_ptr<ObjModel> EnemyNormalBullet::Premodel;

EnemyNormalBullet::EnemyNormalBullet()
{
	ModelInit(Premodel.get());
	Velocity_ = { 0,0,0 };
}

EnemyNormalBullet::~EnemyNormalBullet()
{
}

void EnemyNormalBullet::SetModel(ObjModel* _model)
{
	Premodel.reset(_model);
}

void EnemyNormalBullet::Initlize(const Vector3& position, const Vector3& rota, const Vector3& velocity)
{
	St->Wt.translation_ = position;
	St->Wt.rotation_ = rota;
	St->Wt.scale_ = { 0.5f,0.5f,0.5f };
	St->color = { 1.0f,0,0,1.0f };

	Velocity_ = velocity;
}

void EnemyNormalBullet::Update()
{
	St->Wt.translation_ = St->Wt.translation_ + Velocity_;

	St->Update(camera->getView());

	//ãƒ‡ã‚¹ã‚¿ã‚¤ãƒžãƒ¼ã‚’ã²ã„ã¦0ä»¥ä¸‹ã«ãªã£ãŸã‚‰ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
	if (--deathTimer_ <= 0)
	{
		isDead_ = true;
	}
}

void EnemyNormalBullet::Draw()
{
	St->Draw();
}

void EnemyNormalBullet::OnCollision()
{
	isDead_ = true;
}


============================================================
File Path: SourceCode/App/Enemy/EnemyNormalBullet.h
============================================================
#pragma once
#include "StuructTransform.h"
using namespace DirectX;

class EnemyNormalBullet:public StuructTransform
{
public:
	EnemyNormalBullet();
	~EnemyNormalBullet();

	static void SetModel(ObjModel* _model);

	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="model">ãƒ¢ãƒ‡ãƒ«</param>
	/// <param name="position">åˆæœŸåº§æ¨™</param>
	/// <param name="velocity">é€Ÿåº¦</param>
	void Initlize(const Vector3& position, const Vector3& rota, const Vector3& velocity);

	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void Update();

	/// <summary>
	/// æç”»
	/// </summary>
	/// <param name="viewProjection">ãƒ“ãƒ¥ãƒ¼ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³</param>
	void Draw();

	bool IsDead()const { return isDead_; }

	//è¡çªã‚’æ¤œå‡ºã—ãŸã‚‰å‘¼ã³å‡ºã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°
	void OnCollision();

	Vector3 GetWorldPosition() { return St->Wt.translation_; }
	Vector3 GetScale() { return St->Wt.scale_; }
	Vector3 GetVec() { return Velocity_; }


private:

	static std::unique_ptr<ObjModel> Premodel;

	//ãƒ¢ãƒ‡ãƒ«
	//StuructTransform bullet;


	//ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒãƒ³ãƒ‰ãƒ«


	//é€Ÿåº¦
	Vector3 Velocity_;

	//å¯¿å‘½<frm>
	static const int32_t kLifeTime = 60 * 5;

	//ãƒ‡ã‚¹ã‚¿ã‚¤ãƒžãƒ¼
	int32_t deathTimer_ = kLifeTime;

	//ãƒ‡ã‚¹ãƒ•ãƒ©ã‚°
	bool isDead_ = false;


};



============================================================
File Path: SourceCode/App/Field.cpp
============================================================
#include "Field.h"

#include"ImGuiManager.h"
const float Field::AreaLimit = 250.0f;	//åŠå¾„

void Field::Init(Camera* _camera)
{

	ground.clear();
	ground_model.reset(ObjModel::LoadFromOBJ("555"));

	for (size_t i = 0; i < TileNum; i++)
	{
		std::unique_ptr<OBJ3D > g = std::make_unique<OBJ3D>();

		ground.push_back(std::move(g));
	}

	for (auto& Ground : ground)
	{
		Ground.reset(OBJ3D::Create());
		Ground->SetModel(ground_model.get());
		Ground->Wt.scale_ = { TileSize / 2.0f,0.0f,TileSize / 2.0f };
	}

	for (size_t i = 0; i < ground.size(); i++)
	{
		ground[i]->Wt.translation_.x = -((AreaLimit / 2.0f) - (TileSize / 2.0f)) + ((TileSize) * static_cast<float>(i % 10));
		ground[i]->Wt.translation_.y = 0;
		ground[i]->Wt.translation_.z = ((AreaLimit / 2.0f) - (TileSize / 2.0f)) - ((TileSize) * static_cast<float>(i / 10));
	}

	camera = _camera;
}

void Field::Update()
{
	for (auto& Ground : ground)
	{
		Ground->Update(camera->getView());
	}
#ifdef _DEBUG
	ImGuiSet();
#endif


}

void Field::Draw()
{
	for (auto& Ground : ground)
	{
		Ground->Draw();
	}

}

float Field::GetArea()
{
	return AreaLimit;
}

float Field::GetUpArea()
{
	return UpAreaLimit;
}

void Field::ImGuiSet()
{
	//ImguI
	ImGui::SetNextWindowPos({ ImGui::GetMainViewport()->WorkPos.x, ImGui::GetMainViewport()->WorkPos.y + 10 }, ImGuiCond_Once);
	ImGui::SetNextWindowSize({ 400, 500 });

	ImGuiWindowFlags window_flags = 0;
	window_flags |= ImGuiWindowFlags_NoResize;
	ImGui::Begin("Field", NULL, window_flags);

	ImGui::Text("TileNum%d", ground.size());

	ImGui::End();
}


============================================================
File Path: SourceCode/App/Field.h
============================================================
#pragma once
#include"ObjModel.h"
#include"OBJ3D.h"
#include"Camera.h"

class Field 
{
public:

	void Init(Camera* _camera);

	void Update();

	void Draw();

	static float GetArea();

	float GetUpArea();

	/// <summary>
	/// ImGuié–¢ä¿‚
	/// </summary>
	void ImGuiSet();

private:

	Camera* camera;

	vector<std::unique_ptr<OBJ3D>> ground;
	std::unique_ptr<ObjModel> ground_model;

	const float UpAreaLimit = 100.0f;

	static const float AreaLimit;

	const size_t LaneTileNum = 10;

	const float TileSize = AreaLimit / static_cast<float>(LaneTileNum);

	const size_t TileNum = LaneTileNum * LaneTileNum;

};



============================================================
File Path: SourceCode/App/GameScene.cpp
============================================================
#include "GameScene.h"
#include"FbxLoader.h"
#include"StuructTransform.h"
#include"Input.h"
#include"Collision.h"
#include"Easing.h"
#include"DeathParticle.h"

using namespace SKNEngine;

void GameScene::Init(DirectXCommon* dxcommon)
{
	//spritecommon = new SpriteCommon();
	//spritecommon->Initialize(dxcommon);

	texturemanager = TextureManager::GetInstance();
	texturemanager->StaticInitialize(dxcommon);
	//light = LightGroup::Create();
	//OBJ3D::SetLight(light);
	//
	//camera.Initialize(dxcommon->GetDevice());
	////Object3D::SetCamera(camera.getView());
	//Draw3DLine::SetCamera(&camera);

	//StuructTransform::SetStruct(&camera, spritecommon, texturemanager);

	//ãƒ†ã‚¯ã‚¹ãƒãƒ£èª­ã¿è¾¼ã¿
	skydome_model = ObjModel::LoadFromOBJ("skydome");
	DeathParticle::SetModel(ObjModel::LoadFromOBJ("boxobj"));
	
	//preTitleHandle = texturemanager->LoadTexture("Resources/title.png");
	//preTitleHandle2 = texturemanager->LoadTexture("Resources/title2.png");
	//SceneChaHandle = texturemanager->LoadTexture("Resources/scene.png");
	//clearScHandle = texturemanager->LoadTexture("Resources/clear.png");
	//GameOverScHandle = texturemanager->LoadTexture("Resources/GameOver.png");
	//

	////3Dãƒ¢ãƒ‡ãƒ«å‘¨ã‚Š

	//
	//skydome = OBJ3D::Create();
	//skydome->SetModel(skydome_model);

	//field.Init(&camera);

	//boss.Init();
	//player.Init();

	//camera.setTarget(&player.prePlayer);
	////camera.setTarget(&player.St->Wt);

	//boss.SetPlayer(&player);
	//player.SetEnemy(&boss.St->Wt);


	////ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆå‘¨ã‚Š

	//preTitle = std::make_unique<Sprite2D>();
	//preTitle->Initialize(spritecommon, preTitleHandle);
	//preTitle->Wt.translation_ = { DxWindow::window_width / 2.0f,DxWindow::window_height / 4.5f ,0.0f };

	//preTitle2 = std::make_unique<Sprite2D>();
	//preTitle2->Initialize(spritecommon, preTitleHandle2);
	//preTitle2->Wt.translation_ = { DxWindow::window_width / 2.0f,(DxWindow::window_height / 2.0f) + 60.0f ,0.0f };

	//SceneCha = std::make_unique<Sprite2D>();
	//SceneCha->Initialize(spritecommon, SceneChaHandle);
	//SceneCha->Wt.translation_ = { DxWindow::window_width / 2.0f,(DxWindow::window_height / 2.0f) ,0.0f };

	//clearSc = std::make_unique<Sprite2D>();
	//clearSc->Initialize(spritecommon, clearScHandle);
	//clearSc->Wt.translation_ = { DxWindow::window_width / 2.0f,(DxWindow::window_height / 2.0f) ,0.0f };


	////ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å‘¨ã‚Š

	//float ambientColor[3] = { 1,1,1 };

	//float lightDir0[3] = { 0,0,-1 };
	//float lightColor0[3] = { 1,0,0 };

	//float litX = 0.0f;
	//float litY = 0.0f;
	//float litZ = 0.0f;

	//float pointLightPos[3] = { litX,litY,litZ };
	//float pointLightColor[3] = { 1,1,1 };

	//float pointLightAtten[3] = { 0.3f,0.1f,0.1f };

	//light->SetDirLightActive(0, true);
	//light->SetPointLightActive(0, false);


	//light->SetPointLightPos(0, Vector3(pointLightPos));
	//light->SetPointLightColor(0, Vector3(pointLightColor));
	//light->SetPointLightAtten(0, Vector3(pointLightAtten));

	////float a = 0.2f;

	////field->Wt->translation_.y = -5.0f;
	//player.Reset();
	//boss.Reset();
	//camera.Reset();
}

void GameScene::Update()
{
	
	switch (scene)
	{
	case SceneType::TITLE:
		TitleUpdate();
		if (Input::GetPadButtonDown(XINPUT_GAMEPAD_A) || Input::GetPressKey(DIK_END))
		{
			sceneChaflag = true;
		}

		if (sceneChaflag)
		{
			SceneChangeTimer++;
			if (SceneChangeTimer >= SceneChangeTime)
			{
				player.Reset();
				boss.Reset();
				camera.Reset();
				GameUpdate();
				//camera.setPos(boss.GetPos());
				camera.setTarget(&player.prePlayer);
				scene = SceneType::GAMESCENE;
				
			}
		}
		else
		{
			SceneChangeTimer = 0;
		}
		break;
	case SceneType::GAMESCENE:
		if (sceneChaflag)
		{
			StartUpdate();
			
		}
		else
		{
			GameUpdate();
		}
		if (player.GameEnd() || boss.GameEnd())
		{
			endSceneChaflag = true;
			
		}
		if (endSceneChaflag)
		{
			SceneChangeTimer++;
			if (SceneChangeTimer >= SceneChangeTime)
			{
				if (player.GameEnd())
				{
					scene = SceneType::GAMEOVER;
					clearSc->SetTexture(GameOverScHandle);
				}
				else if(boss.GameEnd())
				{
					scene = SceneType::CLEARSCENE;
					clearSc->SetTexture(clearScHandle);
				}
				
				player.Reset();
				camera.Reset();
				endSceneChaflag = false;
			}
		}
		break;

	case SceneType::CLEARSCENE:
		
		SceneChangeTimer--;

		if (SceneChangeTimer <= 0)
		{
			SceneChangeTimer = 0;
			scene = SceneType::TITLE;
			player.Reset();
			camera.Reset();
		}

		break;

	case SceneType::GAMEOVER:

		SceneChangeTimer--;

		if (SceneChangeTimer <= 0)
		{
			SceneChangeTimer = 0;
			scene = SceneType::TITLE;
			player.Reset();
			camera.Reset();
		}


		break;
	}

	SceneAlpha = easeOutSine(0, 255.0f, static_cast<float>(SceneChangeTimer), static_cast<float>(SceneChangeTime));
	SceneCha->Wt.color = { SceneAlpha / 255.0f ,SceneAlpha / 255.0f ,SceneAlpha / 255.0f ,SceneAlpha / 255.0f };
	SceneCha->Update();

	ImGuiView();

}

void GameScene::Draw(DirectXCommon* dxcommon)
{
	switch (scene)
	{
	case SceneType::TITLE:
		TitleDraw(dxcommon);
		break;
	case SceneType::GAMESCENE:
		GameDraw(dxcommon);
		break;
	case SceneType::CLEARSCENE:
		spritecommon->PreDraw();
		clearSc->Draw();
		break;
	case SceneType::GAMEOVER:
		spritecommon->PreDraw();
		clearSc->Draw();
		break;
	}
	
	spritecommon->PreDraw();
	SceneCha->Draw();

	
	
}

void GameScene::ALLCol()
{
	const std::list<std::unique_ptr<BulletManager>>& playerBullets = player.GetBullets();

	const std::list<std::unique_ptr<EnemyNormalBullet>>& enemyBullets = boss.GetBullets();

	const std::list<std::unique_ptr<EnemyMine>>& enemyMines = boss.GetMines();

	Sphere playerSp;
	Sphere bossSp;

	playerSp.center = player.GetPos();
	playerSp.radius = player.St->Wt.scale_.x;

	bossSp.center = boss.St->Wt.translation_;
	bossSp.radius = boss.St->Wt.scale_.x;
	hitcheck = false;
	if (Collision::CheckSphereToSphere(playerSp, bossSp))
	{
		hitcheck = true;
		if (boss.GetAtkPattern() == AtkPattern::CHARGE)
		{
			player.Damege(0.2f);
			player.HitParticle(player.GetPos() - boss.GetPos());
		}
	}
	for (const std::unique_ptr<EnemyNormalBullet>& bullet : enemyBullets)
	{
		Sphere bossBulletSp;
		bossBulletSp.center = bullet->GetWorldPosition();
		bossBulletSp.radius = bullet->GetScale().x;
		if (Collision::CheckSphereToSphere(playerSp, bossBulletSp))
		{
			
			player.Damege(1.0f);
			player.HitParticle(bullet->GetVec());
			bullet->OnCollision();
		}
		
	}
	for (const std::unique_ptr<EnemyMine>& mine : enemyMines)
	{
		Sphere bossMineSp;
		bossMineSp.center = mine->GetWorldPosition();
		bossMineSp.radius = mine->GetScale().x;
		if (Collision::CheckSphereToSphere(playerSp, bossMineSp)&&mine->IsHit())
		{

			player.Damege(5.0f);
			player.HitParticle(mine->GetVec());
			player.KnockBack(mine->GetVec());
			mine->OnCol();
			//mine->Destoroy();
		}

	}
	for (const std::unique_ptr<BulletManager>& p_bullet : playerBullets)
	{
		Sphere playerBulletSp;
		playerBulletSp.center =p_bullet->GetWorldPosition();
		playerBulletSp.radius = p_bullet->GetScale().x;
		if (Collision::CheckSphereToSphere(playerBulletSp, bossSp))
		{
			boss.Damege(2.0f);
			boss.HitParticle(p_bullet->GetVec());
			p_bullet->OnCollision();
		}
	}

}

void GameScene::TitleUpdate()
{
	if (tenmetu > 254.0f || tenmetu < 0.0f)
	{
		decri *= -1.0f;
	}

	tenmetu += decri;



	preTitle2->Wt.color = { tenmetu / 255.0f ,tenmetu / 255.0f ,tenmetu / 255.0f ,tenmetu / 255.0f };
	camera.Update();
	preTitle->Update();
	preTitle2->Update();
	player.TitleUpdate();
}

void GameScene::GameUpdate()
{


	ALLCol();

	light->Update();

	camera.Update();
	skydome->Update(camera.getView());
	field.Update();
	player.Update();
	boss.Update();
}

void GameScene::TitleDraw(DirectXCommon* dxcommon)
{
	OBJ3D::PreDraw(dxcommon->GetCommandList());
	/*skydome->Draw();
	field.Draw();*/
	player.Draw();
	spritecommon->PreDraw();

	preTitle->Draw();
	preTitle2->Draw();

	spritecommon->PostDraw();

}

void GameScene::GameDraw(DirectXCommon* dxcommon)
{
	OBJ3D::PreDraw(dxcommon->GetCommandList());

	skydome->Draw();
	field.Draw();

	player.Draw();
	boss.Draw();
	//ParticleManager::PreDraw(dxcommon->GetCommandList());

	// 3Dã‚ªãƒ–ã‚¯ã‚¸ã‚§ã‚¯ãƒˆã®æç”»
	//particleMan->Draw();


	/// <summary>
	/// ã“ã“ã«3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æç”»å‡¦ç†ã‚’è¿½åŠ ã§ãã‚‹
	/// </summary>

	// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæç”»å¾Œå‡¦ç†
	//ParticleManager::PostDraw();

	spritecommon->PreDraw();
	if (!sceneChaflag)
	{
		player.DrawUI();
		boss.DrawUI();
	}

	//sprite->Draw({ 0,0 });
	//sprite2->DrawClip({ 80.0f,180.0f }, { 200.0f,100.0f }, {});

	spritecommon->PostDraw();

}

void GameScene::StartUpdate()
{
	SceneChangeTimer--;
	//SceneCameraTimer++;

	

	if (SceneChangeTimer <= 0)
	{
		SceneChangeTimer = 0;
		//sceneChaflag = false;
	}
	//sceneCamera=

	//camera.setPos();
	if (SceneCameraTimer >= SceneCameraTime)
	{
		SceneCameraTimer = SceneCameraTime;
		//camera.setTarget(&player.St->Wt);
		
	}
	//camera.Update();
	camera.Update();
	skydome->Update(camera.getView());
	field.Update();
	player.StartUpdate();
	boss.Update(sceneChaflag);
	

	if (player.Start())
	{
		sceneChaflag = false;
	}
}

void GameScene::ImGuiView()
{
	//ImguI
	ImGui::SetNextWindowPos({ ImGui::GetMainViewport()->WorkPos.x + 400, ImGui::GetMainViewport()->WorkPos.y + 10 }, ImGuiCond_Once);
	ImGui::SetNextWindowSize({ 400, 500 });

	ImGuiWindowFlags window_flags = 0;
	window_flags |= ImGuiWindowFlags_NoResize;
	ImGui::Begin("Collsion", NULL, window_flags);

	ImGui::Checkbox("hit", &hitcheck);
	
	ImGui::End();
}




============================================================
File Path: SourceCode/App/GameScene.h
============================================================
#pragma once
#include"DirectXCommon.h"
#include"DxWindow.h"
#include"ViewProjection.h"
//#include"Object3D.h"
#include"ImGuiManager.h"
#include"TextureManager.h"
#include"SpriteCommon.h"
//#include"Model.h"
#include"Sprite2D.h"
#include"LightGroup.h"
#include"ParticleManager.h"
#include"CollisionPrimitive.h"
#include"Collision.h"
#include"OBJ3D.h"
#include"ObjModel.h"
#include"Camera.h"
#include"Player.h"
#include"BossEnemy.h"
#include"Draw3DLine.h"
#include"Field.h"
#include"DeathParticle.h"

enum struct SceneType
{
	TITLE,
	GAMESCENE,
	CLEARSCENE,
	GAMEOVER
};

class GameScene
{

private:
	SpriteCommon* spritecommon = nullptr;
	TextureManager* texturemanager;


public:

	void Init(SKNEngine::DirectXCommon* dxcommon);

	void Update();

	void Draw(SKNEngine::DirectXCommon* dxcommon);

	void ALLCol();

	void Finalize()
	{
		delete spritecommon;
		texturemanager->DeleteInstance();
		delete light;

		delete skydome_model;
		delete skydome;
	}

	

private:

private:
	/// <summary>
	/// ã‚¿ã‚¤ãƒˆãƒ«æ›´æ–°
	/// </summary>
	void TitleUpdate();

	/// <summary>
	/// ãƒ¡ã‚¤ãƒ³æ›´æ–°
	/// </summary>
	void GameUpdate();

	/// <summary>
	/// ã‚¿ã‚¤ãƒˆãƒ«æç”»
	/// </summary>
	void TitleDraw(SKNEngine::DirectXCommon* dxcommon);

	/// <summary>
	/// ãƒ¡ã‚¤ãƒ³æç”»
	/// </summary>
	void GameDraw(SKNEngine::DirectXCommon* dxcommon);

	void StartUpdate();

	/// <summary>
	/// ImGuié–¢ä¿‚
	/// </summary>
	void ImGuiView();

	Player player;
	BossEnemy boss;
	Field field;


	float cameraX = 0;
	float cameraZ = 0;
	float rotateX = 0;
	float rotateY = 0;

	float cameraRotateX = 0;
	float cameraRotateY = 9.45f;

	float cameraDPI = 0.05f;


private:
	Camera camera;
	LightGroup* light = nullptr;

	ObjModel* skydome_model = nullptr;
	OBJ3D* skydome = nullptr;


	Vector3 flontVec = { 0,0,1.0f };
	float cameraDistance = 20.0f;

	std::unique_ptr<Sprite2D> preTitle;
	uint32_t preTitleHandle;

	std::unique_ptr<Sprite2D> preTitle2;
	uint32_t preTitleHandle2;

	std::unique_ptr<Sprite2D> SceneCha;
	uint32_t SceneChaHandle;

	std::unique_ptr<Sprite2D> clearSc;
	uint32_t clearScHandle;
	uint32_t GameOverScHandle;

	bool sceneChaflag = false;
	bool endSceneChaflag = false;

	int SceneChangeTimer = 0;

	const int SceneChangeTime = 60;

	float tenmetu = 255.0f;

	float SceneAlpha = 255.0f;

	float SceneAlpha2 = 255.0f;

	float decri = 3.0f;


	SceneType scene = SceneType::TITLE;

	Vector3 sceneCamera = { 0,0,0 };

	int SceneCameraTimer = 0;

	const int SceneCameraTime = 120;

	int clearSceneTimer = 0;

	const int clearSceneTime = 60;

	bool hitcheck = false;



};



============================================================
File Path: SourceCode/App/Player/Player.cpp
============================================================
#include "Player.h"
#include "ImGuiManager.h"
#include "Math/Easing.h"
#include"Field.h"
#include"myMath.h"



void Player::Init()
{

	ModelInit("Player");
	

	prePP.reset(OBJ3D::Create());
	prePP->SetModel(model.get());
	PlayerBullet::SetModel(ObjModel::LoadFromOBJ("maru"));
	
	colBox.reset(OBJ3D::Create());
	colBox->SetModel(ObjModel::LoadFromOBJ("maru"));


	colBox->Wt.scale_ = St->Wt.scale_;
	colBox->Wt.color = { 1.0f,1.0f,1.0f,1.0f };
	
	
	
	reticleHandle = texMana->LoadTexture("Resources/Reticle.png");
	LockHandle = texMana->LoadTexture("Resources/Lock.png");
	HpBarHandle = texMana->LoadTexture("Resources/HpBar.png");
	St->Wt.scale_ = { 1.0f,1.0f,1.0f };
	St->Wt.translation_.y = 50.0f;

	prePP->Wt.scale_ = St->Wt.scale_;
	prePP->Wt.color = { 0,1.0f,0,1.0f };

	HP = MaxHP;

	KeyUI = std::make_unique<Sprite2D>();
	KeyUI->Initialize(spCommon, texMana->LoadTexture("Resources/preKeyUI.png"));

	sprite_HPbar = std::make_unique<Sprite2D>();
	sprite_HPbar->Initialize(spCommon, HpBarHandle);
	sprite_HPbar->Wt.translation_ = { 200.0f,680.0f,0.0f };
	sprite_HPbar->Wt.scale_.x = 10.0f;
	sprite_HPbar->Wt.color = { 0.0f,1.0f,0.0f,1.0f };

	sprite_CoverHPbar = std::make_unique<Sprite2D>();
	sprite_CoverHPbar->Initialize(spCommon,  HpBarHandle);
	sprite_CoverHPbar->Wt.translation_ = { 200.0f,680.0f,0.0f };
	sprite_CoverHPbar->Wt.scale_.x = 10.0f;
	sprite_CoverHPbar->Wt.color = { 0.15f,0.15f,0.15f,1.0f };

	sprite_ENGauge = std::make_unique<Sprite2D>();
	sprite_ENGauge->Initialize(spCommon, HpBarHandle);
	sprite_ENGauge->Wt.translation_ = { DxWindow::window_width / 2.0f,(DxWindow::window_height / 22.5f)*20.0f ,0.0f };
	sprite_ENGauge->Wt.scale_.x = ENGaugeSize * static_cast<float>(ENGauge) / static_cast<float>(ENMAXGauge);
	sprite_ENGauge->Wt.scale_.y *= 0.5f;
	sprite_ENGauge->Wt.color = { 0.0f,0.15f,0.75f,1.0f };

	sprite_CoverENGaugebar = std::make_unique<Sprite2D>();
	sprite_CoverENGaugebar->Initialize(spCommon, HpBarHandle);
	sprite_CoverENGaugebar->Wt.translation_ = { DxWindow::window_width / 2.0f,(DxWindow::window_height / 22.5f) * 20.0f ,0.0f };
	sprite_CoverENGaugebar->Wt.scale_.x = ENGaugeSize;
	sprite_CoverENGaugebar->Wt.scale_.y *= 0.5f;
	sprite_CoverENGaugebar->Wt.color = { 0.15f,0.15f,0.15f,1.0f };

	sprite_Reticle = std::make_unique<Sprite2D>();
	sprite_Reticle->Initialize(spCommon, reticleHandle);
	sprite_Reticle->Wt.translation_ = { DxWindow::window_width / 2.0f,DxWindow::window_height / 2.0f ,0.0f };
	sprite_Reticle->Wt.scale_={ 1.0f,1.0f,1.0f };

	sprite_Lock= std::make_unique<Sprite2D>();
	sprite_Lock->Initialize(spCommon, LockHandle);

	move_speed = 0.4f;

	ENGauge = ENMAXGauge;


	prePlayer = St->Wt;
}

void Player::Reset()
{
	HP = MaxHP;
	St->Wt.translation_ = { 0,50.0f,0 };
	St->Wt.scale_ = { 1.0f,1.0f,1.0f };
	const std::list<std::unique_ptr<BulletManager>>& Bullets = GetBullets();
	for (const std::unique_ptr<BulletManager>& p_bullet : Bullets)
	{
		
		p_bullet->OnCollision();
		
	}
	const std::list<std::unique_ptr<DeathParticle>>& Dps = GetDps();
	for (const std::unique_ptr<DeathParticle>& Dp : Dps)
	{

		Dp->Death();

	}
	bullets_.remove_if([](std::unique_ptr<BulletManager>& bullet)
		{
			return bullet->IsDead();
		});

	deathPaticles.remove_if([](std::unique_ptr<DeathParticle>& dp)
		{
			return dp->IsDead();
		});

	startFlag = false;
	SceneCameraTimer = 0;
	endFlag = false;
	DeathTimer = 0;

	rotaVec = { 0,0,1.0f };
	mae = { 0,0,0 };
	DpRate = 0;
	scale = 1.0f;
	hpBarShakeNum = 0;
	diff = 0;
	
}

void Player::Update()
{
	prePlayer.rotation_ = St->Wt.rotation_;
	sprite_HPbar->Wt.translation_.x = 200.0f-(8.0f * (MaxHP-HP));
	sprite_HPbar->Wt.scale_.x = (10.0f * HP / MaxHP);
	prePlayer.translation_ =lerp(prePlayer.translation_, St->Wt.translation_, 0.3f);

	sprite_ENGauge->Wt.scale_.x = ENGaugeSize * static_cast<float>(ENGauge) / static_cast<float>(ENMAXGauge);
	if (HP > MaxHP)
	{
		HP = MaxHP;
	}

	

	bullets_.remove_if([](std::unique_ptr<BulletManager>& bullet)
		{
			return bullet->IsDead();
		});


	deathPaticles.remove_if([](std::unique_ptr<DeathParticle>& dp)
		{
			return dp->IsDead();
		});

	if (!Death())
	{
		if (knockBack)
		{
			St->Wt.translation_ += knockVec * knockSpeed;
			knockSpeed -= 0.5f;
			if (knockSpeed <= 0)
			{
				knockBack = false;
			}
		}
		else
		{
			Move();
		}
		
	}
	else
	{
		DeathAnimetion();
	}
	
	
	if (Input::GetRTrigger()&& !Death())
	{
		if (latetime <= 0)
		{
			Attack(camera->getForwardVec());

			latetime = firelate;
		}
	}

	latetime--;

	for (std::unique_ptr<BulletManager>& bullet : bullets_)
	{
		bullet->Update();
	}

	for (std::unique_ptr<DeathParticle>& dp : deathPaticles)
	{
		dp->Update();
	}
	
	sprite_Lock->Wt.translation_ = { Lock2DPos.x,Lock2DPos.y,0.0f };

#ifdef _DEBUG
	ImGuiSet();
#endif

	LockOn();

	St->Update(camera->getView());
	prePlayer.UpdateMatrix(camera->getView());
	prePP->Update(camera->getView());
	sprite_Reticle->Update();
	colBox->Wt.translation_ = St->Wt.translation_;
	colBox->Wt.scale_ = St->Wt.scale_;
	colBox->Update(camera->getView());
	sprite_HPbar->Update();
	sprite_ENGauge->Update();
	sprite_CoverENGaugebar->Update();
	sprite_CoverHPbar->Update();
	sprite_Lock->Update();
}

void Player::Damege(float dmg)
{
	HP -= dmg * static_cast<float>(1 - Muteki);

}

void Player::HitParticle(Vector3 vec)
{
	if (!Death())
	{
		for (size_t i = 0; i < 4; i++)
		{
			std::unique_ptr <DeathParticle> newBullet = std::make_unique<DeathParticle>();
			newBullet->CreateHitParticle(St->Wt.translation_, St->Wt.rotation_, vec, 0.5f, { 0,0.3f,1.0f,1.0f });

			deathPaticles.push_back(std::move(newBullet));
		}
	}
	
}

void Player::KnockBack(Vector3 vec)
{
	knockBack = true;
	knockVec = vec;
	knockVec.y = 0;
	knockVec.normalize();
	knockSpeed = knockSpeedNum;

}

void Player::Attack(Vector3 flont)
{
	const float kBulletSpeed = 5.0f;
	
	Vector3 velocity = flont;

	if (Locked)
	{
		velocity = boss->translation_ - GetPos();
	}

	velocity.normalize();

	/*velocity = VectorMat(velocity,player->Wt->matWorld_);
	normalize(velocity);*/

	Vector3 BulletStart = St->Wt.translation_ ;
	velocity *= kBulletSpeed;


	std::unique_ptr <BulletManager> newBullet = std::make_unique<PlayerBullet>();
	newBullet->Initlize(BulletStart, St->Wt.rotation_, velocity);

	bullets_.push_back(std::move(newBullet));

	
}

void Player::Move()
{
	EN();

	

	rotaVec = mae;
	moveVec = { 0,0,0 };
	Vector3 Flont = camera->getForwardVec();
	Flont.y = 0;

	playerPredictionPoint = St->Wt.translation_;
	
	
	Vector2 inputnum = Input::GetLStick(true, true);

	moveVec.x += (float)inputnum.x / SHRT_MAX;
	moveVec.z += (float)inputnum.y / SHRT_MAX;


	float p_pos = atan2(moveVec.x, moveVec.z);
	float c_vec = atan2(Flont.x, Flont.z);




	mae = { 0,0,0 };

	if ((moveVec.x != 0 || moveVec.z != 0))
	{
		mae = { 0,0,1.0f };
		diff = p_pos+c_vec;
		/*St->Wt.rotation_.y = (p_pos + c_vec);*/	
	}
	St->Wt.rotation_.y = myMath::LerpShortAngle(St->Wt.rotation_.y, diff, 0.5f);

	mae *= St->Wt.matWorld_;

	mae.normalize();

	
	
	Jump(mae);

	if ((moveVec.x == 0 && moveVec.z == 0))
	{
		mae = rotaVec;
	}
	Dash(mae);

	if (Input::GetPadButtonDown(XINPUT_GAMEPAD_B))
	{
		BoostMode = !BoostMode;
	}


	if (!DashFlag&& (moveVec.x != 0 || moveVec.z != 0))
	{
		St->Wt.translation_ += mae * (move_speed + (move_speed * BoostMode));
		/*playerPredictionPoint = St->Wt.translation_ + mae * (move_speed + (move_speed * BoostMode));
		playerPredictionPoint.y = 1.5f;*/
	}
	
	if ((moveVec.x == 0 && moveVec.z == 0))
	{
		BoostMode = false;
	}

	//St->Wt.translation_.y -= 0.5f;

	if (St->Wt.translation_.y - (St->Wt.scale_.y * 1.5f) < 0.0f)
	{
		St->Wt.translation_.y = (St->Wt.scale_.y * 1.5f);
		OnGround = true;
	}
	else
	{
		OnGround = false;
	}

	if (St->Wt.translation_.x + St->Wt.scale_.x > Field::GetArea() || St->Wt.translation_.x - St->Wt.scale_.x < -Field::GetArea())
	{
		St->Wt.translation_.x = Field::GetArea() - St->Wt.scale_.x * (abs(St->Wt.translation_.x) / St->Wt.translation_.x);
	}
	if (St->Wt.translation_.z + St->Wt.scale_.z >= Field::GetArea() || St->Wt.translation_.z - St->Wt.scale_.z <= -Field::GetArea())
	{
		St->Wt.translation_.z = Field::GetArea() - St->Wt.scale_.z * (abs(St->Wt.translation_.z) / St->Wt.translation_.z);
	}
	
	prePP->Wt.translation_ = prePlayer.translation_;

}

void Player::Jump(Vector3 front)
{
	if (!OverHeat)
	{
		if (Input::GetPadButtonDown(XINPUT_GAMEPAD_A) && !DashFlag && OnGround)
		{
			JumpFlag = true;
			JumpTimer = 0;
			JumpVec = front;
			UseEN = true;
			ENGauge -= JumpUseGauge;
		}
		if (Input::GetPadButton(XINPUT_GAMEPAD_A) && !DashFlag && !JumpFlag)
		{
			JumpTimer = 0;
			St->Wt.translation_.y += AirUpSpead;
			ENGauge -= AirUseGauge;
		}
	}

	

	if (JumpFlag)
	{
		JumpTimer++;

		Upspeed = easeInSine(UpSpeadNum, 0.0f, static_cast<float>(JumpTimer), static_cast<float>(JumpTime));

		St->Wt.translation_ += JumpVec * Upspeed;

		if (JumpTimer >= JumpTime)
		{
			JumpFlag = false;
			JumpTimer = 0;
		}
	}
	else
	{
		if (!DashFlag)
		{
			JumpTimer++;
			Upspeed = easeOutSine(0.0f, -UpSpeadNum, static_cast<float>(JumpTimer), static_cast<float>(JumpTime));
		}
		if (JumpTimer >= JumpTime)
		{
			JumpTimer = JumpTime;
		}
	}

	St->Wt.translation_.y += Upspeed;

}

void Player::Dash(Vector3 front)
{
	if (Input::GetPadButtonDown(XINPUT_GAMEPAD_X) && !DashFlag&&!OverHeat)
	{
		DashFlag = true;
		DashVec = front;
		DashTimer = 0;
		ENGauge -= DashUseGauge;
		UseEN = true;
		JumpTimer = 0;
		JumpFlag = false;
		Upspeed = 0;
		BoostMode = true;
	}

	if (DashFlag)
	{
		DashTimer++;

		dashspeed = easeInQuint(DashSpeadNum, 0.0f, static_cast<float>(DashTimer), static_cast<float>(DashTime));

		St->Wt.translation_ += DashVec * dashspeed;

		if (DashTimer >= DashTime)
		{
			DashFlag = false;
			BoostMode = true;
		}
	}
}

void Player::EN()
{
	if (InfEN)
	{
		ENGauge = ENMAXGauge;
	}

	if (UseEN)
	{
		RegenENCoolTimer = RegenENCoolTime;
		UseEN = false;
	}

	if (ENGauge <= 0&&!OverHeat)
	{
		OverHeat = true;
		OverHeatENCoolTimer = OverHeatENCoolTime;
	}

	if (OverHeat)
	{
		OverHeatENCoolTimer--;
		RegenENCoolTimer = 0;
		ENGauge += RecoveryENGauge;
		if (OverHeatENCoolTimer <= 0)
		{
			OverHeat = false;
		}
	}
	

	if (RegenENCoolTimer > 0)
	{
		RegenENCoolTimer--;
	}
	else
	{
		ENGauge+=RegenEN;
	}

	if (ENGauge >= ENMAXGauge)
	{
		ENGauge = ENMAXGauge;
	}

	

}

void Player::LockOn()
{
	
	if (ScLock(boss))
	{

		Lock2DPos = WorldToMonitor(boss->translation_);
		sprite_Reticle->Wt.translation_ = { Lock2DPos.x,Lock2DPos.y ,0.0f };
		Locked = true;
	}
	else
	{
		Lock2DPos = { DxWindow::window_width / 2.0f,DxWindow::window_height / 2.0f };
		sprite_Reticle->Wt.translation_ = { DxWindow::window_width / 2.0f,DxWindow::window_height / 2.0f ,0.0f };
		Locked = false;
	}
}

bool Player::ScLock(WorldTransform* prewt)
{
	Matrix4 Pos = prewt->matWorld_;
	Pos *= camera->getView()->GetMAtView();
	Pos *= camera->getView()->GetMatProjection();

	float objZ = Pos.GetTranslation().z;

	Vector2 scr_pos = WorldToMonitor(prewt->translation_);

	if (0 < scr_pos.x && (DxWindow::window_width)  > scr_pos.x && 
		0 < scr_pos.y &&(DxWindow::window_height)> scr_pos.y && objZ > 0)
	{
		return true;
	}

	else
	{
		return false;
	}
}

void Player::DeathAnimetion()
{
	DpRate++;
	DeathTimer++;

	scale = easeInSine(1.0f, 0, static_cast<float>(DeathTimer), static_cast<float>(DeathTime));

	St->Wt.scale_ = { scale,scale,scale };

	if (DpRate >= DpRateNum)
	{

		std::unique_ptr <DeathParticle> newBullet = std::make_unique<DeathParticle>();
		newBullet->CreateDeathParticle(St->Wt.translation_, St->Wt.rotation_, -rotaVec,scale/3.0f, { 0,0.3f,1.0f,1.0f });

		deathPaticles.push_back(std::move(newBullet));
		DpRate = 0;
	}
	if (DeathTimer >= DeathTime)
	{
		endFlag = true;
		DeathTimer = DeathTime;
	}
	
}

Vector2 Player::WorldToMonitor(Vector3 pos)
{
	Vector3 positionReticle = pos;

	Matrix4 matViewport = Matrix4::Viewport(0, 0, static_cast<float>(DxWindow::window_width), static_cast<float>(DxWindow::window_height), 0, 1.0f);

	//ãƒ“ãƒ¥ãƒ¼è¡Œåˆ—ã¨ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è¡Œåˆ—ã€ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆè¡Œåˆ—ã‚’åˆæˆã™ã‚‹
	Matrix4 matViewProjectionViewport = camera->getView()->GetMAtView() * camera->getView()->GetMatProjection() * matViewport;
	//ãƒ¯ãƒ¼ãƒ«ãƒ‰â†’ã‚¹ã‚¯ãƒªãƒ¼ãƒ³åº§æ¨™å¤‰æ›(ã“ã“ã§3Dã‹ã‚‰2Dã«ãªã‚‹)
	positionReticle = Matrix4::ProjectionDivW(positionReticle,matViewProjectionViewport);

	//ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®ãƒ¬ãƒ†ã‚£ã‚¯ãƒ«ã«åº§æ¨™è¨­å®š
	return Vector2(positionReticle.x, positionReticle.y);
}

void Player::ImGuiSet()
{
	//ImguI
	ImGui::SetNextWindowPos({ ImGui::GetMainViewport()->WorkPos.x + 800, ImGui::GetMainViewport()->WorkPos.y + 10 }, ImGuiCond_Once);
	ImGui::SetNextWindowSize({ 400, 500 });

	ImGuiWindowFlags window_flags = 0;
	window_flags |= ImGuiWindowFlags_NoResize;
	ImGui::Begin("Player", NULL, window_flags);

	ImGui::Text("Position");
	ImGui::DragFloat("X", &St->Wt.translation_.x, 0.5f);
	ImGui::DragFloat("Y", &prePP->Wt.translation_.y, 0.5f);
	ImGui::DragFloat("Z", &St->Wt.translation_.z, 0.5f);
	ImGui::NewLine();
	ImGui::Text("HP::%5.2f", HP);
	ImGui::DragFloat("HP", &HP, 0.2f);
	ImGui::DragFloat("HPposX", &sprite_HPbar->Wt.translation_.x, 0.5f);
	ImGui::DragFloat("HPposY", &sprite_HPbar->Wt.translation_.y, 0.5f);
	ImGui::DragFloat("HPSizeX", &sprite_HPbar->Wt.scale_.x, 0.5f);
	ImGui::DragFloat("HPSizeY", &sprite_HPbar->Wt.scale_.y, 0.5f);
	ImGui::NewLine();
	ImGui::Text("ENGauge::%d", ENGauge);
	ImGui::Text("OverHeat::%d", OverHeat);
	ImGui::NewLine();
	ImGui::Text("BoostMode::%d", BoostMode);
	ImGui::Checkbox("InfEN", &InfEN);
	ImGui::Checkbox("Muteki", &Muteki);
	ImGui::Checkbox("colLock", &colLock);


	ImGui::End();

}

void Player::Draw()
{
	for (std::unique_ptr<BulletManager>& bullet : bullets_)
	{
		bullet->Draw();
	}
	for (std::unique_ptr<DeathParticle>& dp : deathPaticles)
	{
		dp->Draw();
	}

	St->Draw();
	if (colLock)
	{
		colBox->Draw();
	}
	//prePP->Draw();
}

void Player::DrawUI()
{
	if (OverHeat)
	{
		sprite_ENGauge->Wt.color = { 1.0f,0,0,1.0f };
	}
	else
	{
		sprite_ENGauge->Wt.color = { 0.0f, 0.15f, 0.75f, 1.0f };
	}

	sprite_Reticle->Draw();
	sprite_Lock->Draw();
	sprite_CoverHPbar->Draw();
	sprite_CoverENGaugebar->Draw();
	KeyUI->Draw(1280.0f-64.0f, 720.0f-128.0f, 1280.0f, 720.0f);
	if (ENGauge > 0)
	{
		sprite_ENGauge->Draw();
	}
	if (HP > 0)
	{
		sprite_HPbar->Draw();
	}
	

	
}

void Player::TitleUpdate()
{

	St->Wt.rotation_.y += 0.05f;

#ifdef _DEBUG
	ImGuiSet();
#endif
	St->Update(camera->getView());
}

void Player::StartUpdate()
{
	SceneCameraTimer++;
	St->Wt.translation_.y = easeOutQuint(50.0f, 1.5f, static_cast<float>(SceneCameraTimer), static_cast<float>(SceneCameraTime));

	if (SceneCameraTimer >= SceneCameraTime)
	{
		SceneCameraTimer = SceneCameraTime;
		startFlag = true;
	}
	prePlayer.translation_ = St->Wt.translation_;
#ifdef _DEBUG
	ImGuiSet();
#endif
	St->Update(camera->getView());
}




============================================================
File Path: SourceCode/App/Player/Player.h
============================================================
#pragma once
#include"Input.h"
#include"PlayerBullet.h"
#include"BulletManager.h"
#include"StuructTransform.h"
#include"ParticleManager.h"
#include"DeathParticle.h"


class Player : public StuructTransform
{
public:
	void SetEnemy(WorldTransform* enemy)
	{
		boss = enemy;
	}

	void Init();

	void Reset();

	void Update();

	void Damege(float dmg);

	void HitParticle(Vector3 vec);

	void KnockBack(Vector3 vec);

	void Draw();

	void DrawUI();

	/// <summary>
	/// ä»®ã‚¿ã‚¤ãƒˆãƒ«ç”¨æ›´æ–°
	/// </summary>
	void TitleUpdate();

	void StartUpdate();

	bool Start()
	{
		return startFlag;
	}

	bool Death()
	{
		if (HP <= 0)
		{
			return true;
		}
		else
		{
			return false;
		}
	}

	bool GameEnd()
	{
		return endFlag;
	}

	Vector3 GetPos()
	{
		return St->Wt.translation_;
	}

	WorldTransform GetPre() 
	{
		return prePlayer;
	}
	Vector3 GetUnderPos()
	{
		Vector3 UnderPos = GetPos();
		UnderPos.y -= St->Wt.scale_.y;
		return UnderPos;
	}

	Vector3 GetPredictionPoint() { return playerPredictionPoint; }

	const std::list<std::unique_ptr<BulletManager>>& GetBullets() { return bullets_; };

	const std::list<std::unique_ptr<DeathParticle>>& GetDps() { return deathPaticles; };

	WorldTransform prePlayer;
private:

	/// <summary>
	/// æ”»æ’ƒ
	/// </summary>
	void Attack(Vector3 flont);

	void Move();

	void Jump(Vector3 front);

	void Dash(Vector3 front);

	void EN();

	void LockOn();

	bool ScLock(WorldTransform* prewt);

	void DeathAnimetion();

	Vector2 WorldToMonitor(Vector3 pos);


	void ImGuiSet();

	
	

private:
	WorldTransform* boss;

	std::unique_ptr<OBJ3D> prePP;

	std::unique_ptr<OBJ3D> colBox;
	bool colLock = false;

	
	float move_speed;

	bool BoostMode = false;

	Vector3 moveVec;

	Vector3 playerPredictionPoint;

	Vector3 rotaVec = { 0,0,0 };

	Vector3 mae = { 0,0,0 };

	//HUDå‘¨ã‚Š----------
	std::unique_ptr<Sprite2D> sprite_Reticle;
	std::unique_ptr<Sprite2D> sprite_Lock;
	std::unique_ptr<Sprite2D> sprite_HPbar;
	std::unique_ptr<Sprite2D> sprite_CoverHPbar;
	std::unique_ptr<Sprite2D> sprite_ENGauge;
	std::unique_ptr<Sprite2D> sprite_CoverENGaugebar;

	std::unique_ptr<Sprite2D> KeyUI;

	uint32_t reticleHandle;
	uint32_t LockHandle;
	uint32_t HpBarHandle;


	Vector2 hpBarShakePos = {0,0};

	float hpBarShakeNum = 0;

	//----------------

	Vector2 Lock2DPos = { 0,0 };

	float scale = 1.0f;
	int DpRate = 0;
	const int DpRateNum = 1;

	//å¼¾é–¢é€£
	std::list<std::unique_ptr<BulletManager>> bullets_;

	std::list<std::unique_ptr<DeathParticle>> deathPaticles;

	const float MaxHP = 20.0f;
	float HP = 0.0f;


	int bulletCT = 0;

	const int MAXBulletCT = 5;

	const int firelate = 15;

	int latetime;

	bool Locked = false;

	//ã‚¯ã‚¤ãƒƒã‚¯ãƒ€ãƒƒã‚·ãƒ¥å‘¨ã‚Š

	float dashspeed = 0.0f;

	const float DashSpeadNum = 5.0f;

	Vector3 DashVec = { 0,0,0 };

	bool DashFlag = false;

	int DashTimer = 0;
	const int DashTime = 20;

	//ã‚¸ãƒ£ãƒ³ãƒ—andç©ºä¸­å‘¨ã‚Š

	bool OnGround = false;

	float Upspeed = 0.0f;

	Vector3 JumpVec = { 0,0,0 };

	const float AirUpSpead = 0.5f;

	const float UpSpeadNum = 2.0f;

	bool JumpFlag = false;

	int JumpTimer = 0;
	const int JumpTime = 20;

	//ãƒ–ãƒ¼ã‚¹ãƒˆã‚²ãƒ¼ã‚¸çš„ãªä½•ã‹-------
	const float ENGaugeSize = 15.0f;

	int ENGauge = 0;

	const int ENMAXGauge = 1000;

	const int DashUseGauge = 200;

	const int JumpUseGauge = 100;

	const int AirUseGauge = 7;

	bool UseEN = false;

	int RegenENCoolTimer = 0;

	const int RegenENCoolTime = 60;

	const int RegenEN = 3;

	const int RecoveryENGauge = 1;

	bool OverHeat = false;

	int OverHeatENCoolTimer = 0;

	const int OverHeatENCoolTime = 250;

	bool InfEN = false;

	bool Muteki = false;



	//--------

	int DeathTimer = 0;

	const int DeathTime = 120;

	int SceneCameraTimer = 0;

	const int SceneCameraTime = 120;

	bool startFlag = false;

	bool endFlag = false;

	
	float diff = 0;

	//ãƒŽãƒƒã‚¯ãƒãƒƒã‚¯
	bool knockBack = false;
	Vector3 knockVec = { 0,0,0 };
	float knockSpeed = 0;
	const float knockSpeedNum = 5.0f;
	

};




============================================================
File Path: SourceCode/App/Player/PlayerBullet.cpp
============================================================
#include "PlayerBullet.h"

std::unique_ptr<ObjModel> PlayerBullet::Premodel;

PlayerBullet::PlayerBullet()
{
	ModelInit(Premodel.get());
	Velocity_ = { 0,0,0 };
}

PlayerBullet::~PlayerBullet()
{
}

void PlayerBullet::SetModel(ObjModel* model)
{
	Premodel.reset(model);
}

void PlayerBullet::Initlize(const Vector3& position, const Vector3& rota, const Vector3& velocity)
{
	St->Wt.translation_ = position;
	St->Wt.rotation_ = rota;
	St->Wt.scale_ = { 0.5f,0.5f,0.5f };
	
	Velocity_ = velocity;
}

void PlayerBullet::Update()
{
	St->Wt.translation_ = St->Wt.translation_ + Velocity_;

	St->Update(camera->getView());

	//ãƒ‡ã‚¹ã‚¿ã‚¤ãƒžãƒ¼ã‚’ã²ã„ã¦0ä»¥ä¸‹ã«ãªã£ãŸã‚‰ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
	if (--deathTimer_ <= 0)
	{
		isDead_ = true;
	}
}

void PlayerBullet::Draw()
{
	//bullet.Draw();
	St->Draw();
}




============================================================
File Path: SourceCode/App/Player/PlayerBullet.h
============================================================
#pragma once
#include "BulletManager.h"
using namespace DirectX;
class PlayerBullet:public BulletManager
{
public:
	PlayerBullet();
	~PlayerBullet();

	static void SetModel(ObjModel* model);

	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="model">ãƒ¢ãƒ‡ãƒ«</param>
	/// <param name="position">åˆæœŸåº§æ¨™</param>
	/// <param name="velocity">é€Ÿåº¦</param>
	void Initlize(const Vector3& position, const Vector3& rota, const Vector3& velocity) override;

	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void Update() override;

	/// <summary>
	/// æç”»
	/// </summary>
	/// <param name="viewProjection">ãƒ“ãƒ¥ãƒ¼ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³</param>
	void Draw() override;

	
private:

	static std::unique_ptr<ObjModel> Premodel;

	//ãƒ¢ãƒ‡ãƒ«
	//StuructTransform bullet;
	

	//ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒãƒ³ãƒ‰ãƒ«


	//é€Ÿåº¦
	Vector3 Velocity_;

	//å¯¿å‘½<frm>
	static const int32_t kLifeTime = 60 * 5;

	//ãƒ‡ã‚¹ã‚¿ã‚¤ãƒžãƒ¼
	int32_t deathTimer_ = kLifeTime;

	//ãƒ‡ã‚¹ãƒ•ãƒ©ã‚°
	bool isDead_ = false;

};


============================================================
File Path: SourceCode/App/StuructTransform.cpp
============================================================
#include "StuructTransform.h"

Camera* StuructTransform::camera = nullptr;
SpriteCommon* StuructTransform::spCommon = nullptr;
TextureManager* StuructTransform::texMana = nullptr;

void StuructTransform::SetStruct(Camera* _camera, SpriteCommon* spcommon, TextureManager* texmana)
{
	camera = _camera;
	spCommon = spcommon;
	texMana = texmana;
}

void StuructTransform::ModelInit(const string& modelname, bool smooth)
{
	model.reset(ObjModel::LoadFromOBJ(modelname, smooth));

	St.reset(OBJ3D::Create());
	St->SetModel(model.get());

}

void StuructTransform::ModelInit(ObjModel* _model)
{
	St.reset(OBJ3D::Create());
	St->SetModel(_model);
}


============================================================
File Path: SourceCode/App/StuructTransform.h
============================================================
#pragma once
#include"OBJ3D.h"
#include"ObjModel.h"
#include"Camera.h"
#include"Sprite2D.h"
#include"SpriteCommon.h"
class StuructTransform
{
public:

	//å„ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ¼ãƒ³åŒ–ã—ãŸã‚‰ä¸è¦ã«ãªã‚‹ã‹ã‚‚
	static void SetStruct(Camera* _camera, SpriteCommon* spcommon, TextureManager* texmana);


	/// <summary>
	/// æ–°ã—ããƒ¢ãƒ‡ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰
	/// </summary>
	/// <param name="modelname"></param>
	/// <param name="smooth"></param>
	void ModelInit(const string& modelname,bool smooth=false);

	/// <summary>
	/// ãƒ¢ãƒ‡ãƒ«ãã®ã‚‚ã®ã‚’ãƒ­ãƒ¼ãƒ‰
	/// </summary>
	/// <param name="_model"></param>
	void ModelInit(ObjModel* _model);

	
	std::unique_ptr<OBJ3D> St;
	std::unique_ptr<ObjModel> model;
protected:

	static SpriteCommon* spCommon;
	static TextureManager* texMana;
	static Camera* camera;

};



============================================================
File Path: SourceCode/App/UI.cpp
============================================================
#include "UI.h"


============================================================
File Path: SourceCode/App/UI.h
============================================================
#pragma once
#include"TextureManager.h"
#include"Sprite2D.h"
#include"SpriteCommon.h"
class UI
{




};



============================================================
File Path: SourceCode/App/main.cpp
============================================================
#include"DxWindow.h"
#include"DirectXCommon.h"
//#include"Object3D.h"
#include "OBJ3D.h"
#include"Input.h"
#include<wrl.h>
#include"LightGroup.h"
#include<sstream>
#include<iomanip>
#include"ImGuiManager.h"
#include"FPS.h"
//#include"FbxLoader.h"
#include"ParticleManager.h"
#include"PostEffect.h"
#include"SpriteCommon.h"
#include"Draw3DLine.h"

#include "GameScene.h"

using namespace SKNEngine;
//template <class T>
//inline void complete_type_safe_delete(T * &p) {
//	//  ä¸å®Œå…¨ãªåž‹ã®ãƒã‚¤ãƒ³ã‚¿ã‚’deleteã—ã‚ˆã†ã¨ã—ãŸæ™‚ã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ã«ã™ã‚‹
//	typedef char type_must_be_complete[sizeof(T) ? 1 : -1];
//	(void)sizeof(type_must_be_complete);
//
//	delete p;
//	p = nullptr;
//}

int WINAPI WinMain(HINSTANCE, HINSTANCE, LPSTR, int)
{

	DxWindow* window = nullptr;
	GameScene* gameScene = nullptr;

	window = DxWindow::GetInstance();
	window->CreateGameWindow();
#ifdef _DEBUG
	//ãƒ‡ãƒãƒƒã‚°ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ã‚ªãƒ³ã«
	ComPtr<ID3D12Debug1> debugController;
	if (SUCCEEDED(D3D12GetDebugInterface(IID_PPV_ARGS(&debugController))))
	{
		debugController->EnableDebugLayer();
		debugController->SetEnableGPUBasedValidation(TRUE);
	}
#endif	
	DirectXCommon* dxCommon = nullptr;
	dxCommon = new DirectXCommon();
	dxCommon->Initialize(window);
	ImGuiManager::Initialize(window->GetHwnd(), dxCommon);

	//FbxLoader::GetInstance()->Initialize(dxCommon->GetDevice());
	//Input::Init(window->GetHInstance(), window->GetHwnd());

	OBJ3D::StaticInitialize(dxCommon->GetDevice());
	/*Object3D::SetDevice(dxCommon->GetDevice());
	//Object3D::CreateGraphicsPipeline();*/
	//Draw3DLine::SetDevice(dxCommon->GetDevice(),dxCommon->GetCommandList());
	//ParticleManager::StaticInitialize(dxCommon->GetDevice());
	//LightGroup::StaticInitialize(dxCommon->GetDevice());
	//PostEffect::SetDXCommon(dxCommon);
	//PostEffect::CreateGraphicsPipeline();

	

	//PostEffect* postEffect = nullptr;
	//postEffect = new PostEffect();
	//postEffect->Initialize();

	//unique_ptr<FPS>fps;
	//fps = std::make_unique<FPS>();
	//fps->Initialize();

	gameScene = new GameScene();
	gameScene->Init(dxCommon);

	
	//while (true)
	//{
	//	if (window->ProcessMessage())
	//	{
	//		break;
	//	}
	//	ImGuiManager::Begin();
	//	Input::InputUpdate();

	//	gameScene->Update();


	//	postEffect->PreDrawScene(dxCommon->GetCommandList());
	//	gameScene->Draw(dxCommon);
	//	postEffect->PostDrawScene(dxCommon->GetCommandList());
	//	
	//	dxCommon->PreDraw();
	//	postEffect->Draw(dxCommon->GetCommandList());
	//	//gameScene->Draw(dxCommon);

	//	ImGuiManager::Draw();
	//	dxCommon->PostDraw();

	//	fps->Update();

	//}

	
	//gameScene->Finalize();
	//FbxLoader::GetInstance()->Finalize();
	//complete_type_safe_delete(gameScene);
	//complete_type_safe_delete(postEffect);
	//ImGuiManager::Finalize();
	//complete_type_safe_delete(dxCommon);
	//window->TerminateGameWindow();
}

============================================================
File Path: SourceCode/Engine/Buffer/ConstBuffer.cpp
============================================================
#include "ConstBuffer.h"
using namespace SKNEngine;

void ConstBuffer::Create(DirectXCommon* dxcommon, size_t size)
{
	bufferSize = size;

	//é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã®è¨­å®š
	D3D12_HEAP_PROPERTIES heapProp{};//ãƒ’ãƒ¼ãƒ—è¨­å®š
	heapProp.Type = D3D12_HEAP_TYPE_UPLOAD;//GPUã¸ã®è»¢é€ç”¨
	//ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
	D3D12_RESOURCE_DESC resDesc{};
	resDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
	resDesc.Width = (bufferSize + 0xff) & ~0xff;//é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿å…¨ä½“ã®ã‚µã‚¤ã‚º
	resDesc.Height = 1;
	resDesc.DepthOrArraySize = 1;
	resDesc.MipLevels = 1;
	resDesc.SampleDesc.Count = 1;
	resDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;

	// ãƒªã‚½ãƒ¼ã‚¹ã‚’ç”Ÿæˆ
	HRESULT result = dxcommon->GetDevice()->CreateCommittedResource(
		&heapProp,
		D3D12_HEAP_FLAG_NONE,
		&resDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(buffer.ReleaseAndGetAddressOf()));

	result = buffer->Map(0, nullptr, &bufferMappedPtr);

	constantBufferView = {};
	constantBufferView.BufferLocation = buffer->GetGPUVirtualAddress();
	constantBufferView.SizeInBytes = static_cast<UINT>(resDesc.Width);

	dxcommon->GetDescriptorHeap()->CreateCBV(constantBufferView);


}

D3D12_GPU_VIRTUAL_ADDRESS ConstBuffer::GetAddress() const
{
	return D3D12_GPU_VIRTUAL_ADDRESS();
}

D3D12_CONSTANT_BUFFER_VIEW_DESC ConstBuffer::GetViewDesc()
{
	return D3D12_CONSTANT_BUFFER_VIEW_DESC();
}

//void ConstBuffer::Update(void* data)
//{
//}

ID3D12Resource* ConstBuffer::GetResource()
{
	return nullptr;
}

void* ConstBuffer::GetPtr()
{
	return nullptr;
}


============================================================
File Path: SourceCode/Engine/Buffer/ConstBuffer.h
============================================================
#pragma once
#include<wrl.h>
#include <d3d12.h>
#include"DirectXCommon.h"
using namespace Microsoft::WRL;

class ConstBuffer
{

public:
	ConstBuffer() = default;
	~ConstBuffer() = default;

	void Create(SKNEngine::DirectXCommon* dxcommon, size_t size);

	D3D12_GPU_VIRTUAL_ADDRESS GetAddress() const;

	D3D12_CONSTANT_BUFFER_VIEW_DESC GetViewDesc();

	//void Update(void* data);

	ID3D12Resource* GetResource();

	void* GetPtr();

private:

	
	ComPtr<ID3D12Resource> buffer;

	
	D3D12_CONSTANT_BUFFER_VIEW_DESC constantBufferView = {};

	void* bufferMappedPtr = nullptr;

	size_t bufferSize;

	ConstBuffer(const ConstBuffer&) = delete;
	void operator = (const ConstBuffer&) = delete;

};



============================================================
File Path: SourceCode/Engine/Buffer/IndexBuffer.cpp
============================================================
#include "IndexBuffer.h"

void IndexBuffer::Create(ID3D12Device* device, size_t length, const void* data)
{
	bufferLength = length;

	//ãƒ’ãƒ¼ãƒ—è¨­å®š
	D3D12_HEAP_PROPERTIES heapProp{};
	//ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
	D3D12_RESOURCE_DESC resDesc{};

	//ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ‡ãƒ¼ã‚¿ã®ã‚µã‚¤ã‚º
	UINT sizeIB = static_cast<UINT>(sizeof(uint32_t) * length);
	//é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã®è¨­å®š
	heapProp.Type = D3D12_HEAP_TYPE_UPLOAD;//GPUã¸ã®è»¢é€ç”¨
	//ãƒªã‚½ãƒ¼ã‚¹è¨­å®šã€€
	resDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
	resDesc.Width = sizeIB;
	resDesc.Height = 1;
	resDesc.DepthOrArraySize = 1;
	resDesc.MipLevels = 1;
	resDesc.SampleDesc.Count = 1;
	resDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;

	// ãƒªã‚½ãƒ¼ã‚¹ã‚’ç”Ÿæˆ
	HRESULT result = device->CreateCommittedResource(
		&heapProp,
		D3D12_HEAP_FLAG_NONE,
		&resDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(indexBuff.ReleaseAndGetAddressOf()));

	// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã®è¨­å®š
	ibView = {};
	ibView.BufferLocation = indexBuff->GetGPUVirtualAddress();
	ibView.Format = DXGI_FORMAT_R32_UINT;
	ibView.SizeInBytes = static_cast<UINT>(length * sizeof(uint32_t));

	result =indexBuff->Map(0, nullptr, &bufferMappedPtr);

	// ãƒžãƒƒãƒ”ãƒ³ã‚°ã™ã‚‹
	if (data != nullptr)
	{
		// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ãƒžãƒƒãƒ”ãƒ³ã‚°å…ˆã«è¨­å®š
		memcpy(bufferMappedPtr, data, length * sizeof(uint32_t));

		// ãƒžãƒƒãƒ”ãƒ³ã‚°è§£é™¤
		indexBuff->Unmap(0, nullptr);
	}

}

D3D12_INDEX_BUFFER_VIEW IndexBuffer::GetView() const
{
	return ibView;
}

void IndexBuffer::Update(void* data)
{
	memcpy(bufferMappedPtr, data, bufferLength * sizeof(uint32_t));
}


============================================================
File Path: SourceCode/Engine/Buffer/IndexBuffer.h
============================================================
#pragma once
#include<wrl.h>
#include <d3d12.h>
#include <cstdint>

using namespace Microsoft::WRL;
class IndexBuffer
{
public:

    IndexBuffer() = default;
    ~IndexBuffer() = default;

    void Create(ID3D12Device* device, size_t length, const void* data = nullptr);

    D3D12_INDEX_BUFFER_VIEW GetView() const;

    void Update(void* data);
private:

    ComPtr<ID3D12Resource> indexBuff;

    D3D12_INDEX_BUFFER_VIEW ibView;

    void* bufferMappedPtr = nullptr;

    size_t bufferLength = 0;

    IndexBuffer(const IndexBuffer&) = delete;
    void operator = (const IndexBuffer&) = delete;
};



============================================================
File Path: SourceCode/Engine/Buffer/VertexBuffer.cpp
============================================================
#include "VertexBuffer.h"

void VertexBuffer::Create(ID3D12Device* device, size_t length, size_t singleSize, const void* data)
{
	// ãƒ’ãƒ¼ãƒ—è¨­å®š
	D3D12_HEAP_PROPERTIES heapProp{};
	//ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
	D3D12_RESOURCE_DESC resDesc{};

	//é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿å…¨ä½“ã®ã‚µã‚¤ã‚º = é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚ºä¸€ã¤åˆ†ã®ã‚µã‚¤ã‚º * é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã®è¦ç´ æ•°
	UINT sizeVB = static_cast<UINT>(singleSize * length);

	//é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã®è¨­å®š
	heapProp.Type = D3D12_HEAP_TYPE_UPLOAD;//GPUã¸ã®è»¢é€ç”¨
	//ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
	resDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
	resDesc.Width = sizeVB;
	resDesc.Height = 1;
	resDesc.DepthOrArraySize = 1;
	resDesc.MipLevels = 1;
	resDesc.SampleDesc.Count = 1;
	resDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;

	// ãƒªã‚½ãƒ¼ã‚¹ã‚’ç”Ÿæˆ
	HRESULT result = device->CreateCommittedResource(
		&heapProp,
		D3D12_HEAP_FLAG_NONE,
		&resDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(vertBuff.ReleaseAndGetAddressOf()));

	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã®è¨­å®š
	vbView.BufferLocation = vertBuff->GetGPUVirtualAddress();
	vbView.SizeInBytes = sizeVB;
	vbView.StrideInBytes = static_cast<UINT>(singleSize);

	result = vertBuff->Map(0, nullptr, &bufferMappedPtr);

	// ãƒžãƒƒãƒ”ãƒ³ã‚°ã™ã‚‹
	if (data != nullptr)
	{
		// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ãƒžãƒƒãƒ”ãƒ³ã‚°å…ˆã«è¨­å®š
		memcpy(bufferMappedPtr, data, length * singleSize);
	}

}

D3D12_VERTEX_BUFFER_VIEW VertexBuffer::GetView() const
{
	return vbView;
}

ID3D12Resource* VertexBuffer::GetResource()
{
	return vertBuff.Get();
}

void VertexBuffer::Update(void* data)
{
	if (data == nullptr)
	{
		return;
	}

	// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ãƒžãƒƒãƒ”ãƒ³ã‚°å…ˆã«è¨­å®š
	memcpy(bufferMappedPtr, data, vbView.SizeInBytes);
}


============================================================
File Path: SourceCode/Engine/Buffer/VertexBuffer.h
============================================================
#pragma once
#include<wrl.h>
#include <d3d12.h>

using namespace Microsoft::WRL;

class VertexBuffer
{
public:

	VertexBuffer() = default;
	~VertexBuffer() = default;

	void Create(ID3D12Device* device, size_t length, size_t singleSize, const void* data = nullptr);

	D3D12_VERTEX_BUFFER_VIEW GetView() const;

	ID3D12Resource* GetResource();

	void Update(void* data);
private:

	ComPtr<ID3D12Resource> vertBuff = nullptr;
	D3D12_VERTEX_BUFFER_VIEW vbView;
	void* bufferMappedPtr = nullptr;

	VertexBuffer(const VertexBuffer&) = delete;

	void operator = (const VertexBuffer&) = delete;
};



============================================================
File Path: SourceCode/Engine/Core/DescriptorHeap.cpp
============================================================
#include "DescriptorHeap.h"
#include<cassert>

void DescriptorHeap::Initialize(ID3D12Device* Device)
{
	device = Device;
	HRESULT result = S_FALSE;

	D3D12_DESCRIPTOR_HEAP_DESC descHeapDesc = {};
	descHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
	descHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;//ã‚·ã‚§ãƒ¼ãƒ€ã‹ã‚‰è¦‹ãˆã‚‹ã‚ˆã†ã«
	descHeapDesc.NumDescriptors = static_cast<UINT>(MaxSRV + MaxCBV);
	result = device->CreateDescriptorHeap(&descHeapDesc, IID_PPV_ARGS(descHeap.ReleaseAndGetAddressOf()));//ç”Ÿæˆ
	assert(SUCCEEDED(result));

	startCpuHandle = descHeap->GetCPUDescriptorHandleForHeapStart();
	startGpuHandle = descHeap->GetGPUDescriptorHandleForHeapStart();

	incrementSize = static_cast<UINT>(device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV));

}

UINT64 DescriptorHeap::CreateSRV(D3D12_SHADER_RESOURCE_VIEW_DESC& desc, ID3D12Resource* resource)
{
	if (SRVCount > MaxSRV)
	{
		assert(0);
	}
	//SRVãƒ’ãƒ¼ãƒ—ã®å…ˆé ­ãƒãƒ³ãƒ‰ãƒ«ã‚’å–å¾—
	DescriptorHeapViewHandle handle{};
	SRVCount++;

	//ãƒãƒ³ãƒ‰ãƒ«ã®ãƒã‚¤ãƒ³ã‚¿ãšã‚‰ã—
	handle.cpuHandle.ptr = startCpuHandle.ptr + (static_cast<SIZE_T>(SRVCount) * incrementSize);
	handle.gpuHandle.ptr = startGpuHandle.ptr + (static_cast<SIZE_T>(SRVCount) * incrementSize);

	// ãƒãƒ³ãƒ‰ãƒ«ã®æŒ‡ã™ä½ç½®ã«ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒªã‚½ãƒ¼ã‚¹ãƒ“ãƒ¥ãƒ¼ä½œæˆ
	device->CreateShaderResourceView(resource, &desc, handle.cpuHandle);
	SRVCount++;

	return handle.gpuHandle.ptr;
}

UINT64 DescriptorHeap::CreateCBV(D3D12_CONSTANT_BUFFER_VIEW_DESC& desc)
{
	if (CBVCount > MaxCBV)
	{
		CBVCount = 0;
	}

	//SRVãƒ’ãƒ¼ãƒ—ã®å…ˆé ­ãƒãƒ³ãƒ‰ãƒ«ã‚’å–å¾—
	DescriptorHeapViewHandle handle{};

	//ãƒãƒ³ãƒ‰ãƒ«ã®ãƒã‚¤ãƒ³ã‚¿ãšã‚‰ã—
	handle.cpuHandle.ptr = startCpuHandle.ptr + (static_cast<SIZE_T>(MaxSRV + CBVCount) * incrementSize);
	handle.gpuHandle.ptr = startGpuHandle.ptr + (static_cast<SIZE_T>(MaxSRV + CBVCount) * incrementSize);

	// ãƒãƒ³ãƒ‰ãƒ«ã®æŒ‡ã™ä½ç½®ã«ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒªã‚½ãƒ¼ã‚¹ãƒ“ãƒ¥ãƒ¼ä½œæˆ
	device->CreateConstantBufferView(&desc, handle.cpuHandle);

	CBVCount++;

	return handle.gpuHandle.ptr;
}

DescriptorHeap::DescriptorHeapViewHandle DescriptorHeap::AddSRV()
{
	if (SRVCount > MaxSRV)
	{
		assert(0);
	}
	//SRVãƒ’ãƒ¼ãƒ—ã®å…ˆé ­ãƒãƒ³ãƒ‰ãƒ«ã‚’å–å¾—
	DescriptorHeapViewHandle handle{};

	//ãƒãƒ³ãƒ‰ãƒ«ã®ãƒã‚¤ãƒ³ã‚¿ãšã‚‰ã—
	handle.cpuHandle.ptr = startCpuHandle.ptr + (static_cast<SIZE_T>(SRVCount) * incrementSize);
	handle.gpuHandle.ptr = startGpuHandle.ptr + (static_cast<SIZE_T>(SRVCount) * incrementSize);

	SRVCount++;

	return handle;
}


ComPtr<ID3D12DescriptorHeap> DescriptorHeap::GetHeap()
{
	return descHeap;
}

============================================================
File Path: SourceCode/Engine/Core/DescriptorHeap.h
============================================================
#pragma once
#include<wrl.h>
#include <d3d12.h>

using namespace Microsoft::WRL;

class DescriptorHeap
{
public:

	struct DescriptorHeapViewHandle
	{
		D3D12_CPU_DESCRIPTOR_HANDLE cpuHandle;
		D3D12_GPU_DESCRIPTOR_HANDLE gpuHandle;
	};

	void Initialize(ID3D12Device* Device);


	UINT64 CreateSRV(D3D12_SHADER_RESOURCE_VIEW_DESC& desc, ID3D12Resource* resource);

	UINT64 CreateCBV(D3D12_CONSTANT_BUFFER_VIEW_DESC& desc);

	DescriptorHeapViewHandle AddSRV();

	ComPtr<ID3D12DescriptorHeap> GetHeap();

private:

	ComPtr <ID3D12Device> device;
	ComPtr <ID3D12DescriptorHeap> descHeap;
	D3D12_DESCRIPTOR_RANGE descriptorRange{};

	const size_t MaxSRV = 400000;
	const size_t MaxCBV = 600000;

	size_t SRVCount = 0;
	size_t CBVCount = 0;



	UINT incrementSize = 0;

	D3D12_CPU_DESCRIPTOR_HANDLE	startCpuHandle;
	D3D12_GPU_DESCRIPTOR_HANDLE	startGpuHandle;

};

============================================================
File Path: SourceCode/Engine/Core/DirectXCommon.cpp
============================================================
#include "DirectXCommon.h"
#include<cassert>

#pragma comment(lib,"d3d12.lib")
#pragma comment(lib,"dxgi.lib")

using namespace SKNEngine;


DirectXCommon::DirectXCommon()
{
	backBufferWidth = 0;
	backBufferHeight = 0;

	fenceVal = 0;
}

void DirectXCommon::Initialize(DxWindow* win, int32_t BackBufferWidth, int32_t BackBufferHeight)
{
	assert(win);

	dxWin = win;
	this->backBufferWidth = BackBufferWidth;
	this->backBufferHeight = BackBufferHeight;

	InitializeDXGIdevice();

	InitializeCommand();

	InitializeSwapChain();

	InitializeRenserTargetView();

	InitializeDepthBuffer();

	InitializeFence();

	descHeap = make_unique<DescriptorHeap>();
	descHeap->Initialize(device.Get());
}

void DirectXCommon::PreDraw()
{
	//HRESULT result;
	//ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ã®ç•ªå·ã‚’å–å¾—(2ã¤ãªã®ã§0ç•ªã‹1ç•ª)
	UINT bbIndex = swapChain->GetCurrentBackBufferIndex();

	D3D12_RESOURCE_BARRIER barrierDesc{};

	barrierDesc.Transition.pResource = backBuffers[bbIndex].Get();				//ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ã‚’æŒ‡å®š
	barrierDesc.Transition.StateBefore = D3D12_RESOURCE_STATE_PRESENT;		//è¡¨ç¤ºçŠ¶æ…‹ã‹ã‚‰
	barrierDesc.Transition.StateAfter = D3D12_RESOURCE_STATE_RENDER_TARGET;	//æç”»çŠ¶æ…‹ã¸

	commandList->ResourceBarrier(1, &barrierDesc);

	//ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ“ãƒ¥ãƒ¼ã®ãƒãƒ³ãƒ‰ãƒ«ã‚’å–å¾—
	D3D12_CPU_DESCRIPTOR_HANDLE rtvHandle = rtvHeap->GetCPUDescriptorHandleForHeapStart();
	rtvHandle.ptr += bbIndex * device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);
	D3D12_CPU_DESCRIPTOR_HANDLE dsvHandle = dsvHeap->GetCPUDescriptorHandleForHeapStart();
	commandList->OMSetRenderTargets(1, &rtvHandle, false, &dsvHandle);

	//3. ç”»é¢ã‚¯ãƒªã‚¢
	FLOAT clearColor[] = { 0.1f,0.25f,0.5f,0.0f };	//è‰²ã®æŒ‡å®šã¯RGBAã®0.0fï½ž1.0f

	commandList->ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
	commandList->ClearDepthStencilView(dsvHandle, D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr);

	D3D12_VIEWPORT viewport{};
	viewport.Width = float(backBufferWidth);
	viewport.Height = float(backBufferHeight);
	viewport.TopLeftX = 0;
	viewport.TopLeftY = 0;
	viewport.MinDepth = 0.0f;
	viewport.MaxDepth = 1.0f;

	commandList->RSSetViewports(1, &viewport);

	D3D12_RECT scissorRect{};
	scissorRect.left = 0;										//åˆ‡ã‚ŠæŠœãåº§æ¨™å·¦
	scissorRect.right = scissorRect.left + backBufferWidth;		//åˆ‡ã‚ŠæŠœãåº§æ¨™å³
	scissorRect.top = 0;										//åˆ‡ã‚ŠæŠœãåº§æ¨™ä¸Š
	scissorRect.bottom = scissorRect.top + backBufferHeight;		//åˆ‡ã‚ŠæŠœãåº§æ¨™ä¸‹

	//ã‚·ã‚¶ãƒ¼çŸ©å½¢è¨­å®šã‚³ãƒžãƒ³ãƒ‰ã‚’ã€ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆã«ç©ã‚€
	commandList->RSSetScissorRects(1, &scissorRect);

}

void DirectXCommon::PostDraw()
{
	HRESULT result;

	UINT bbIndex = swapChain->GetCurrentBackBufferIndex();

	D3D12_RESOURCE_BARRIER barrierDesc{};

	barrierDesc.Transition.pResource = backBuffers[bbIndex].Get();
	barrierDesc.Transition.StateBefore = D3D12_RESOURCE_STATE_RENDER_TARGET;	//æç”»çŠ¶æ…‹ã‹ã‚‰
	barrierDesc.Transition.StateAfter = D3D12_RESOURCE_STATE_PRESENT;			//è¡¨ç¤ºçŠ¶æ…‹ã¸
	commandList->ResourceBarrier(1, &barrierDesc);

	result=commandList->Close();
	assert(SUCCEEDED(result));
	//ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®å®Ÿè¡Œ
	ID3D12CommandList* commandLists[] = { commandList.Get() };
	commandQueue->ExecuteCommandLists(1, commandLists);

	//ç”»é¢ã«è¡¨ç¤ºã™ã‚‹ãƒãƒƒãƒ•ã‚¡ã‚’ãƒ•ãƒªãƒƒãƒ—(è£è¡¨ã®å…¥ã‚Œæ›¿ãˆ)
	result = swapChain->Present(1, 0);
	assert(SUCCEEDED(result));

	//ã‚³ãƒžãƒ³ãƒ‰ã®å®Ÿè¡Œå®Œäº†ã‚’å¾…ã¤
	commandQueue->Signal(fence.Get(), ++fenceVal);
	if (fence->GetCompletedValue() != fenceVal)
	{
		HANDLE event = CreateEvent(nullptr, false, false, nullptr);
		fence->SetEventOnCompletion(fenceVal, event);
		WaitForSingleObject(event, INFINITE);
		CloseHandle(event);
	}

	//ã‚­ãƒ¥ãƒ¼ã‚’ã‚¯ãƒªã‚¢
	result = commandAllocator->Reset();
	assert(SUCCEEDED(result));
	//å†ã³ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆã‚’ãŸã‚ã‚‹æº–å‚™
	result = commandList->Reset(commandAllocator.Get(), nullptr);
	assert(SUCCEEDED(result));

}

void DirectXCommon::InitializeDXGIdevice()
{
	HRESULT result = S_FALSE;

	D3D_FEATURE_LEVEL levels[] =
	{
		D3D_FEATURE_LEVEL_12_1,
		D3D_FEATURE_LEVEL_12_0,
		D3D_FEATURE_LEVEL_11_1,
		D3D_FEATURE_LEVEL_11_0,
	};


	//DXGIãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ã®ç”Ÿæˆ
	result = CreateDXGIFactory(IID_PPV_ARGS(dxgiFactory.GetAddressOf()));
	assert(SUCCEEDED(result));


	//ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã®åˆ—æŒ™ç”¨
	std::vector <ComPtr<IDXGIAdapter4>>adapters;
	//ã“ã“ã«ç‰¹å®šã®åå‰ã‚’æŒã¤ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå…¥ã‚‹
	ComPtr<IDXGIAdapter4> tmpAdapter;

	//ãƒ‘fï¼ãƒžãƒ³ã‚¹ãŒé«˜ã„ã‚‚ã®ã‹ã‚‰é †ã«ã€å…¨ã¦ã®ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã‚’åˆ—æŒ™ã™ã‚‹
	for (UINT i = 0; dxgiFactory->EnumAdapterByGpuPreference(i, DXGI_GPU_PREFERENCE_HIGH_PERFORMANCE, IID_PPV_ARGS(&tmpAdapter)) != DXGI_ERROR_NOT_FOUND; i++)
	{
		//å‹•çš„ã«é…åˆ—ã‚’è¿½åŠ ã™ã‚‹
		adapters.push_back(tmpAdapter);
	}
	for (size_t i = 0; i < adapters.size(); i++)
	{
		DXGI_ADAPTER_DESC3 adapterDesc;
		//ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã®æƒ…å ±ã‚’å–å¾—ã™ã‚‹
		adapters[i]->GetDesc3(&adapterDesc);

		//ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ãƒ‡ãƒã‚¤ã‚¹ã‚’å›žé¿
		if (!(adapterDesc.Flags & DXGI_ADAPTER_FLAG3_SOFTWARE))
		{
			//ãƒ‡ãƒã‚¤ã‚¹ã‚’æŽ¡ç”¨ã—ã¦ãƒ«ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹
			tmpAdapter = adapters[i];
			break;
		}
	}
	D3D_FEATURE_LEVEL featureLevel;
	for (size_t i = 0; i < _countof(levels); i++)
	{
		//æŽ¡ç”¨ã—ãŸã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã§ãƒ‡ãƒã‚¤ã‚¹ã‚’ç”Ÿæˆ
		result = D3D12CreateDevice(tmpAdapter.Get(), levels[i], IID_PPV_ARGS(device.GetAddressOf()));
		if (result == S_OK)
		{
			featureLevel = levels[i];
			break;
		}
	}

	assert(SUCCEEDED(result));
}


void DirectXCommon::InitializeSwapChain()
{
	HRESULT result = S_FALSE;

	//ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ãƒ¼ãƒ³ã®è¨­å®š
	DXGI_SWAP_CHAIN_DESC1 swapChainDesc{};

	swapChainDesc.Width = backBufferWidth;
	swapChainDesc.Height = backBufferHeight;
	swapChainDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;				//è‰²æƒ…å ±ã®æ›¸å¼
	swapChainDesc.SampleDesc.Count = 1;								//ãƒžãƒ«ãƒã‚µãƒ³ãƒ—ãƒ«ã‚’ã—ãªã„
	swapChainDesc.BufferUsage = DXGI_USAGE_BACK_BUFFER;				//ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ç”¨
	swapChainDesc.BufferCount = 2;									//ãƒãƒƒãƒ•ã‚¡æ•°ã‚’2ã¤ã«è¨­å®š
	swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;		//ãƒ•ãƒªãƒƒãƒ—å¾Œã¯ç ´æ£„
	swapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;	//ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ãƒ¼ãƒ³ã®ç”Ÿæˆ

	ComPtr<IDXGISwapChain1> swapchain1;

	HWND hwnd = dxWin->GetHwnd();
	result = dxgiFactory->CreateSwapChainForHwnd(commandQueue.Get(), hwnd, &swapChainDesc, nullptr, nullptr, &swapchain1);
	assert(SUCCEEDED(result));

	swapchain1->QueryInterface(IID_PPV_ARGS(&swapChain));
	assert(SUCCEEDED(result));

}

void DirectXCommon::InitializeRenserTargetView()
{
	HRESULT result = S_FALSE;

	DXGI_SWAP_CHAIN_DESC swapChainDesc = {};
	result = swapChain->GetDesc(&swapChainDesc);
	assert(SUCCEEDED(result));


	//ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã®è¨­å®š
	D3D12_DESCRIPTOR_HEAP_DESC rtvHeapDesc{};

	rtvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;			//ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ“ãƒ¥ãƒ¼
	rtvHeapDesc.NumDescriptors = swapChainDesc.BufferCount;		//è£è¡¨ã®ï¼’ã¤

	device->CreateDescriptorHeap(&rtvHeapDesc, IID_PPV_ARGS(&rtvHeap));

	backBuffers.resize(swapChainDesc.BufferCount);

	

	for (size_t i = 0; i < backBuffers.size(); i++)
	{
		//ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ãƒ¼ãƒ³ã‹ã‚‰ãƒãƒƒãƒ•ã‚¡ã‚’å–å¾—
		swapChain->GetBuffer((UINT)i, IID_PPV_ARGS(&backBuffers[i]));
		//ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã®ãƒãƒ³ãƒ‰ãƒ«ã‚’å–å¾—
		D3D12_CPU_DESCRIPTOR_HANDLE rtvHandle = rtvHeap->GetCPUDescriptorHandleForHeapStart();
		//è£ã‹è¡¨ã‹ã§ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒãšã‚Œã‚‹
		rtvHandle.ptr += i * device->GetDescriptorHandleIncrementSize(rtvHeapDesc.Type);
		D3D12_RENDER_TARGET_VIEW_DESC rtvDesc{};
		//ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®è¨ˆç®—çµæžœã‚’SRGBã«å¤‰æ›ã—ã¦æ›¸ãè¾¼ã‚€
		rtvDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
		rtvDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2D;
		//ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ“ãƒ¥ãƒ¼ã®ç”Ÿæˆ
		device->CreateRenderTargetView(backBuffers[i].Get(), &rtvDesc, rtvHandle);
	}

}

void DirectXCommon::InitializeDepthBuffer()
{
	HRESULT result = S_FALSE;

	D3D12_RESOURCE_DESC depthResourceDesc{};
	depthResourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
	depthResourceDesc.Width = DxWindow::window_width;
	depthResourceDesc.Height = DxWindow::window_height;
	depthResourceDesc.DepthOrArraySize = 1;
	depthResourceDesc.Format = DXGI_FORMAT_D32_FLOAT;
	depthResourceDesc.SampleDesc.Count = 1;
	depthResourceDesc.Flags = D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;

	D3D12_HEAP_PROPERTIES depthHeapProp{};

	//ãƒ’ãƒ¼ãƒ—ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
	depthHeapProp.Type = D3D12_HEAP_TYPE_DEFAULT;

	D3D12_CLEAR_VALUE depthClearValue{};

	//æ·±åº¦å€¤ã®ã‚¯ãƒªã‚¢è¨­å®š
	depthClearValue.DepthStencil.Depth = 1.0f;
	depthClearValue.Format = DXGI_FORMAT_D32_FLOAT;

	result = device->CreateCommittedResource(
		&depthHeapProp,
		D3D12_HEAP_FLAG_NONE,
		&depthResourceDesc,
		D3D12_RESOURCE_STATE_DEPTH_WRITE,
		&depthClearValue,
		IID_PPV_ARGS(&depthBuff)
	);

	D3D12_DESCRIPTOR_HEAP_DESC dsvHeapDesc{};
	dsvHeapDesc.NumDescriptors = 1;
	dsvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_DSV;
	result = device->CreateDescriptorHeap(&dsvHeapDesc, IID_PPV_ARGS(&dsvHeap));
	D3D12_DEPTH_STENCIL_VIEW_DESC dsvDesc{};
	dsvDesc.Format = DXGI_FORMAT_D32_FLOAT;
	dsvDesc.ViewDimension = D3D12_DSV_DIMENSION_TEXTURE2D;
	device->CreateDepthStencilView(
		depthBuff.Get(),
		&dsvDesc,
		dsvHeap->GetCPUDescriptorHandleForHeapStart()
	);
}

void DirectXCommon::InitializeCommand()
{
	HRESULT result = S_FALSE;

	//ã‚³ãƒžãƒ³ãƒ‰ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ãƒ¼ã‚’ç”Ÿæˆ
	result = device->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(&commandAllocator));
	assert(SUCCEEDED(result));

	//ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆã‚’ç”Ÿæˆ
	result = device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, commandAllocator.Get(), nullptr, IID_PPV_ARGS(&commandList));
	assert(SUCCEEDED(result));

	//ã‚³ãƒžãƒ³ãƒ‰ã‚­ãƒ¥ãƒ¼ã‚’ç”Ÿæˆ
	D3D12_COMMAND_QUEUE_DESC commandQueueDesc{};
	result = device->CreateCommandQueue(&commandQueueDesc, IID_PPV_ARGS(commandQueue.GetAddressOf()));
	assert(SUCCEEDED(result));


}


void DirectXCommon::InitializeFence()
{
	HRESULT result = S_FALSE;

	result = device->CreateFence(fenceVal, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&fence));
	assert(SUCCEEDED(result));
}

============================================================
File Path: SourceCode/Engine/Core/DirectXCommon.h
============================================================
#pragma once
#include "DxWindow.h"
#include<d3d12.h>
#include<dxgi1_6.h>
#include<wrl.h>
#include<vector>
#include"DescriptorHeap.h"
#include<memory>

using namespace Microsoft::WRL;
using namespace std;

namespace SKNEngine
{
	class DirectXCommon
	{
	public:

		DirectXCommon();

		void Initialize(DxWindow* win, int32_t BackBufferWidth = DxWindow::window_width, int32_t BackBufferHeight = DxWindow::window_height);

		void PreDraw();

		void PostDraw();

		/// <returns>ãƒ‡ãƒã‚¤ã‚¹</returns>
		ID3D12Device* GetDevice() const { return device.Get(); }

		/// <summary>
		/// æç”»ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®å–å¾—
		/// </summary>
		/// <returns>æç”»ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆ</returns>
		ID3D12GraphicsCommandList* GetCommandList() const { return commandList.Get(); }

		DescriptorHeap* GetDescriptorHeap() { return descHeap.get(); }

		size_t GetBackBufferCount()const { return backBuffers.size(); }

		//DescriptorHeap* GetDescriptorHeap()const { return descHeap.get(); }

	private:

		DxWindow* dxWin;

		ComPtr<ID3D12Device> device;
		ComPtr<IDXGIFactory7> dxgiFactory;
		ComPtr<IDXGISwapChain4> swapChain;
		ComPtr<ID3D12CommandAllocator> commandAllocator;
		ComPtr<ID3D12GraphicsCommandList> commandList;
		ComPtr<ID3D12CommandQueue> commandQueue;
		ComPtr<ID3D12DescriptorHeap> rtvHeap;
		ComPtr<ID3D12Resource> depthBuff;
		ComPtr<ID3D12DescriptorHeap> dsvHeap;


		vector<ComPtr<ID3D12Resource>> backBuffers;

		ComPtr<ID3D12Fence> fence;

		ComPtr<ID3D12Resource> depthBuffer;

		unique_ptr<DescriptorHeap> descHeap;

		UINT backBufferWidth = 0;
		UINT backBufferHeight = 0;

		UINT64 fenceVal = 0;

	private:

		void InitializeDXGIdevice();

		void InitializeSwapChain();

		void InitializeCommand();

		void InitializeRenserTargetView();

		void InitializeDepthBuffer();

		void InitializeFence();

	};
}



============================================================
File Path: SourceCode/Engine/Core/DxWindow.cpp
============================================================
#include "DxWindow.h"
#include <string>
#include"imgui_impl_win32.h"

extern IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandler(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);


DxWindow* DxWindow::GetInstance()
{
	static DxWindow instance;
	return &instance;
}

LRESULT DxWindow::WindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
{

	if (ImGui_ImplWin32_WndProcHandler(hwnd, msg, wparam, lparam))
	{
		return true;
	}
	switch (msg)
	{
	case WM_DESTROY:
		//OSã«å¯¾ã—ã¦ã€ã‚¢ãƒ—ãƒªã®çµ‚äº†ã‚’ä¼ãˆã‚‹
		PostQuitMessage(0);
		return 0;
	}

	return DefWindowProc(hwnd, msg, wparam, lparam);
}

void DxWindow::CreateGameWindow(const char* title, UINT windowStyle, int32_t clientWidth, int32_t clientHeight)
{
	winStyle_ = windowStyle;
	winClass.cbSize = sizeof(WNDCLASSEX);
	winClass.lpfnWndProc = (WNDPROC)WindowProc;	//ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒ—ãƒ­ã‚·ãƒ¼ã‚¸ãƒ£ã‚’è¨­å®š
	winClass.lpszClassName = L"Mecha Core";		//ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¯ãƒ©ã‚¹å
	winClass.hInstance = GetModuleHandle(nullptr);	//ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒãƒ³ãƒ‰ãƒ«
	winClass.hCursor = LoadCursor(NULL, IDC_ARROW);//ã‚«ãƒ¼ã‚½ãƒ«æŒ‡å®š
	//ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¯ãƒ©ã‚¹ã‚’OSã«ç™»éŒ²ã™ã‚‹
	RegisterClassEx(&winClass);

	// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚µã‚¤ã‚º{ Xåº§æ¨™ Yåº§æ¨™ æ¨ªå¹… ç¸¦å¹… }
	RECT wrc = { 0, 0, clientWidth, clientHeight };
	AdjustWindowRect(&wrc, winStyle_, false); // è‡ªå‹•ã§ã‚µã‚¤ã‚ºè£œæ­£

	hwnd = CreateWindow
	(
		winClass.lpszClassName,		//ã‚¯ãƒ©ã‚¹å
		L"Mecha Core",			//ã‚¿ã‚¤ãƒˆãƒ«ãƒãƒ¼ã®æ–‡å­—
		winStyle_,	//æ¨™æº–çš„ãªã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¹ã‚¿ã‚¤ãƒ«
		CW_USEDEFAULT,			//è¡¨ç¤ºXåº§æ¨™(OSã«ä»»ã›ã‚‹)
		CW_USEDEFAULT,			//è¡¨ç¤ºYåº§æ¨™(OSã«ä»»ã›ã‚‹)
		wrc.right - wrc.left,	//ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦æ¨ªå¹…
		wrc.bottom - wrc.top,	//ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ç¸¦å¹…
		nullptr,				//è¦ªã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒãƒ³ãƒ‰ãƒ«
		nullptr,				//ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒãƒ³ãƒ‰ãƒ«
		winClass.hInstance,			//å‘¼ã³å‡ºã—ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒãƒ³ãƒ‰ãƒ«
		nullptr					//ã‚ªãƒ—ã‚·ãƒ§ãƒ³
	);

	//ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’è¡¨ç¤ºçŠ¶æ…‹ã™ã‚‹
	ShowWindow(hwnd, SW_SHOW);

}

void DxWindow::TerminateGameWindow()
{
	UnregisterClass(winClass.lpszClassName, winClass.hInstance);
}

bool DxWindow::ProcessMessage()
{
	MSG msg{};
	//ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚ã‚‹ï¼Ÿ
	if (PeekMessage(&msg, nullptr, 0, 0, PM_REMOVE))
	{
		TranslateMessage(&msg);	//ã‚­ãƒ¼å…¥åŠ›ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å‡¦ç†
		DispatchMessage(&msg);	//ãƒ—ãƒ­ã‚·ãƒ¼ã‚¸ãƒ£ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ã‚‹
	}

	//Ã—ãƒœã‚¿ãƒ³ã§çµ‚äº†ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒæ¥ãŸã‚‰ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹
	if (msg.message == WM_QUIT)
	{
		return true;
	}

	return false;
}


============================================================
File Path: SourceCode/Engine/Core/DxWindow.h
============================================================
#pragma once
#include<Windows.h>
#include <cstdint>

//const int window_width = 1280;	//æ¨ªå¹…
//const int window_height = 720;	//ç¸¦å¹…


class DxWindow
{
public:

	static const int window_width = 1280;	//æ¨ªå¹…
	static const int window_height = 720;	//ç¸¦å¹…

	//static const wchar_t windowClassName[];

	//DXWindow();

	static DxWindow* GetInstance();

	static LRESULT WindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam);



public:

	void CreateGameWindow(const char* title = "Mecha Core", UINT windowStyle = WS_OVERLAPPEDWINDOW, int32_t clientWidth = window_width, int32_t clientHeight = window_height);

	void TerminateGameWindow();

	bool ProcessMessage();

	HWND GetHwnd()const { return hwnd; }
	HINSTANCE GetHInstance() const { return winClass.hInstance; }

private:

	HWND hwnd = nullptr;
	WNDCLASSEX winClass{};
	UINT winStyle_;
	RECT winRect;


	//ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚µã‚¤ã‚º{ã€€Xåº§æ¨™ã€€Yåº§æ¨™ã€€æ¨ªå¹…ã€€ç¸¦å¹…ã€€}


	//RECT wrc = { 0,0,window_width, window_height };




};



============================================================
File Path: SourceCode/Engine/Core/FPS.cpp
============================================================
#include "FPS.h"
#include<thread>

void FPS::Initialize()
{
	count = std::chrono::steady_clock::now();
}

void FPS::Update(float Fps, bool flag)
{
	
	std::chrono::microseconds minTime(uint64_t(1000000.0f / Fps));
	
	std::chrono::microseconds minCheckTime(uint64_t(1000000.0f / (Fps + 5.0f)));

	std::chrono::steady_clock::time_point now = std::chrono::steady_clock::now();
	
	std::chrono::microseconds elapsed = std::chrono::duration_cast<std::chrono::microseconds>(now - count);
	
	if (flag == false)
	{
		if (elapsed < minTime)
		{
			while (std::chrono::steady_clock::now() - count < minTime)
			{
				std::this_thread::sleep_for(std::chrono::microseconds(1));
			}
		}
	}
	else
	{
		if (elapsed < minCheckTime)
		{
			while (std::chrono::steady_clock::now() - count < minCheckTime)
			{
				std::this_thread::sleep_for(std::chrono::microseconds(1));
			}
		}
	}
	count = std::chrono::steady_clock::now();



}


============================================================
File Path: SourceCode/Engine/Core/FPS.h
============================================================
#pragma once
#include <chrono>
class FPS
{
private:

	std::chrono::steady_clock::time_point count;

public:

	void Initialize();

	
	void Update(float Fps = 60.0f, bool flag = true);



};



============================================================
File Path: SourceCode/Engine/Core/Input.cpp
============================================================
#include "Input.h"
#include"DirectXCommon.h"
#include<cassert>
#include <cmath>



Input* Input::GetInstance()
{
	static Input instance;
	return &instance;
}

void Input::Init(HINSTANCE hinstance, HWND hwnd)
{
	GetInstance()->Initialize(hinstance, hwnd);
}

void Input::Initialize(HINSTANCE hinstance, HWND hwnd)
{
#pragma region	ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å‘¨ã‚Š
	HRESULT result;

	//DirectInputã®åˆæœŸåŒ–
	result = DirectInput8Create(hinstance, DIRECTINPUT_VERSION, IID_IDirectInput8, (void**)&directInput, nullptr);
	assert(SUCCEEDED(result));

	//ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ãƒ‡ãƒã‚¤ã‚¹ã®ç”Ÿæˆ
	result = directInput->CreateDevice(GUID_SysKeyboard, &keyboard, NULL);
	assert(SUCCEEDED(result));

	//å…¥åŠ›ãƒ‡ãƒ¼ã‚¿å½¢å¼ã®ã‚»ãƒƒãƒˆ
	result = keyboard->SetDataFormat(&c_dfDIKeyboard);	//æ¨™æº–å½¢å¼
	assert(SUCCEEDED(result));

	//æŽ’ä»–åˆ¶å¾¡ãƒ¬ãƒ™ãƒ«ã®ã‚»ãƒƒãƒˆ
	result = keyboard->SetCooperativeLevel(hwnd, DISCL_FOREGROUND | DISCL_NONEXCLUSIVE | DISCL_NOWINKEY);
	assert(SUCCEEDED(result));

#pragma endregion	ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å‘¨ã‚ŠåˆæœŸåŒ–
	ZeroMemory(&xInputState, sizeof(XINPUT_STATE));
	DWORD dresult;
	dresult = XInputGetState(0, &xInputState);

	if (result == ERROR_SUCCESS)
	{
		isConnectPad = true;
	}
	else
	{
		isConnectPad = false;
	}

}

void Input::InputUpdate()
{
	Input* instance = GetInstance();

	//ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æƒ…å ±ã®å–å¾—é–‹å§‹
	instance->keyboard->Acquire();

	memcpy(instance->oldkey, instance->key, sizeof(key));

	instance->keyboard->GetDeviceState(sizeof(key), instance->key);

	instance->OldxInputState = instance->xInputState;

	DWORD dresult = XInputGetState(0, &instance->xInputState);

	if (dresult == ERROR_SUCCESS) 
	{

		instance->isConnectPad = true;
	}
	else 
	{
		instance->isConnectPad = false;
	}

	if ((instance->xInputState.Gamepad.sThumbLX <  XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE &&
		instance->xInputState.Gamepad.sThumbLX > -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE) &&
		(instance->xInputState.Gamepad.sThumbLY <  XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE &&
			instance->xInputState.Gamepad.sThumbLY > -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE))
	{
		instance->xInputState.Gamepad.sThumbLX = 0;
		instance->xInputState.Gamepad.sThumbLY = 0;
	}

	if ((instance->xInputState.Gamepad.sThumbRX <  XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE &&
		instance->xInputState.Gamepad.sThumbRX > -XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE) &&
		(instance->xInputState.Gamepad.sThumbRY <  XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE &&
			instance->xInputState.Gamepad.sThumbRY > -XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE))
	{
		instance->xInputState.Gamepad.sThumbRX = 0;
		instance->xInputState.Gamepad.sThumbRY = 0;
	}

}

bool Input::GetKey(BYTE _key)
{
	if (GetInstance()->key[_key])
	{
		return true;
	}

	return false;
}

bool Input::GetPressKey(BYTE _key)
{
	if (GetInstance()->key[_key] && !GetInstance()->oldkey[_key])
	{
		return true;
	}
	return false;
}

bool Input::GetReleaseKey(BYTE _key)
{
	if (GetInstance()->key[_key] && !GetInstance()->oldkey[_key])
	{
		return true;
	}
	return false;
}

bool Input::GetPadConnect()
{
	return GetInstance()->isConnectPad;
}

bool Input::GetPadButton(UINT button)
{
	return GetInstance()->xInputState.Gamepad.wButtons == button;
}

bool Input::GetPadButtonUp(UINT button)
{
	return GetInstance()->xInputState.Gamepad.wButtons != button && GetInstance()->OldxInputState.Gamepad.wButtons == button;
}

bool Input::GetPadButtonDown(UINT button)
{
	return GetInstance()->xInputState.Gamepad.wButtons == button && GetInstance()->OldxInputState.Gamepad.wButtons != button;
}

Vector2 Input::GetPadLStick()
{
	SHORT x = GetInstance()->xInputState.Gamepad.sThumbLX;
	SHORT y = GetInstance()->xInputState.Gamepad.sThumbLY;

	return Vector2(static_cast<float>(x) / 32767.0f, static_cast<float>(y) / 32767.0f);
}

Vector2 Input::GetPadRStick()
{
	SHORT x = GetInstance()->xInputState.Gamepad.sThumbRX;
	SHORT y = GetInstance()->xInputState.Gamepad.sThumbRY;

	return Vector2(static_cast<float>(x) / 32767.0f, static_cast<float>(y) / 32767.0f);
}

bool Input::GetLTriggerDown()
{
	if (GetInstance()->OldxInputState.Gamepad.bLeftTrigger < 128 && GetInstance()->xInputState.Gamepad.bLeftTrigger >= 128)
	{
		return true;
	}
	return false;
}

bool Input::GetLTrigger()
{
	if (GetInstance()->OldxInputState.Gamepad.bLeftTrigger > 128)
	{
		return true;
	}
	return false;
}

bool Input::GetRTriggerDown()
{
	if (GetInstance()->OldxInputState.Gamepad.bRightTrigger < 128 && GetInstance()->xInputState.Gamepad.bRightTrigger >= 128)
	{
		return true;
	}
	return false;
}

bool Input::GetRTrigger()
{
	if (GetInstance()->OldxInputState.Gamepad.bRightTrigger > 128)
	{
		return true;
	}
	return false;
}

Vector2 Input::GetLStick(bool useWASD, bool useArrow)
{
	Vector2 pad;
	pad.x = static_cast<float>(GetInstance()->xInputState.Gamepad.sThumbLX) / 32767.0f;
	pad.y = static_cast<float>(GetInstance()->xInputState.Gamepad.sThumbLY) / 32767.0f;

	Vector2 wasd;
	if (useWASD) {
		wasd.x = static_cast<float>(GetInstance()->key[DIK_D] - GetInstance()->key[DIK_A]);
		wasd.y = static_cast<float>(GetInstance()->key[DIK_W] - GetInstance()->key[DIK_S]);
	}

	Vector2 arrow;
	if (useArrow) {
		arrow.x = static_cast<float>(GetInstance()->key[DIK_RIGHT] - GetInstance()->key[DIK_LEFT]);
		arrow.y = static_cast<float>(GetInstance()->key[DIK_UP]	- GetInstance()->key[DIK_DOWN]);
	}

	Vector2 result = pad + wasd + arrow;
	result.normalize();
	return result;
}

Vector2 Input::GetRStick(bool useWASD, bool useArrow)
{
	Vector2 pad;
	pad.x = static_cast<float>(GetInstance()->xInputState.Gamepad.sThumbRX) / 32767.0f;
	pad.y = static_cast<float>(GetInstance()->xInputState.Gamepad.sThumbRY) / 32767.0f;

	Vector2 wasd;
	if (useWASD) {
		wasd.x = static_cast<float>(GetInstance()->key[DIK_D] - GetInstance()->key[DIK_A]);
		wasd.y = static_cast<float>(GetInstance()->key[DIK_W] - GetInstance()->key[DIK_S]);
	}

	Vector2 arrow;
	if (useArrow) {
		arrow.x = static_cast<float>(GetInstance()->key[DIK_RIGHT] - GetInstance()->key[DIK_LEFT]);
		arrow.y = static_cast<float>(GetInstance()->key[DIK_UP] - GetInstance()->key[DIK_DOWN]);
	}

	Vector2 result = pad + wasd + arrow;
	result.normalize();
	return result;
}

Vector2 Input::GetMousePostion()
{
	return Vector2();
}



============================================================
File Path: SourceCode/Engine/Core/Input.h
============================================================
#pragma once

#define DIRECTINPUT_VERSION	0x0800
#include<dinput.h>
#include<Xinput.h>

#include<wrl.h>

#pragma comment(lib,"dinput8.lib")
#pragma comment(lib,"dxguid.lib")
#pragma comment (lib, "xinput.lib")

#include"myMath.h"

class Input
{
private:
	template <class T> using ComPtr = Microsoft::WRL::ComPtr<T>;


public:

	static Input* GetInstance();

	static void Init(HINSTANCE hinstance, HWND hwnd);

	static void InputUpdate();

	static bool GetKey(BYTE _key);

	static bool GetPressKey(BYTE _key);

	static bool GetReleaseKey(BYTE _key);

	//ãƒ‘ãƒƒãƒ‰ã«æŽ¥ç¶šã•ã‚Œã¦ã‚‹ã‹
	static bool GetPadConnect();

	//ãƒ‘ãƒƒãƒ‰ã®ãƒœã‚¿ãƒ³ãŒæŠ¼ã•ã‚Œã¦ã„ã‚‹ã‹
	static bool GetPadButton(UINT button);

	//ãƒ‘ãƒƒãƒ‰ã®ãƒœã‚¿ãƒ³ãŒé›¢ã‚ŒãŸçž¬é–“ã‹
	static bool GetPadButtonUp(UINT button);

	//ãƒ‘ãƒƒãƒ‰ã®ãƒœã‚¿ãƒ³ãŒæŠ¼ã•ã‚ŒãŸçž¬é–“ã‹
	static bool GetPadButtonDown(UINT button);

	//ãƒ‘ãƒƒãƒ‰ã®å·¦ã‚¹ãƒ†ã‚£ãƒƒã‚¯
	static Vector2 GetPadLStick();

	//ãƒ‘ãƒƒãƒ‰ã®å³ã‚¹ãƒ†ã‚£ãƒƒã‚¯
	static Vector2 GetPadRStick();

	//å·¦ãƒˆãƒªã‚¬ãƒ¼ã‚’æŠ¼ã—è¾¼ã‚“ã çž¬é–“ã‹
	static bool GetLTriggerDown();

	//å·¦ãƒˆãƒªã‚¬ãƒ¼ã‚’æŠ¼ã•ã‚Œã¦ã„ã‚‹ã‹
	static bool GetLTrigger();


	//å³ãƒˆãƒªã‚¬ãƒ¼ã‚’æŠ¼ã—è¾¼ã‚“ã çž¬é–“ã‹
	static bool GetRTriggerDown();


	//å³ãƒˆãƒªã‚¬ãƒ¼ã‚’æŠ¼ã•ã‚Œã¦ã„ã‚‹ã‹
	static bool GetRTrigger();

	/// <summary>
	/// å·¦ã‚¹ãƒ†ã‚£ãƒƒã‚¯å…¥åŠ›ã‚’å¾—ã‚‹
	/// </summary>
	/// <param name="useWASD">WASDã‚­ãƒ¼ã‚‚ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã«è¦‹ç«‹ã¦ã¦å‡¦ç†ã™ã‚‹</param>
	/// <param name="useArrow">çŸ¢å°ã‚­ãƒ¼ã‚‚ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã«è¦‹ç«‹ã¦ã¦å‡¦ç†ã™ã‚‹</param>
	/// <returns>å…¥åŠ›é‡</returns>
	static Vector2 GetLStick(bool useWASD, bool useArrow);

	/// <summary>
	/// å³ã‚¹ãƒ†ã‚£ãƒƒã‚¯å…¥åŠ›ã‚’å¾—ã‚‹
	/// </summary>
	/// <param name="useWASD">WASDã‚­ãƒ¼ã‚‚ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã«è¦‹ç«‹ã¦ã¦å‡¦ç†ã™ã‚‹</param>
	/// <param name="useArrow">çŸ¢å°ã‚­ãƒ¼ã‚‚ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã«è¦‹ç«‹ã¦ã¦å‡¦ç†ã™ã‚‹</param>
	/// <returns>å…¥åŠ›é‡</returns>
	static Vector2 GetRStick(bool useWASD, bool useArrow);

	static Vector2 GetMousePostion();



private:

	void Initialize(HINSTANCE hinstance, HWND hwnd);

	ComPtr<IDirectInput8>directInput;
	ComPtr<IDirectInputDevice8>keyboard;

	XINPUT_STATE xInputState;
	XINPUT_STATE OldxInputState;

	

	bool isConnectPad = false;

	BYTE key[256] = {};
	BYTE oldkey[256] = {};

};



============================================================
File Path: SourceCode/Engine/Core/Pipeline.cpp
============================================================
#include "Pipeline.h"
#include<string>
#include <d3dcompiler.h>
#include <d3dx12.h>

#pragma comment(lib, "d3dcompiler.lib")
#include<cassert>
PipelineSet Pipeline::CreateSpritePipline(ID3D12Device* device)
{
	HRESULT result = S_FALSE;
	ComPtr<ID3DBlob> vsBlob; // é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	ComPtr<ID3DBlob> psBlob;	// ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	ComPtr<ID3DBlob> errorBlob; // ã‚¨ãƒ©ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ


	result = D3DCompileFromFile(
		L"Resources/Shader/BasicVS.hlsl",
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE,
		"main", "vs_5_0",
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION,
		0,
		&vsBlob, &errorBlob
	);

	// ã‚¨ãƒ©ãƒ¼ãªã‚‰
	if (FAILED(result)) {
		// errorBlobã‹ã‚‰ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’stringåž‹ã«ã‚³ãƒ”ãƒ¼
		std::string error;
		error.resize(errorBlob->GetBufferSize());
		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			error.begin());
		error += "\n";
		// ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’å‡ºåŠ›ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«è¡¨ç¤º
		OutputDebugStringA(error.c_str());
		assert(0);
	}

	result = D3DCompileFromFile(
		L"Resources/Shader/BasicPS.hlsl", // ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«å
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰å¯èƒ½ã«ã™ã‚‹
		"main", "ps_5_0", // ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆåã€ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ¢ãƒ‡ãƒ«æŒ‡å®š
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // ãƒ‡ãƒãƒƒã‚°ç”¨è¨­å®š
		0,
		&psBlob, &errorBlob);
	// ã‚¨ãƒ©ãƒ¼ãªã‚‰
	if (FAILED(result)) {
		// errorBlobã‹ã‚‰ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’stringåž‹ã«ã‚³ãƒ”ãƒ¼
		std::string error;
		error.resize(errorBlob->GetBufferSize());
		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			error.begin());
		error += "\n";
		// ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’å‡ºåŠ›ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«è¡¨ç¤º
		OutputDebugStringA(error.c_str());
		assert(0);
	}


	D3D12_INPUT_ELEMENT_DESC inputLayout[] = {
		{
			"POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},
		{
			"TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},
	};

	D3D12_GRAPHICS_PIPELINE_STATE_DESC pipelineDesc{};

	pipelineDesc.VS.pShaderBytecode = vsBlob->GetBufferPointer();
	pipelineDesc.VS.BytecodeLength = vsBlob->GetBufferSize();
	pipelineDesc.PS.pShaderBytecode = psBlob->GetBufferPointer();
	pipelineDesc.PS.BytecodeLength = psBlob->GetBufferSize();

	pipelineDesc.SampleMask = D3D12_DEFAULT_SAMPLE_MASK;

	// ãƒ©ã‚¹ã‚¿ãƒ©ã‚¤ã‚¶ã®è¨­å®š
	pipelineDesc.RasterizerState.CullMode = D3D12_CULL_MODE_NONE; // ã‚«ãƒªãƒ³ã‚°ã—ãªã„
	pipelineDesc.RasterizerState.FillMode = D3D12_FILL_MODE_SOLID; // ãƒãƒªã‚´ãƒ³å†…å¡—ã‚Šã¤ã¶ã—
	pipelineDesc.RasterizerState.DepthClipEnable = true; // æ·±åº¦ã‚¯ãƒªãƒƒãƒ”ãƒ³ã‚°ã‚’æœ‰åŠ¹ã«

	// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ãƒ–ãƒ¬ãƒ³ãƒ‰è¨­å®š
	D3D12_RENDER_TARGET_BLEND_DESC& blenddesc = pipelineDesc.BlendState.RenderTarget[0];
	blenddesc.RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;	// RBGAå…¨ã¦ã®ãƒãƒ£ãƒ³ãƒãƒ«ã‚’æç”»
	blenddesc.BlendEnable = true;
	blenddesc.BlendOp = D3D12_BLEND_OP_ADD;
	blenddesc.SrcBlend = D3D12_BLEND_SRC_ALPHA;
	blenddesc.DestBlend = D3D12_BLEND_INV_SRC_ALPHA;

	blenddesc.BlendOpAlpha = D3D12_BLEND_OP_ADD;
	blenddesc.SrcBlendAlpha = D3D12_BLEND_ONE;
	blenddesc.DestBlendAlpha = D3D12_BLEND_ZERO;

	// ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚¹ãƒ†ãƒ¼ãƒˆ
	//pipelineDesc.BlendState.RenderTarget[0].RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL; 

	// é ‚ç‚¹ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®è¨­å®š
	pipelineDesc.InputLayout.pInputElementDescs = inputLayout;
	pipelineDesc.InputLayout.NumElements = _countof(inputLayout);

	// å›³å½¢ã®å½¢çŠ¶è¨­å®š
	pipelineDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;

	// ãã®ä»–ã®è¨­å®š
	pipelineDesc.NumRenderTargets = 1; // æç”»å¯¾è±¡ã¯1ã¤
	pipelineDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB; // 0~255æŒ‡å®šã®RGBA
	pipelineDesc.SampleDesc.Count = 1; // 1ãƒ”ã‚¯ã‚»ãƒ«ã«ã¤ã1å›žã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°

	D3D12_DESCRIPTOR_RANGE descriptorRange{};
	descriptorRange.NumDescriptors = 1;		//ä¸€åº¦ã®æç”»ã«ä½¿ã†ãƒ†ã‚¯ã‚¹ãƒãƒ£ãŒ1æžšãªã®ã§1
	descriptorRange.RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
	descriptorRange.BaseShaderRegister = 0;	//ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ¬ã‚¸ã‚¹ã‚¿0ç•ª
	descriptorRange.OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND;



	D3D12_ROOT_PARAMETER rootParams[2] = {};

	rootParams[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
	rootParams[0].Descriptor.ShaderRegister = 0;
	rootParams[0].Descriptor.RegisterSpace = 0;
	rootParams[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;

	//ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ¬ã‚¸ã‚¹ã‚¿0ç•ª
	rootParams[1].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;	//ç¨®é¡ž
	rootParams[1].DescriptorTable.pDescriptorRanges = &descriptorRange;			//ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¬ãƒ³ã‚¸
	rootParams[1].DescriptorTable.NumDescriptorRanges = 1;						//ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¬ãƒ³ã‚¸æ•°
	rootParams[1].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;				//å…¨ã¦ã®ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‹ã‚‰è¦‹ãˆã‚‹



	D3D12_STATIC_SAMPLER_DESC samplerDesc{};
	samplerDesc.AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP;					//æ¨ªç¹°ã‚Šè¿”ã—(ã‚¿ã‚¤ãƒªãƒ³ã‚°)
	samplerDesc.AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP;					//ç¸¦ç¹°ã‚Šè¿”ã—(ã‚¿ã‚¤ãƒªãƒ³ã‚°)
	samplerDesc.AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;					//å¥¥è¡Œç¹°ã‚Šè¿”ã—(ã‚¿ã‚¤ãƒªãƒ³ã‚°)
	samplerDesc.BorderColor = D3D12_STATIC_BORDER_COLOR_TRANSPARENT_BLACK;	//ãƒœãƒ¼ãƒ€ãƒ¼ã®æ™‚ã¯é»’
	samplerDesc.Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;					//å…¨ã¦ãƒªãƒ‹ã‚¢è£œé–“
	samplerDesc.MaxLOD = D3D12_FLOAT32_MAX;									//ãƒŸãƒƒãƒ—ãƒžãƒƒãƒ—æœ€å¤§å€¤
	samplerDesc.MinLOD = 0.0f;
	samplerDesc.ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;
	samplerDesc.ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;			//ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‹ã‚‰ã®ã¿ä½¿ç”¨å¯èƒ½

	PipelineSet pipelineset;

	D3D12_ROOT_SIGNATURE_DESC rootSignatureDesc{};
	rootSignatureDesc.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
	rootSignatureDesc.pParameters = rootParams;
	rootSignatureDesc.NumParameters = _countof(rootParams);
	rootSignatureDesc.pStaticSamplers = &samplerDesc;
	rootSignatureDesc.NumStaticSamplers = 1;

	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º
	ComPtr<ID3DBlob> rootSigBlob;
	result = D3D12SerializeRootSignature(&rootSignatureDesc, D3D_ROOT_SIGNATURE_VERSION_1_0,
		&rootSigBlob, &errorBlob);
	assert(SUCCEEDED(result));
	result = device->CreateRootSignature(0, rootSigBlob->GetBufferPointer(), rootSigBlob->GetBufferSize(),
		IID_PPV_ARGS(&pipelineset.rootSignature));
	assert(SUCCEEDED(result));
	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã«ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã‚’ã‚»ãƒƒãƒˆ
	pipelineDesc.pRootSignature = pipelineset.rootSignature.Get();

	// ãƒ‘ã‚¤ãƒ—ãƒ©ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã®ç”Ÿæˆ
	result = device->CreateGraphicsPipelineState(&pipelineDesc, IID_PPV_ARGS(&pipelineset.pipelineState));
	assert(SUCCEEDED(result));

	return pipelineset;
}

PipelineSet Pipeline::CreateModelPipline(ID3D12Device* device)
{
	HRESULT result = S_FALSE;
	ComPtr<ID3DBlob> vsBlob; // é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	ComPtr<ID3DBlob> psBlob;	// ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	ComPtr<ID3DBlob> errorBlob; // ã‚¨ãƒ©ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ


	result = D3DCompileFromFile(
		L"Resources/Shader/ObjVs.hlsl",
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE,
		"main", "vs_5_0",
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION,
		0,
		&vsBlob, &errorBlob
	);

	// ã‚¨ãƒ©ãƒ¼ãªã‚‰
	if (FAILED(result)) {
		// errorBlobã‹ã‚‰ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’stringåž‹ã«ã‚³ãƒ”ãƒ¼
		std::string error;
		error.resize(errorBlob->GetBufferSize());
		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			error.begin());
		error += "\n";
		// ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’å‡ºåŠ›ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«è¡¨ç¤º
		OutputDebugStringA(error.c_str());
		assert(0);
	}

	result = D3DCompileFromFile(
		L"Resources/Shader/ObjPs.hlsl", // ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«å
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰å¯èƒ½ã«ã™ã‚‹
		"main", "ps_5_0", // ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆåã€ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ¢ãƒ‡ãƒ«æŒ‡å®š
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // ãƒ‡ãƒãƒƒã‚°ç”¨è¨­å®š
		0,
		&psBlob, &errorBlob);
	// ã‚¨ãƒ©ãƒ¼ãªã‚‰
	if (FAILED(result)) {
		// errorBlobã‹ã‚‰ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’stringåž‹ã«ã‚³ãƒ”ãƒ¼
		std::string error;
		error.resize(errorBlob->GetBufferSize());
		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			error.begin());
		error += "\n";
		// ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’å‡ºåŠ›ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«è¡¨ç¤º
		OutputDebugStringA(error.c_str());
		assert(0);
	}

	D3D12_INPUT_ELEMENT_DESC inputLayout[] = {
		{
			"POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},
		{
			"NORMAL",0,DXGI_FORMAT_R32G32B32_FLOAT,0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA,0
		},
		{
			"TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},
	};

	D3D12_GRAPHICS_PIPELINE_STATE_DESC pipelineDesc{};

	pipelineDesc.VS.pShaderBytecode = vsBlob->GetBufferPointer();
	pipelineDesc.VS.BytecodeLength = vsBlob->GetBufferSize();
	pipelineDesc.PS.pShaderBytecode = psBlob->GetBufferPointer();
	pipelineDesc.PS.BytecodeLength = psBlob->GetBufferSize();

	pipelineDesc.SampleMask = D3D12_DEFAULT_SAMPLE_MASK;

	// ãƒ©ã‚¹ã‚¿ãƒ©ã‚¤ã‚¶ã®è¨­å®š
	pipelineDesc.RasterizerState.CullMode = D3D12_CULL_MODE_BACK; // ã‚«ãƒªãƒ³ã‚°ã—ãªã„
	pipelineDesc.RasterizerState.FillMode = D3D12_FILL_MODE_SOLID; // ãƒãƒªã‚´ãƒ³å†…å¡—ã‚Šã¤ã¶ã—
	pipelineDesc.RasterizerState.DepthClipEnable = true; // æ·±åº¦ã‚¯ãƒªãƒƒãƒ”ãƒ³ã‚°ã‚’æœ‰åŠ¹ã«

	pipelineDesc.DepthStencilState.DepthEnable = true;
	pipelineDesc.DepthStencilState.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ALL;
	pipelineDesc.DepthStencilState.DepthFunc = D3D12_COMPARISON_FUNC_LESS;
	pipelineDesc.DSVFormat = DXGI_FORMAT_D32_FLOAT;


	// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ãƒ–ãƒ¬ãƒ³ãƒ‰è¨­å®š
	D3D12_RENDER_TARGET_BLEND_DESC& blenddesc = pipelineDesc.BlendState.RenderTarget[0];
	blenddesc.RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;	// RBGAå…¨ã¦ã®ãƒãƒ£ãƒ³ãƒãƒ«ã‚’æç”»
	blenddesc.BlendEnable = true;
	blenddesc.BlendOp = D3D12_BLEND_OP_ADD;
	blenddesc.SrcBlend = D3D12_BLEND_SRC_ALPHA;
	blenddesc.DestBlend = D3D12_BLEND_INV_SRC_ALPHA;

	blenddesc.BlendOpAlpha = D3D12_BLEND_OP_ADD;
	blenddesc.SrcBlendAlpha = D3D12_BLEND_ONE;
	blenddesc.DestBlendAlpha = D3D12_BLEND_ZERO;

	// ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚¹ãƒ†ãƒ¼ãƒˆ
	//pipelineDesc.BlendState.RenderTarget[0].RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL; 

	// é ‚ç‚¹ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®è¨­å®š
	pipelineDesc.InputLayout.pInputElementDescs = inputLayout;
	pipelineDesc.InputLayout.NumElements = _countof(inputLayout);

	// å›³å½¢ã®å½¢çŠ¶è¨­å®š
	pipelineDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;

	// ãã®ä»–ã®è¨­å®š
	pipelineDesc.NumRenderTargets = 1; // æç”»å¯¾è±¡ã¯1ã¤
	pipelineDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB; // 0~255æŒ‡å®šã®RGBA
	pipelineDesc.SampleDesc.Count = 1; // 1ãƒ”ã‚¯ã‚»ãƒ«ã«ã¤ã1å›žã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°

	D3D12_DESCRIPTOR_RANGE descriptorRange{};
	descriptorRange.NumDescriptors = 1;		//ä¸€åº¦ã®æç”»ã«ä½¿ã†ãƒ†ã‚¯ã‚¹ãƒãƒ£ãŒ1æžšãªã®ã§1
	descriptorRange.RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
	descriptorRange.BaseShaderRegister = 0;	//ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ¬ã‚¸ã‚¹ã‚¿0ç•ª
	descriptorRange.OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND;



	D3D12_ROOT_PARAMETER rootParams[4] = {};

	rootParams[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
	rootParams[0].Descriptor.ShaderRegister = 0;
	rootParams[0].Descriptor.RegisterSpace = 0;
	rootParams[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;

	//å®šæ•°ãƒãƒƒãƒ•ã‚¡1ç•ª
	rootParams[1].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;		//ç¨®é¡ž
	rootParams[1].Descriptor.ShaderRegister = 1;						//å®šæ•°ãƒãƒƒãƒ•ã‚¡ç•ªå·
	rootParams[1].Descriptor.RegisterSpace = 0;							//ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
	rootParams[1].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;		//å…¨ã¦ã®ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‹ã‚‰è¦‹ãˆã‚‹

	//ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ¬ã‚¸ã‚¹ã‚¿0ç•ª
	rootParams[2].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;	//ç¨®é¡ž
	rootParams[2].DescriptorTable.pDescriptorRanges = &descriptorRange;			//ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¬ãƒ³ã‚¸
	rootParams[2].DescriptorTable.NumDescriptorRanges = 1;						//ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¬ãƒ³ã‚¸æ•°
	rootParams[2].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;
	
	rootParams[3].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
	rootParams[3].Descriptor.ShaderRegister = 2;
	rootParams[3].Descriptor.RegisterSpace = 0;	
	rootParams[3].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;//å…¨ã¦ã®ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‹ã‚‰è¦‹ãˆã‚‹



	D3D12_STATIC_SAMPLER_DESC samplerDesc{};
	samplerDesc.AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP;					//æ¨ªç¹°ã‚Šè¿”ã—(ã‚¿ã‚¤ãƒªãƒ³ã‚°)
	samplerDesc.AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP;					//ç¸¦ç¹°ã‚Šè¿”ã—(ã‚¿ã‚¤ãƒªãƒ³ã‚°)
	samplerDesc.AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;					//å¥¥è¡Œç¹°ã‚Šè¿”ã—(ã‚¿ã‚¤ãƒªãƒ³ã‚°)
	samplerDesc.BorderColor = D3D12_STATIC_BORDER_COLOR_TRANSPARENT_BLACK;	//ãƒœãƒ¼ãƒ€ãƒ¼ã®æ™‚ã¯é»’
	samplerDesc.Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;					//å…¨ã¦ãƒªãƒ‹ã‚¢è£œé–“
	samplerDesc.MaxLOD = D3D12_FLOAT32_MAX;									//ãƒŸãƒƒãƒ—ãƒžãƒƒãƒ—æœ€å¤§å€¤
	samplerDesc.MinLOD = 0.0f;
	samplerDesc.ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;
	samplerDesc.ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;			//ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‹ã‚‰ã®ã¿ä½¿ç”¨å¯èƒ½

	PipelineSet pipelineset;

	D3D12_ROOT_SIGNATURE_DESC rootSignatureDesc{};
	rootSignatureDesc.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
	rootSignatureDesc.pParameters = rootParams;
	rootSignatureDesc.NumParameters = _countof(rootParams);
	rootSignatureDesc.pStaticSamplers = &samplerDesc;
	rootSignatureDesc.NumStaticSamplers = 1;

	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º
	ComPtr<ID3DBlob> rootSigBlob;
	result = D3D12SerializeRootSignature(&rootSignatureDesc, D3D_ROOT_SIGNATURE_VERSION_1_0,
		&rootSigBlob, &errorBlob);
	assert(SUCCEEDED(result));
	result = device->CreateRootSignature(0, rootSigBlob->GetBufferPointer(), rootSigBlob->GetBufferSize(),
		IID_PPV_ARGS(&pipelineset.rootSignature));
	assert(SUCCEEDED(result));
	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã«ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã‚’ã‚»ãƒƒãƒˆ
	pipelineDesc.pRootSignature = pipelineset.rootSignature.Get();

	// ãƒ‘ã‚¤ãƒ—ãƒ©ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã®ç”Ÿæˆ
	result = device->CreateGraphicsPipelineState(&pipelineDesc, IID_PPV_ARGS(&pipelineset.pipelineState));
	assert(SUCCEEDED(result));

	return pipelineset;
}

PipelineSet Pipeline::CreateParticlePipline(ID3D12Device* device)
{
	HRESULT result = S_FALSE;
	ComPtr<ID3DBlob> vsBlob; // é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	ComPtr<ID3DBlob> psBlob;	// ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	ComPtr<ID3DBlob> gsBlob;
	ComPtr<ID3DBlob> errorBlob; // ã‚¨ãƒ©ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ


	result = D3DCompileFromFile(
		L"Resources/Shader/ParticleVS.hlsl",
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE,
		"main", "vs_5_0",
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION,
		0,
		&vsBlob, &errorBlob
	);

	// ã‚¨ãƒ©ãƒ¼ãªã‚‰
	if (FAILED(result)) {
		// errorBlobã‹ã‚‰ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’stringåž‹ã«ã‚³ãƒ”ãƒ¼
		std::string error;
		error.resize(errorBlob->GetBufferSize());
		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			error.begin());
		error += "\n";
		// ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’å‡ºåŠ›ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«è¡¨ç¤º
		OutputDebugStringA(error.c_str());
		assert(0);
	}

	result = D3DCompileFromFile(
		L"Resources/Shader/ParticlePS.hlsl", // ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«å
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰å¯èƒ½ã«ã™ã‚‹
		"main", "ps_5_0", // ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆåã€ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ¢ãƒ‡ãƒ«æŒ‡å®š
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // ãƒ‡ãƒãƒƒã‚°ç”¨è¨­å®š
		0,
		&psBlob, &errorBlob);
	// ã‚¨ãƒ©ãƒ¼ãªã‚‰
	if (FAILED(result)) {
		// errorBlobã‹ã‚‰ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’stringåž‹ã«ã‚³ãƒ”ãƒ¼
		std::string error;
		error.resize(errorBlob->GetBufferSize());
		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			error.begin());
		error += "\n";
		// ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’å‡ºåŠ›ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«è¡¨ç¤º
		OutputDebugStringA(error.c_str());
		assert(0);
	}
	result = D3DCompileFromFile(
		L"Resources/Shader/ParticleGS.hlsl",	// ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«å
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰å¯èƒ½ã«ã™ã‚‹
		"main", "gs_5_0",	// ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆåã€ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ¢ãƒ‡ãƒ«æŒ‡å®š
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // ãƒ‡ãƒãƒƒã‚°ç”¨è¨­å®š
		0,
		&gsBlob, &errorBlob);
	if (FAILED(result)) {
		// errorBlobã‹ã‚‰ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’stringåž‹ã«ã‚³ãƒ”ãƒ¼
		std::string errstr;
		errstr.resize(errorBlob->GetBufferSize());

		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			errstr.begin());
		errstr += "\n";
		// ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’å‡ºåŠ›ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«è¡¨ç¤º
		OutputDebugStringA(errstr.c_str());
		exit(1);
	}

	// é ‚ç‚¹ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
	D3D12_INPUT_ELEMENT_DESC inputLayout[] = {
		{ // xyåº§æ¨™(1è¡Œã§æ›¸ã„ãŸã»ã†ãŒè¦‹ã‚„ã™ã„)
			"POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},
		{
			"TEXCOORD",0,DXGI_FORMAT_R32_FLOAT,0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},
	};

	D3D12_GRAPHICS_PIPELINE_STATE_DESC pipelineDesc{};

	pipelineDesc.VS.pShaderBytecode = vsBlob->GetBufferPointer();
	pipelineDesc.VS.BytecodeLength = vsBlob->GetBufferSize();
	pipelineDesc.GS.pShaderBytecode = gsBlob->GetBufferPointer();
	pipelineDesc.GS.BytecodeLength = gsBlob->GetBufferSize();
	pipelineDesc.PS.pShaderBytecode = psBlob->GetBufferPointer();
	pipelineDesc.PS.BytecodeLength = psBlob->GetBufferSize();

	pipelineDesc.SampleMask = D3D12_DEFAULT_SAMPLE_MASK;

	// ãƒ©ã‚¹ã‚¿ãƒ©ã‚¤ã‚¶ã®è¨­å®š
	pipelineDesc.RasterizerState.CullMode = D3D12_CULL_MODE_BACK; // ã‚«ãƒªãƒ³ã‚°ã—ãªã„
	pipelineDesc.RasterizerState.FillMode = D3D12_FILL_MODE_SOLID; // ãƒãƒªã‚´ãƒ³å†…å¡—ã‚Šã¤ã¶ã—
	pipelineDesc.RasterizerState.DepthClipEnable = true; // æ·±åº¦ã‚¯ãƒªãƒƒãƒ”ãƒ³ã‚°ã‚’æœ‰åŠ¹ã«

	pipelineDesc.DepthStencilState.DepthEnable = true;
	pipelineDesc.DepthStencilState.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ZERO;
	pipelineDesc.DepthStencilState.DepthFunc = D3D12_COMPARISON_FUNC_LESS;
	pipelineDesc.DSVFormat = DXGI_FORMAT_D32_FLOAT;


	// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ãƒ–ãƒ¬ãƒ³ãƒ‰è¨­å®š
	D3D12_RENDER_TARGET_BLEND_DESC& blenddesc = pipelineDesc.BlendState.RenderTarget[0];
	blenddesc.RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;	// RBGAå…¨ã¦ã®ãƒãƒ£ãƒ³ãƒãƒ«ã‚’æç”»
	blenddesc.BlendEnable = true;
	blenddesc.BlendOp = D3D12_BLEND_OP_ADD;
	blenddesc.SrcBlend = D3D12_BLEND_ONE;
	blenddesc.DestBlend = D3D12_BLEND_ONE;

	blenddesc.BlendOpAlpha = D3D12_BLEND_OP_ADD;
	blenddesc.SrcBlendAlpha = D3D12_BLEND_ONE;
	blenddesc.DestBlendAlpha = D3D12_BLEND_ZERO;

	// ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚¹ãƒ†ãƒ¼ãƒˆ
	//pipelineDesc.BlendState.RenderTarget[0].RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL; 

	// é ‚ç‚¹ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®è¨­å®š
	pipelineDesc.InputLayout.pInputElementDescs = inputLayout;
	pipelineDesc.InputLayout.NumElements = _countof(inputLayout);

	// å›³å½¢ã®å½¢çŠ¶è¨­å®š
	pipelineDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_POINT;

	// ãã®ä»–ã®è¨­å®š
	pipelineDesc.NumRenderTargets = 1; // æç”»å¯¾è±¡ã¯1ã¤
	pipelineDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB; // 0~255æŒ‡å®šã®RGBA
	pipelineDesc.SampleDesc.Count = 1; // 1ãƒ”ã‚¯ã‚»ãƒ«ã«ã¤ã1å›žã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°

	D3D12_DESCRIPTOR_RANGE descriptorRange{};
	descriptorRange.NumDescriptors = 1;		//ä¸€åº¦ã®æç”»ã«ä½¿ã†ãƒ†ã‚¯ã‚¹ãƒãƒ£ãŒ1æžšãªã®ã§1
	descriptorRange.RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
	descriptorRange.BaseShaderRegister = 0;	//ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ¬ã‚¸ã‚¹ã‚¿0ç•ª
	descriptorRange.OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND;



	D3D12_ROOT_PARAMETER rootParams[2] = {};

	rootParams[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
	rootParams[0].Descriptor.ShaderRegister = 0;
	rootParams[0].Descriptor.RegisterSpace = 0;
	rootParams[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;

	
	//ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ¬ã‚¸ã‚¹ã‚¿0ç•ª
	rootParams[1].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;	//ç¨®é¡ž
	rootParams[1].DescriptorTable.pDescriptorRanges = &descriptorRange;			//ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¬ãƒ³ã‚¸
	rootParams[1].DescriptorTable.NumDescriptorRanges = 1;						//ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¬ãƒ³ã‚¸æ•°
	rootParams[1].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;

	


	D3D12_STATIC_SAMPLER_DESC samplerDesc{};
	samplerDesc.AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP;					//æ¨ªç¹°ã‚Šè¿”ã—(ã‚¿ã‚¤ãƒªãƒ³ã‚°)
	samplerDesc.AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP;					//ç¸¦ç¹°ã‚Šè¿”ã—(ã‚¿ã‚¤ãƒªãƒ³ã‚°)
	samplerDesc.AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;					//å¥¥è¡Œç¹°ã‚Šè¿”ã—(ã‚¿ã‚¤ãƒªãƒ³ã‚°)
	samplerDesc.BorderColor = D3D12_STATIC_BORDER_COLOR_TRANSPARENT_BLACK;	//ãƒœãƒ¼ãƒ€ãƒ¼ã®æ™‚ã¯é»’
	samplerDesc.Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;					//å…¨ã¦ãƒªãƒ‹ã‚¢è£œé–“
	samplerDesc.MaxLOD = D3D12_FLOAT32_MAX;									//ãƒŸãƒƒãƒ—ãƒžãƒƒãƒ—æœ€å¤§å€¤
	samplerDesc.MinLOD = 0.0f;
	samplerDesc.ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;
	samplerDesc.ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;			//ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‹ã‚‰ã®ã¿ä½¿ç”¨å¯èƒ½

	PipelineSet pipelineset;

	D3D12_ROOT_SIGNATURE_DESC rootSignatureDesc{};
	rootSignatureDesc.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
	rootSignatureDesc.pParameters = rootParams;
	rootSignatureDesc.NumParameters = _countof(rootParams);
	rootSignatureDesc.pStaticSamplers = &samplerDesc;
	rootSignatureDesc.NumStaticSamplers = 1;

	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º
	ComPtr<ID3DBlob> rootSigBlob;
	result = D3D12SerializeRootSignature(&rootSignatureDesc, D3D_ROOT_SIGNATURE_VERSION_1_0,
		&rootSigBlob, &errorBlob);
	assert(SUCCEEDED(result));
	result = device->CreateRootSignature(0, rootSigBlob->GetBufferPointer(), rootSigBlob->GetBufferSize(),
		IID_PPV_ARGS(&pipelineset.rootSignature));
	assert(SUCCEEDED(result));
	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã«ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã‚’ã‚»ãƒƒãƒˆ
	pipelineDesc.pRootSignature = pipelineset.rootSignature.Get();

	// ãƒ‘ã‚¤ãƒ—ãƒ©ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã®ç”Ÿæˆ
	result = device->CreateGraphicsPipelineState(&pipelineDesc, IID_PPV_ARGS(&pipelineset.pipelineState));
	assert(SUCCEEDED(result));

	return pipelineset;
}

PipelineSet Pipeline::CreateFBXPipeline(ID3D12Device* device)
{
	HRESULT result = S_FALSE;
	ComPtr<ID3DBlob> vsBlob; // é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	ComPtr<ID3DBlob> psBlob;    // ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	ComPtr<ID3DBlob> errorBlob; // ã‚¨ãƒ©ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ

	assert(device);

	// é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ã®èª­ã¿è¾¼ã¿ã¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«
	result = D3DCompileFromFile(
		L"Resources/Shader/FBXVS.hlsl",    // ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«å
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰å¯èƒ½ã«ã™ã‚‹
		"main", "vs_5_0",    // ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆåã€ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ¢ãƒ‡ãƒ«æŒ‡å®š
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // ãƒ‡ãƒãƒƒã‚°ç”¨è¨­å®š
		0,
		&vsBlob, &errorBlob);
	if (FAILED(result)) {
		// errorBlobã‹ã‚‰ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’stringåž‹ã«ã‚³ãƒ”ãƒ¼
		std::string errstr;
		errstr.resize(errorBlob->GetBufferSize());

		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			errstr.begin());
		errstr += "\n";
		// ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’å‡ºåŠ›ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«è¡¨ç¤º
		OutputDebugStringA(errstr.c_str());
		exit(1);
	}

	// ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã®èª­ã¿è¾¼ã¿ã¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«
	result = D3DCompileFromFile(
		L"Resources/Shader/FBXPS.hlsl",    // ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«å
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰å¯èƒ½ã«ã™ã‚‹
		"main", "ps_5_0",    // ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆåã€ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ¢ãƒ‡ãƒ«æŒ‡å®š
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // ãƒ‡ãƒãƒƒã‚°ç”¨è¨­å®š
		0,
		&psBlob, &errorBlob);
	if (FAILED(result)) {
		// errorBlobã‹ã‚‰ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’stringåž‹ã«ã‚³ãƒ”ãƒ¼
		std::string errstr;
		errstr.resize(errorBlob->GetBufferSize());

		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			errstr.begin());
		errstr += "\n";
		// ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’å‡ºåŠ›ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«è¡¨ç¤º
		OutputDebugStringA(errstr.c_str());
		exit(1);
	}

	// é ‚ç‚¹ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
	D3D12_INPUT_ELEMENT_DESC inputLayout[] = {
		{ // xyåº§æ¨™(1è¡Œã§æ›¸ã„ãŸã»ã†ãŒè¦‹ã‚„ã™ã„)
			"POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},
		{ // æ³•ç·šãƒ™ã‚¯ãƒˆãƒ«(1è¡Œã§æ›¸ã„ãŸã»ã†ãŒè¦‹ã‚„ã™ã„)
			"NORMAL", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},
		{ // uvåº§æ¨™(1è¡Œã§æ›¸ã„ãŸã»ã†ãŒè¦‹ã‚„ã™ã„)
			"TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},
		{
			"BONEINDICES",0,DXGI_FORMAT_R32G32B32A32_UINT,0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA,0
		},
		{
			"BONEWEIGHTS",0,DXGI_FORMAT_R32G32B32A32_FLOAT,0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA,0
		},
	};
	
	// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®æµã‚Œã‚’è¨­å®š
	D3D12_GRAPHICS_PIPELINE_STATE_DESC pipelineDesc{};

	pipelineDesc.VS.pShaderBytecode = vsBlob->GetBufferPointer();
	pipelineDesc.VS.BytecodeLength = vsBlob->GetBufferSize();
	pipelineDesc.PS.pShaderBytecode = psBlob->GetBufferPointer();
	pipelineDesc.PS.BytecodeLength = psBlob->GetBufferSize();

	// ã‚µãƒ³ãƒ—ãƒ«ãƒžã‚¹ã‚¯
	pipelineDesc.SampleMask = D3D12_DEFAULT_SAMPLE_MASK;
	// ãƒ©ã‚¹ã‚¿ãƒ©ã‚¤ã‚¶ã‚¹ãƒ†ãƒ¼ãƒˆ
	// ãƒ©ã‚¹ã‚¿ãƒ©ã‚¤ã‚¶ã®è¨­å®š
	pipelineDesc.RasterizerState.CullMode = D3D12_CULL_MODE_BACK; // ã‚«ãƒªãƒ³ã‚°ã—ãªã„
	pipelineDesc.RasterizerState.FillMode = D3D12_FILL_MODE_SOLID; // ãƒãƒªã‚´ãƒ³å†…å¡—ã‚Šã¤ã¶ã—
	pipelineDesc.RasterizerState.DepthClipEnable = true; // æ·±åº¦ã‚¯ãƒªãƒƒãƒ”ãƒ³ã‚°ã‚’æœ‰åŠ¹ã«

	// ãƒ‡ãƒ—ã‚¹ã‚¹ãƒ†ãƒ³ã‚·ãƒ«ã‚¹ãƒ†ãƒ¼ãƒˆ
	pipelineDesc.DepthStencilState.DepthEnable = true;
	pipelineDesc.DepthStencilState.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ALL;
	pipelineDesc.DepthStencilState.DepthFunc = D3D12_COMPARISON_FUNC_LESS;
	pipelineDesc.DSVFormat = DXGI_FORMAT_D32_FLOAT;


	// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ãƒ–ãƒ¬ãƒ³ãƒ‰è¨­å®š
	D3D12_RENDER_TARGET_BLEND_DESC blenddesc{};
	blenddesc.RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;    // RBGAå…¨ã¦ã®ãƒãƒ£ãƒ³ãƒãƒ«ã‚’æç”»
	blenddesc.BlendEnable = true;
	blenddesc.BlendOp = D3D12_BLEND_OP_ADD;
	blenddesc.SrcBlend = D3D12_BLEND_SRC_ALPHA;
	blenddesc.DestBlend = D3D12_BLEND_INV_SRC_ALPHA;

	blenddesc.BlendOpAlpha = D3D12_BLEND_OP_ADD;
	blenddesc.SrcBlendAlpha = D3D12_BLEND_ONE;
	blenddesc.DestBlendAlpha = D3D12_BLEND_ZERO;

	// ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚¹ãƒ†ãƒ¼ãƒˆã®è¨­å®š
	pipelineDesc.BlendState.RenderTarget[0].RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL; 

	// é ‚ç‚¹ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®è¨­å®š
	pipelineDesc.InputLayout.pInputElementDescs = inputLayout;
	pipelineDesc.InputLayout.NumElements = _countof(inputLayout);

	// å›³å½¢ã®å½¢çŠ¶è¨­å®šï¼ˆä¸‰è§’å½¢ï¼‰
	pipelineDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;

	pipelineDesc.NumRenderTargets = 1;    // æç”»å¯¾è±¡ã¯1ã¤
	pipelineDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB; // 0ï½ž255æŒ‡å®šã®RGBA(SRGBç‰ˆ)
	pipelineDesc.SampleDesc.Count = 1; // 1ãƒ”ã‚¯ã‚»ãƒ«ã«ã¤ã1å›žã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°

	// ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¬ãƒ³ã‚¸
	D3D12_DESCRIPTOR_RANGE descriptorRange{};
	descriptorRange.NumDescriptors = 1;		//ä¸€åº¦ã®æç”»ã«ä½¿ã†ãƒ†ã‚¯ã‚¹ãƒãƒ£ãŒ1æžšãªã®ã§1
	descriptorRange.RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
	descriptorRange.BaseShaderRegister = 0;	//ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ¬ã‚¸ã‚¹ã‚¿0ç•ª
	descriptorRange.OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND;
	
	// ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
	D3D12_ROOT_PARAMETER rootParams[3] = {};

	rootParams[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
	rootParams[0].Descriptor.ShaderRegister = 0;
	rootParams[0].Descriptor.RegisterSpace = 0;
	rootParams[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;

	//ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ¬ã‚¸ã‚¹ã‚¿0ç•ª
	rootParams[1].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;	//ç¨®é¡ž
	rootParams[1].DescriptorTable.pDescriptorRanges = &descriptorRange;			//ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¬ãƒ³ã‚¸
	rootParams[1].DescriptorTable.NumDescriptorRanges = 1;						//ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¬ãƒ³ã‚¸æ•°
	rootParams[1].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;

	rootParams[2].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
	rootParams[2].Descriptor.ShaderRegister = 3;
	rootParams[2].Descriptor.RegisterSpace = 0;
	rootParams[2].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;

	// ã‚¹ã‚¿ãƒ†ã‚£ãƒƒã‚¯ã‚µãƒ³ãƒ—ãƒ©ãƒ¼
	D3D12_STATIC_SAMPLER_DESC samplerDesc{};
	samplerDesc.AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP;					//æ¨ªç¹°ã‚Šè¿”ã—(ã‚¿ã‚¤ãƒªãƒ³ã‚°)
	samplerDesc.AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP;					//ç¸¦ç¹°ã‚Šè¿”ã—(ã‚¿ã‚¤ãƒªãƒ³ã‚°)
	samplerDesc.AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;					//å¥¥è¡Œç¹°ã‚Šè¿”ã—(ã‚¿ã‚¤ãƒªãƒ³ã‚°)
	samplerDesc.BorderColor = D3D12_STATIC_BORDER_COLOR_TRANSPARENT_BLACK;	//ãƒœãƒ¼ãƒ€ãƒ¼ã®æ™‚ã¯é»’
	samplerDesc.Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;					//å…¨ã¦ãƒªãƒ‹ã‚¢è£œé–“
	samplerDesc.MaxLOD = D3D12_FLOAT32_MAX;									//ãƒŸãƒƒãƒ—ãƒžãƒƒãƒ—æœ€å¤§å€¤
	samplerDesc.MinLOD = 0.0f;
	samplerDesc.ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;
	samplerDesc.ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;			//ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‹ã‚‰ã®ã¿ä½¿ç”¨å¯èƒ½


	PipelineSet pipelineset;

	D3D12_ROOT_SIGNATURE_DESC rootSignatureDesc{};
	rootSignatureDesc.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
	rootSignatureDesc.pParameters = rootParams;
	rootSignatureDesc.NumParameters = _countof(rootParams);
	rootSignatureDesc.pStaticSamplers = &samplerDesc;
	rootSignatureDesc.NumStaticSamplers = 1;

	ComPtr<ID3DBlob> rootSigBlob;
	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º
	result = D3D12SerializeRootSignature(&rootSignatureDesc, D3D_ROOT_SIGNATURE_VERSION_1_0,
		&rootSigBlob, &errorBlob);
	assert(SUCCEEDED(result));
	result = device->CreateRootSignature(0, rootSigBlob->GetBufferPointer(), rootSigBlob->GetBufferSize(),
		IID_PPV_ARGS(&pipelineset.rootSignature));
	assert(SUCCEEDED(result));
	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã«ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã‚’ã‚»ãƒƒãƒˆ
	pipelineDesc.pRootSignature = pipelineset.rootSignature.Get();
	

	// ãƒ‘ã‚¤ãƒ—ãƒ©ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã®ç”Ÿæˆ
	result = device->CreateGraphicsPipelineState(&pipelineDesc, IID_PPV_ARGS(&pipelineset.pipelineState));
	assert(SUCCEEDED(result));

	return pipelineset;
}

PipelineSet Pipeline::CreatePostEffectPipeline(ID3D12Device* device)
{
	HRESULT result = S_FALSE;
	ComPtr<ID3DBlob> vsBlob; // é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	ComPtr<ID3DBlob> psBlob;	// ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	ComPtr<ID3DBlob> errorBlob; // ã‚¨ãƒ©ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ


	result = D3DCompileFromFile(
		L"Resources/Shader/PostEffectVS.hlsl",
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE,
		"main", "vs_5_0",
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION,
		0,
		&vsBlob, &errorBlob
	);

	// ã‚¨ãƒ©ãƒ¼ãªã‚‰
	if (FAILED(result)) {
		// errorBlobã‹ã‚‰ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’stringåž‹ã«ã‚³ãƒ”ãƒ¼
		std::string error;
		error.resize(errorBlob->GetBufferSize());
		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			error.begin());
		error += "\n";
		// ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’å‡ºåŠ›ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«è¡¨ç¤º
		OutputDebugStringA(error.c_str());
		assert(0);
	}

	result = D3DCompileFromFile(
		L"Resources/Shader/PostEffectPS.hlsl", // ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«å
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰å¯èƒ½ã«ã™ã‚‹
		"main", "ps_5_0", // ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆåã€ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ¢ãƒ‡ãƒ«æŒ‡å®š
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // ãƒ‡ãƒãƒƒã‚°ç”¨è¨­å®š
		0,
		&psBlob, &errorBlob);
	// ã‚¨ãƒ©ãƒ¼ãªã‚‰
	if (FAILED(result)) {
		// errorBlobã‹ã‚‰ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’stringåž‹ã«ã‚³ãƒ”ãƒ¼
		std::string error;
		error.resize(errorBlob->GetBufferSize());
		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			error.begin());
		error += "\n";
		// ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’å‡ºåŠ›ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«è¡¨ç¤º
		OutputDebugStringA(error.c_str());
		assert(0);
	}

	D3D12_INPUT_ELEMENT_DESC inputLayout[] = {
		{
			"POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},
		{
			"TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},
	};
	//ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®æµã‚Œã‚’è¨­å®š
	D3D12_GRAPHICS_PIPELINE_STATE_DESC gpipeline{};
	gpipeline.VS = CD3DX12_SHADER_BYTECODE(vsBlob.Get());
	gpipeline.PS = CD3DX12_SHADER_BYTECODE(psBlob.Get());
	//ã‚µãƒ³ãƒ—ãƒ«ãƒžã‚¹ã‚¯
	gpipeline.SampleMask = D3D12_DEFAULT_SAMPLE_MASK;
	//ãƒ©ã‚¹ã‚¿ãƒ©ã‚¤ã‚¶ã‚¹ãƒ†ãƒ¼ãƒˆ
	gpipeline.RasterizerState = CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT);
	gpipeline.RasterizerState.CullMode = D3D12_CULL_MODE_NONE;
	//ãƒ‡ãƒ—ã‚¹ã‚¹ãƒ†ãƒ³ã‚·ãƒ«ã‚¹ãƒ†ãƒ¼ãƒˆ
	gpipeline.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC(D3D12_DEFAULT);
	gpipeline.DepthStencilState.DepthFunc = D3D12_COMPARISON_FUNC_ALWAYS;

	// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ãƒ–ãƒ¬ãƒ³ãƒ‰è¨­å®š
	D3D12_RENDER_TARGET_BLEND_DESC blenddesc{};
	blenddesc.RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;	// RBGAå…¨ã¦ã®ãƒãƒ£ãƒ³ãƒãƒ«ã‚’æç”»
	blenddesc.BlendEnable = true;
	blenddesc.BlendOp = D3D12_BLEND_OP_ADD;
	blenddesc.SrcBlend = D3D12_BLEND_SRC_ALPHA;
	blenddesc.DestBlend = D3D12_BLEND_INV_SRC_ALPHA;

	blenddesc.BlendOpAlpha = D3D12_BLEND_OP_ADD;
	blenddesc.SrcBlendAlpha = D3D12_BLEND_ONE;
	blenddesc.DestBlendAlpha = D3D12_BLEND_ZERO;

	// ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚¹ãƒ†ãƒ¼ãƒˆ
	gpipeline.BlendState.RenderTarget[0] = blenddesc;

	//æ·±åº¦ãƒãƒƒãƒ•ã‚¡ã®ãƒ•ã‚©ãƒ¼ãƒžãƒƒãƒˆ
	gpipeline.DSVFormat = DXGI_FORMAT_D32_FLOAT;

	//é ‚ç‚¹ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
	gpipeline.InputLayout.pInputElementDescs = inputLayout;
	gpipeline.InputLayout.NumElements = _countof(inputLayout);

	//å›³å½¢ã®å½¢çŠ¶è¨­å®š(ä¸‰è§’å½¢)
	gpipeline.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;

	gpipeline.NumRenderTargets = 1;
	gpipeline.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
	gpipeline.SampleDesc.Count = 1;

	//ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¬ãƒ³ã‚¸
	CD3DX12_DESCRIPTOR_RANGE descRangeSRV;
	descRangeSRV.Init(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, 1, 0);

	//ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
	CD3DX12_ROOT_PARAMETER rootparams[2];
	rootparams[0].InitAsConstantBufferView(0, 0, D3D12_SHADER_VISIBILITY_ALL);
	rootparams[1].InitAsDescriptorTable(1, &descRangeSRV, D3D12_SHADER_VISIBILITY_ALL);

	//ã‚¹ã‚¿ãƒ†ã‚£ãƒƒã‚¯ã‚µãƒ³ãƒ—ãƒ©ãƒ¼
	CD3DX12_STATIC_SAMPLER_DESC samplerDesc = CD3DX12_STATIC_SAMPLER_DESC(0, D3D12_FILTER_MIN_MAG_MIP_POINT);
	samplerDesc.AddressU = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;
	samplerDesc.AddressV = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;

	//ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒã‚¯ãƒãƒ£ã®è¨­å®š
	CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC rootSignatureDesc;
	rootSignatureDesc.Init_1_0(_countof(rootparams), rootparams, 1, &samplerDesc, D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT);

	PipelineSet pipelineset;
	ComPtr<ID3DBlob> rootSigBlob;
	result = D3DX12SerializeVersionedRootSignature(&rootSignatureDesc, D3D_ROOT_SIGNATURE_VERSION_1_0, &rootSigBlob, &errorBlob);
	assert(SUCCEEDED(result));

	result = device->CreateRootSignature(0, rootSigBlob->GetBufferPointer(), rootSigBlob->GetBufferSize(),IID_PPV_ARGS(&pipelineset.rootSignature));
	assert(SUCCEEDED(result));

	gpipeline.pRootSignature = pipelineset.rootSignature.Get();

	//ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç”Ÿæˆ
	result = device->CreateGraphicsPipelineState(&gpipeline, IID_PPV_ARGS(&pipelineset.pipelineState));
	assert(SUCCEEDED(result));

	return pipelineset;
}

PipelineSet Pipeline::Create3DLinePipeline(ID3D12Device* device)
{

	HRESULT result = S_FALSE;
	ComPtr<ID3DBlob> vsBlob; // é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	ComPtr<ID3DBlob> psBlob;	// ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	ComPtr<ID3DBlob> errorBlob; // ã‚¨ãƒ©ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ

	result = D3DCompileFromFile(
		L"Resources/Shader/3DLineVS.hlsl",
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE,
		"main", "vs_5_0",
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION,
		0,
		&vsBlob, &errorBlob
	);

	// ã‚¨ãƒ©ãƒ¼ãªã‚‰
	if (FAILED(result)) {
		// errorBlobã‹ã‚‰ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’stringåž‹ã«ã‚³ãƒ”ãƒ¼
		std::string error;
		error.resize(errorBlob->GetBufferSize());
		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			error.begin());
		error += "\n";
		// ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’å‡ºåŠ›ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«è¡¨ç¤º
		OutputDebugStringA(error.c_str());
		assert(0);
	}

	result = D3DCompileFromFile(
		L"Resources/Shader/3DLinePS.hlsl", // ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«å
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰å¯èƒ½ã«ã™ã‚‹
		"main", "ps_5_0", // ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆåã€ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ¢ãƒ‡ãƒ«æŒ‡å®š
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // ãƒ‡ãƒãƒƒã‚°ç”¨è¨­å®š
		0,
		&psBlob, &errorBlob);
	// ã‚¨ãƒ©ãƒ¼ãªã‚‰
	if (FAILED(result)) {
		// errorBlobã‹ã‚‰ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’stringåž‹ã«ã‚³ãƒ”ãƒ¼
		std::string error;
		error.resize(errorBlob->GetBufferSize());
		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			error.begin());
		error += "\n";
		// ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’å‡ºåŠ›ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«è¡¨ç¤º
		OutputDebugStringA(error.c_str());
		assert(0);
	}

	D3D12_INPUT_ELEMENT_DESC inputLayout[] =
	{
		{
			"POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},
		{
			"NORMAL",0,DXGI_FORMAT_R32G32B32_FLOAT,0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA,0
		},

	};

	D3D12_GRAPHICS_PIPELINE_STATE_DESC pipelineDesc{};

	pipelineDesc.VS.pShaderBytecode = vsBlob->GetBufferPointer();
	pipelineDesc.VS.BytecodeLength = vsBlob->GetBufferSize();
	pipelineDesc.PS.pShaderBytecode = psBlob->GetBufferPointer();
	pipelineDesc.PS.BytecodeLength = psBlob->GetBufferSize();

	pipelineDesc.SampleMask = D3D12_DEFAULT_SAMPLE_MASK;

	// ãƒ©ã‚¹ã‚¿ãƒ©ã‚¤ã‚¶ã®è¨­å®š
	pipelineDesc.RasterizerState.CullMode = D3D12_CULL_MODE_NONE; // ã‚«ãƒªãƒ³ã‚°ã—ãªã„
	pipelineDesc.RasterizerState.FillMode = D3D12_FILL_MODE_SOLID; // ãƒãƒªã‚´ãƒ³å†…å¡—ã‚Šã¤ã¶ã—
	pipelineDesc.RasterizerState.DepthClipEnable = true; // æ·±åº¦ã‚¯ãƒªãƒƒãƒ”ãƒ³ã‚°ã‚’æœ‰åŠ¹ã«

	pipelineDesc.DepthStencilState.DepthEnable = true;
	pipelineDesc.DepthStencilState.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ALL;
	pipelineDesc.DepthStencilState.DepthFunc = D3D12_COMPARISON_FUNC_LESS;
	pipelineDesc.DSVFormat = DXGI_FORMAT_D32_FLOAT;

	// é ‚ç‚¹ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®è¨­å®š
	pipelineDesc.InputLayout.pInputElementDescs = inputLayout;
	pipelineDesc.InputLayout.NumElements = _countof(inputLayout);

	// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ãƒ–ãƒ¬ãƒ³ãƒ‰è¨­å®š
	D3D12_RENDER_TARGET_BLEND_DESC& blenddesc = pipelineDesc.BlendState.RenderTarget[0];
	blenddesc.RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;	// RBGAå…¨ã¦ã®ãƒãƒ£ãƒ³ãƒãƒ«ã‚’æç”»
	blenddesc.BlendEnable = true;
	blenddesc.BlendOp = D3D12_BLEND_OP_ADD;
	blenddesc.SrcBlend = D3D12_BLEND_SRC_ALPHA;
	blenddesc.DestBlend = D3D12_BLEND_INV_SRC_ALPHA;

	blenddesc.BlendOpAlpha = D3D12_BLEND_OP_ADD;
	blenddesc.SrcBlendAlpha = D3D12_BLEND_ONE;
	blenddesc.DestBlendAlpha = D3D12_BLEND_ZERO;

	// å›³å½¢ã®å½¢çŠ¶è¨­å®š
	pipelineDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_LINE;

	// ãã®ä»–ã®è¨­å®š
	pipelineDesc.NumRenderTargets = 1; // æç”»å¯¾è±¡ã¯1ã¤
	pipelineDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB; // 0~255æŒ‡å®šã®RGBA
	pipelineDesc.SampleDesc.Count = 1; // 1ãƒ”ã‚¯ã‚»ãƒ«ã«ã¤ã1å›žã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°


	D3D12_ROOT_PARAMETER rootParams[2] = {};

	rootParams[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
	rootParams[0].Descriptor.ShaderRegister = 0;
	rootParams[0].Descriptor.RegisterSpace = 0;
	rootParams[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;

	rootParams[1].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
	rootParams[1].Descriptor.ShaderRegister = 1;
	rootParams[1].Descriptor.RegisterSpace = 0;
	rootParams[1].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;
	


	//D3D12_STATIC_SAMPLER_DESC samplerDesc{};
	//samplerDesc.AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP;					//æ¨ªç¹°ã‚Šè¿”ã—(ã‚¿ã‚¤ãƒªãƒ³ã‚°)
	//samplerDesc.AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP;					//ç¸¦ç¹°ã‚Šè¿”ã—(ã‚¿ã‚¤ãƒªãƒ³ã‚°)
	//samplerDesc.AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;					//å¥¥è¡Œç¹°ã‚Šè¿”ã—(ã‚¿ã‚¤ãƒªãƒ³ã‚°)
	//samplerDesc.BorderColor = D3D12_STATIC_BORDER_COLOR_TRANSPARENT_BLACK;	//ãƒœãƒ¼ãƒ€ãƒ¼ã®æ™‚ã¯é»’
	//samplerDesc.Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;					//å…¨ã¦ãƒªãƒ‹ã‚¢è£œé–“
	//samplerDesc.MaxLOD = D3D12_FLOAT32_MAX;									//ãƒŸãƒƒãƒ—ãƒžãƒƒãƒ—æœ€å¤§å€¤
	//samplerDesc.MinLOD = 0.0f;
	//samplerDesc.ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;
	//samplerDesc.ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;			//ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‹ã‚‰ã®ã¿ä½¿ç”¨å¯èƒ½

	PipelineSet pipelineset;

	D3D12_ROOT_SIGNATURE_DESC rootSignatureDesc{};
	rootSignatureDesc.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
	rootSignatureDesc.pParameters = rootParams;
	rootSignatureDesc.NumParameters =_countof(rootParams);
	/*rootSignatureDesc.pStaticSamplers = &samplerDesc;
	rootSignatureDesc.NumStaticSamplers = 1;*/

	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º
	ComPtr<ID3DBlob> rootSigBlob;
	result = D3D12SerializeRootSignature(&rootSignatureDesc, D3D_ROOT_SIGNATURE_VERSION_1_0,
		&rootSigBlob, &errorBlob);
	assert(SUCCEEDED(result));
	result = device->CreateRootSignature(0, rootSigBlob->GetBufferPointer(), rootSigBlob->GetBufferSize(),
		IID_PPV_ARGS(&pipelineset.rootSignature));
	assert(SUCCEEDED(result));
	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã«ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã‚’ã‚»ãƒƒãƒˆ
	pipelineDesc.pRootSignature = pipelineset.rootSignature.Get();

	// ãƒ‘ã‚¤ãƒ—ãƒ©ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã®ç”Ÿæˆ
	result = device->CreateGraphicsPipelineState(&pipelineDesc, IID_PPV_ARGS(&pipelineset.pipelineState));
	assert(SUCCEEDED(result));

	return pipelineset;
}


============================================================
File Path: SourceCode/Engine/Core/Pipeline.h
============================================================
#pragma once
#include <d3d12.h>
#include<wrl.h>
#include<memory>
#include<array>
//#include <cstdint>

using namespace Microsoft::WRL;


struct PipelineSet
{
	//ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£
	ComPtr<ID3D12RootSignature> rootSignature;
	//ãƒ‘ã‚¤ãƒ—ãƒ©ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã®ç”Ÿæˆ
	ComPtr<ID3D12PipelineState> pipelineState;
};

class Pipeline
{
public:

	static PipelineSet CreateSpritePipline(ID3D12Device* device);
	static PipelineSet CreateModelPipline(ID3D12Device* device);
	static PipelineSet CreateParticlePipline(ID3D12Device* device);
	static PipelineSet CreateFBXPipeline(ID3D12Device* device);
	static PipelineSet CreatePostEffectPipeline(ID3D12Device* device);
	static PipelineSet Create3DLinePipeline(ID3D12Device* device);

};



============================================================
File Path: SourceCode/Engine/Core/ViewProjection.cpp
============================================================
#include "ViewProjection.h"
#include"DxWindow.h"
#include"myMath.h"

void ViewProjection::Initialize()
{
	eye = { 0,0,-50.0f };
	target = { 0,0,0 };
	up = { 0,1.0f,0 };
	aspect = (float)DxWindow::window_width / DxWindow::window_height;
	

	UpdateMatview();
	UpdateMatProjection();

}

void ViewProjection::Update()
{
	UpdateMatview();
	UpdateMatProjection();
}

void ViewProjection::UpdateMatview()
{
	matView = Matrix4::View(eye, target, up);
}

void ViewProjection::UpdateMatProjection()
{
	matProjection = Matrix4::PerspectiveProjection(myMath::AngleToRadian(45.0f), (float)DxWindow::window_width / DxWindow::window_height, nearClip, farClip);
}

const Matrix4 ViewProjection::GetMAtView()
{
	return matView;
}

const Matrix4 ViewProjection::GetMatProjection()
{
	return matProjection;
}

const Vector3 ViewProjection::Geteye()
{
	return eye;
}

const Vector3 ViewProjection::Gettarget()
{
	return target;
}

const Vector3 ViewProjection::Getup()
{
	return up;
}

void ViewProjection::SetEye(const Vector3& eye_)
{
	eye = eye_;
}

void ViewProjection::SetTarget(const Vector3& target_)
{
	target = target_;
}

void ViewProjection::SetUp(const Vector3& up_)
{
	up = up_;
}


============================================================
File Path: SourceCode/Engine/Core/ViewProjection.h
============================================================
#pragma once
#include"Matrix4.h"
#include"Vector3.h"
#include<cmath>

class ViewProjection
{
public:

	void Initialize();

	void Update();

	void UpdateMatview();

	void UpdateMatProjection();

	const Matrix4 GetMAtView();
	const Matrix4 GetMatProjection();
	const Vector3 Geteye();
	const Vector3 Gettarget();
	const Vector3 Getup();
	
	void SetEye(const Vector3& eye_);
	void SetTarget(const Vector3& target_);
	void SetUp(const Vector3& up_);

private:

	Matrix4 matView;

	Matrix4 matProjection;

	Vector3 eye;

	Vector3 target;

	Vector3 up;

	float aspect = 0.0f;
	float nearClip = 0.1f;
	//std::float_t nearClip = 0.1f;
	float farClip = 2000.0f;
	//std::float_t farClip = 2000.0f;
	float angle = 0.0f;
	float distance = 50.0f;

};



============================================================
File Path: SourceCode/Engine/Core/WorldTronsform.cpp
============================================================
#include "WorldTronsform.h"
#include<cassert>


void WorldTransform::CreateConstBuffer(ID3D12Device* device)
{
	HRESULT result;
	D3D12_HEAP_PROPERTIES cbHeapProp{};

	cbHeapProp.Type = D3D12_HEAP_TYPE_UPLOAD;	//GPUã¸ã®è»¢é€ç”¨

	D3D12_RESOURCE_DESC cbResourceDesc{};
	//ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
	cbResourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
	
	cbResourceDesc.Width = (sizeof(ConstBufferDataWorldTransformB0) + 0xff) & ~0Xff;	//256ãƒã‚¤ãƒˆã‚¢ãƒ©ã‚¤ãƒ¡ãƒ³ãƒˆ
		
	
	cbResourceDesc.Height = 1;
	cbResourceDesc.DepthOrArraySize = 1;
	cbResourceDesc.MipLevels = 1;
	cbResourceDesc.SampleDesc.Count = 1;
	cbResourceDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;
	
	//å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®ç”Ÿæˆ
	result = device->CreateCommittedResource(
		&cbHeapProp,		//ãƒ’ãƒ¼ãƒ—è¨­å®š
		D3D12_HEAP_FLAG_NONE,
		&cbResourceDesc,	//ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&constBuffB0)
	);
	assert(SUCCEEDED(result));


}

void WorldTransform::UpdateMatrix(ViewProjection* camera)
{
	
	matWorld_ = Matrix4();

	// ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã®åˆæˆ
	matWorld_ *= Matrix4::Scaling(scale_.x, scale_.y, scale_.z);						// ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã«ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°ã‚’åæ˜ 
	matWorld_ *= Matrix4::RotationZXY(rotation_.x, rotation_.y, rotation_.z);           // ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã«å›žè»¢ã‚’åæ˜ 
	matWorld_ *= Matrix4::Translation(translation_.x, translation_.y, translation_.z);          // ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã«å¹³è¡Œç§»å‹•ã‚’åæ˜ 

	//// è¦ªè¡Œåˆ—ã®æŒ‡å®šãŒã‚ã‚‹å ´åˆã¯ã€æŽ›ã‘ç®—ã™ã‚‹
	//if (parent_) {
	//	matWorld_ *= parent_->matWorld_;
	//}

	HRESULT result = constBuffB0->Map(0, nullptr, (void**)&constMap);
	assert(SUCCEEDED(result));
	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ã«æ›¸ãè¾¼ã¿
	constMap->color = color;
	//constMap->matWorld = matWorld_ * view * projection;
	constMap->viewproj = camera->GetMAtView() * camera->GetMatProjection();
	constMap->world = matWorld_;
	constMap->cameraPos = camera->Geteye();

	
}

void WorldTransform::UpdateMatrixBill(ViewProjection* camera)
{
	matWorld_ = Matrix4();

	// ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã®åˆæˆ
	matWorld_ *= Matrix4::Scaling(scale_.x, scale_.y, scale_.z);						// ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã«ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°ã‚’åæ˜ 
	matWorld_ *= Matrix4::RotationZXY(rotation_.z, rotation_.x, rotation_.y);           // ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã«å›žè»¢ã‚’åæ˜ 
	matWorld_ *= Matrix4::Translation(translation_.x, translation_.y, translation_.z);          // ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã«å¹³è¡Œç§»å‹•ã‚’åæ˜ 

	Vector3 eyePosition = camera->Geteye();

	Vector3 targetPosition =camera->Gettarget();

	Vector3 upVector = camera->Getup();

	Vector3 cameraAxisZ = targetPosition-eyePosition;

	cameraAxisZ.normalize();

	Vector3 cameraAxisX;

	cameraAxisX = upVector.cross(cameraAxisZ);

	cameraAxisX.normalize();

	Vector3 cameraAxisY;

	cameraAxisY = cameraAxisZ.cross(cameraAxisX);

	Matrix4 matCameraRot = { Float4(cameraAxisX, 0), Float4(cameraAxisY, 0), Float4(cameraAxisZ, 0), Float4(0,0,0,1) };


	Matrix4 matView = matCameraRot.GetTranspose();

	Vector3 reverseEyePosition = -eyePosition;

	float tX = cameraAxisX.dot(reverseEyePosition);
	float tY = cameraAxisY.dot(reverseEyePosition);
	float tZ = cameraAxisZ.dot(reverseEyePosition);

	Vector3 translation = { tX,tY,tZ };

	matView.SetTranslation(Float4(translation, 1.0f));

	matBillboard = { Float4(cameraAxisX, 0), Float4(cameraAxisY, 0), Float4(cameraAxisZ, 0), Float4(0,0,0,1) };
	
	//// è¦ªè¡Œåˆ—ã®æŒ‡å®šãŒã‚ã‚‹å ´åˆã¯ã€æŽ›ã‘ç®—ã™ã‚‹
	//if (parent_) {
	//	matWorld_ *= parent_->matWorld_;
	//}

	HRESULT result = constBuffB0->Map(0, nullptr, (void**)&constMap);
	assert(SUCCEEDED(result));

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ã«æ›¸ãè¾¼ã¿
	constMap->viewproj = matView * camera->GetMatProjection();
	constMap->world = matBillboard;
	constBuffB0->Unmap(0, nullptr);
	

}

void WorldTransform::UpdateSpriteMatrix(Matrix4 projection)
{
	matWorld_ = Matrix4();

	// ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã®åˆæˆ
	matWorld_ *= Matrix4::Scaling(scale_.x, scale_.y, 1.0f);					// ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã«ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°ã‚’åæ˜ 
	matWorld_ *= Matrix4::RotationZXY(rotation_.z, 0, 0);							// ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã«å›žè»¢ã‚’åæ˜ 
	matWorld_ *= Matrix4::Translation(translation_.x, translation_.y, 0);			// ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã«å¹³è¡Œç§»å‹•ã‚’åæ˜ 


	//// è¦ªè¡Œåˆ—ã®æŒ‡å®šãŒã‚ã‚‹å ´åˆã¯ã€æŽ›ã‘ç®—ã™ã‚‹
	//if (parent_) {
	//    matWorld_ *= parent_->matWorld_;
	//}

	HRESULT result = constBuffB0->Map(0, nullptr, (void**)&constMap);
	assert(SUCCEEDED(result));

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ã«æ›¸ãè¾¼ã¿
	constMap->color = color;
	constMap->world = matWorld_ * projection;

}

============================================================
File Path: SourceCode/Engine/Core/WorldTronsform.h
============================================================
#pragma once
#include"Matrix4.h"
#include"Vector3.h"
#include"Float4.h"
#include <d3d12.h>
#include <wrl.h>
#include"ViewProjection.h"


using namespace Microsoft::WRL;

// å®šæ•°ãƒãƒƒãƒ•ã‚¡ç”¨ãƒ‡ãƒ¼ã‚¿æ§‹é€ ä½“
struct ConstBufferDataWorldTransformB0
{
	Matrix4 viewproj;
	Matrix4 world;
	Vector3 cameraPos;
	float pad1;
	Float4 color;
};



/// <summary>
/// ãƒ¯ãƒ¼ãƒ«ãƒ‰å¤‰æ›ãƒ‡ãƒ¼ã‚¿
/// </summary>
struct WorldTransform {

	
	// å®šæ•°ãƒãƒƒãƒ•ã‚¡
	ComPtr<ID3D12Resource> constBuffB0;
	// ãƒžãƒƒãƒ”ãƒ³ã‚°æ¸ˆã¿ã‚¢ãƒ‰ãƒ¬ã‚¹
	ConstBufferDataWorldTransformB0* constMap = nullptr;
	// ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ã‚±ãƒ¼ãƒ«
	Vector3 scale_ = { 1, 1, 1 };
	// X,Y,Zè»¸å›žã‚Šã®ãƒ­ãƒ¼ã‚«ãƒ«å›žè»¢è§’
	Vector3 rotation_ = { 0.0f, 0.0f, 0.0f };
	// ãƒ­ãƒ¼ã‚«ãƒ«åº§æ¨™
	Vector3 translation_ = { 0.0f, 0.0f, 0.0f };

	Float4 color = { 1,1,1,1 };
	// ãƒ­ãƒ¼ã‚«ãƒ« â†’ ãƒ¯ãƒ¼ãƒ«ãƒ‰å¤‰æ›è¡Œåˆ—
	Matrix4 matWorld_;

	Matrix4 matBillboard;
	// è¦ªã¨ãªã‚‹ãƒ¯ãƒ¼ãƒ«ãƒ‰å¤‰æ›ã¸ã®ãƒã‚¤ãƒ³ã‚¿
	//WorldTransform* parent_ = nullptr;

	/// <summary>
	/// å®šæ•°ãƒãƒƒãƒ•ã‚¡ç”Ÿæˆ
	/// </summary>
	void CreateConstBuffer(ID3D12Device* device);
	
	/// <summary>
	/// è¡Œåˆ—ã‚’æ›´æ–°ã™ã‚‹
	/// </summary>
	void UpdateMatrix(ViewProjection* camera);

	void UpdateMatrixBill(ViewProjection* camera);

	void UpdateSpriteMatrix(Matrix4 projection);
};


============================================================
File Path: SourceCode/Engine/Draw/2D/DrawCommon.cpp
============================================================
#include "DrawCommon.h"

ConstBufferDataMaterial Material::GetConstBufferMaterial()
{
    return ConstBufferDataMaterial();
}


============================================================
File Path: SourceCode/Engine/Draw/2D/DrawCommon.h
============================================================
#pragma once
#include <d3dcompiler.h>
#pragma comment(lib,"d3dcompiler.lib")
#include<string>
#include"myMath.h"
using namespace std;


struct PNU
{
	Vector3 pos; // xyzåº§æ¨™
	Vector3 normal;
	Vector2 uv;
};

struct ConstBufferDataMaterial
{
	Vector3 ambient;
	float pad1;
	Vector3 diffuse;
	float pad2;
	Vector3 specular;
	float alpha;
};

struct Material
{
	string name;
	Vector3 ambient;
	Vector3 diffuse;
	Vector3 specular;

	float alpha;
	string textureFilename;

	Material()
	{
		ambient = { 0.3f,0.3f,0.3f };
		diffuse = { 0.0f,0.0f,0.0f };
		specular = { 0.0f,0.0f,0.0f };
		alpha = 1.0f;

	}
	ConstBufferDataMaterial GetConstBufferMaterial();
};





class DrawCommon
{
};



============================================================
File Path: SourceCode/Engine/Draw/2D/Sprite.cpp
============================================================
//#include "Sprite.h"
//#include"DxWindow.h"
//#include<string>
//#include <DirectXTex.h>
//#include <d3dcompiler.h>
//
//#pragma comment(lib, "d3dcompiler.lib")
//
//void Sprite::StaticInitialize(ID3D12Device* _device)
//{
//	assert(_device);
//
//	device = _device;
//
//	InitializeGraphicsPipeline();
//
//	CreateDescriptorHeap();
//}
//
//void Sprite::PreDraw(ID3D12GraphicsCommandList* cmdList)
//{
//	commandList = cmdList;
//
//	commandList->SetPipelineState(pipelinestate.Get());
//	commandList->SetGraphicsRootSignature(rootsignature.Get());
//	// ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å½¢çŠ¶ã®è¨­å®šã‚³ãƒžãƒ³ãƒ‰
//	commandList->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST); // ä¸‰è§’å½¢ãƒªã‚¹ãƒˆ
//}
//
//void Sprite::PostDraw()
//{
//	Sprite::commandList = nullptr;
//}
//
//void Sprite::Initialize()
//{
//	HRESULT result;
//
//	VertexPos vertices[] = {
//		{{  0.0f,100.0f,0},{0.0f,1.0f} },
//		{{  0.0f,  0.0f,0},{0.0f,0.0f} },
//		{{100.0f,100.0f,0},{1.0f,1.0f} },
//		{{100.0f,  0.0f,0},{1.0f,0.0f} },
//
//	};
//
//	uint16_t indices[] =
//	{
//		0,1,2,
//		1,2,3,
//	};
//	UINT sizeVB = static_cast<UINT>(sizeof(vertices[0]) * _countof(vertices));
//
//	D3D12_HEAP_PROPERTIES heapProp{};
//	heapProp.Type = D3D12_HEAP_TYPE_UPLOAD;
//
//	D3D12_RESOURCE_DESC resDesc{};
//	resDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
//	resDesc.Width = sizeVB;
//	resDesc.Height = 1;
//	resDesc.DepthOrArraySize = 1;
//	resDesc.MipLevels = 1;
//	resDesc.SampleDesc.Count = 1;
//	resDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;
//
//	result = device->CreateCommittedResource(
//		&heapProp,
//		D3D12_HEAP_FLAG_NONE,
//		&resDesc,
//		D3D12_RESOURCE_STATE_GENERIC_READ,
//		nullptr,
//		IID_PPV_ARGS(&vertBuff)
//	);
//	assert(SUCCEEDED(result));
//
//
//	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã¸ã®ãƒ‡ãƒ¼ã‚¿è»¢é€
//	VertexPos* vertMap = nullptr;
//	result = vertBuff->Map(0, nullptr, (void**)&vertMap);
//	if (SUCCEEDED(result))
//	{
//		memcpy(vertMap, vertices, sizeof(vertices));
//		vertBuff->Unmap(0, nullptr);
//	}
//
//	vbView.BufferLocation = vertBuff->GetGPUVirtualAddress();
//	vbView.SizeInBytes = sizeVB;
//	vbView.StrideInBytes = sizeof(vertices[0]);
//
//	UINT sizeIB = static_cast<UINT>(sizeof(uint16_t) * _countof(indices));
//
//	resDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
//
//	resDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
//	resDesc.Width = sizeIB;	//ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æƒ…å ±ãŒå…¥ã‚‹ã‚µã‚¤ã‚º
//	resDesc.Height = 1;
//	resDesc.DepthOrArraySize = 1;
//	resDesc.MipLevels = 1;
//	resDesc.SampleDesc.Count = 1;
//	resDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;
//	
//	result = device->CreateCommittedResource(
//		&heapProp,	//ãƒ’ãƒ¼ãƒ—è¨­å®š
//		D3D12_HEAP_FLAG_NONE,
//		&resDesc,	//ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
//		D3D12_RESOURCE_STATE_GENERIC_READ,
//		nullptr,
//		IID_PPV_ARGS(&indexBuff)
//	);
//
//	uint16_t* indexMap = nullptr;
//	result = indexBuff->Map(0, nullptr, (void**)&indexMap);
//	if (SUCCEEDED(result)) 
//	{
//		memcpy(indexMap, indices, sizeof(indices));
//		indexBuff->Unmap(0, nullptr);
//	}
//	
//	ibView.BufferLocation = indexBuff->GetGPUVirtualAddress();
//	ibView.Format = DXGI_FORMAT_R16_UINT;
//	ibView.SizeInBytes = sizeIB;
//
//
//	D3D12_HEAP_PROPERTIES cbHeapProp{};
//
//	cbHeapProp.Type = D3D12_HEAP_TYPE_UPLOAD;	//GPUã¸ã®è»¢é€ç”¨
//
//	D3D12_RESOURCE_DESC cbResourceDesc{};
//	//ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
//	cbResourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
//	cbResourceDesc.Width = (sizeof(ConstBufferDataMaterial) + 0xff) & ~0Xff;	//256ãƒã‚¤ãƒˆã‚¢ãƒ©ã‚¤ãƒ¡ãƒ³ãƒˆ
//	cbResourceDesc.Height = 1;
//	cbResourceDesc.DepthOrArraySize = 1;
//	cbResourceDesc.MipLevels = 1;
//	cbResourceDesc.SampleDesc.Count = 1;
//	cbResourceDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;
//
//	//å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®ç”Ÿæˆ
//	result = device->CreateCommittedResource(
//		&cbHeapProp,		//ãƒ’ãƒ¼ãƒ—è¨­å®š
//		D3D12_HEAP_FLAG_NONE,
//		&cbResourceDesc,	//ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
//		D3D12_RESOURCE_STATE_GENERIC_READ,
//		nullptr,
//		IID_PPV_ARGS(&constBuff)
//	);
//	assert(SUCCEEDED(result));
//	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ã«ãƒ‡ãƒ¼ã‚¿è»¢é€
//	ConstBufferDataMaterial* constMap = nullptr;
//	result = constBuff->Map(0, nullptr, (void**)&constMap);
//	
//	assert(SUCCEEDED(result));
//	
//	constMap->mat = XMMatrixIdentity();
//	constMap->mat.r[0].m128_f32[0] = 2.0f / DxWindow::window_width;
//	constMap->mat.r[1].m128_f32[1] = -2.0f / DxWindow::window_height;
//
//	constMap->mat.r[3].m128_f32[0] = -1.0f;
//	constMap->mat.r[3].m128_f32[1] = 1.0f;
//}
//
//
//void Sprite::InitializeGraphicsPipeline()
//{
//	HRESULT result = S_FALSE;
//	ComPtr<ID3DBlob> vsBlob; // é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
//	ComPtr<ID3DBlob> psBlob;	// ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
//	ComPtr<ID3DBlob> errorBlob; // ã‚¨ãƒ©ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
//
//
//	result = D3DCompileFromFile(
//		L"BasicVS.hlsl",
//		nullptr,
//		D3D_COMPILE_STANDARD_FILE_INCLUDE,
//		"main", "vs_5_0",
//		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION,
//		0,
//		&vsBlob, &errorBlob
//	);
//
//	// ã‚¨ãƒ©ãƒ¼ãªã‚‰
//	if (FAILED(result)) {
//		// errorBlobã‹ã‚‰ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’stringåž‹ã«ã‚³ãƒ”ãƒ¼
//		std::string error;
//		error.resize(errorBlob->GetBufferSize());
//		std::copy_n((char*)errorBlob->GetBufferPointer(),
//			errorBlob->GetBufferSize(),
//			error.begin());
//		error += "\n";
//		// ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’å‡ºåŠ›ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«è¡¨ç¤º
//		OutputDebugStringA(error.c_str());
//		assert(0);
//	}
//
//	result = D3DCompileFromFile(
//		L"BasicPS.hlsl", // ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«å
//		nullptr,
//		D3D_COMPILE_STANDARD_FILE_INCLUDE, // ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰å¯èƒ½ã«ã™ã‚‹
//		"main", "ps_5_0", // ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆåã€ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ¢ãƒ‡ãƒ«æŒ‡å®š
//		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // ãƒ‡ãƒãƒƒã‚°ç”¨è¨­å®š
//		0,
//		&psBlob, &errorBlob);
//	// ã‚¨ãƒ©ãƒ¼ãªã‚‰
//	if (FAILED(result)) {
//		// errorBlobã‹ã‚‰ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’stringåž‹ã«ã‚³ãƒ”ãƒ¼
//		std::string error;
//		error.resize(errorBlob->GetBufferSize());
//		std::copy_n((char*)errorBlob->GetBufferPointer(),
//			errorBlob->GetBufferSize(),
//			error.begin());
//		error += "\n";
//		// ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’å‡ºåŠ›ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«è¡¨ç¤º
//		OutputDebugStringA(error.c_str());
//		assert(0);
//	}
//
//	D3D12_INPUT_ELEMENT_DESC inputLayout[] = {
//		{
//			"POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0,
//			D3D12_APPEND_ALIGNED_ELEMENT,
//			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
//		},
//		{
//			"TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0,
//			D3D12_APPEND_ALIGNED_ELEMENT,
//			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
//		},
//	};
//
//	D3D12_GRAPHICS_PIPELINE_STATE_DESC pipelineDesc{};
//
//	pipelineDesc.VS.pShaderBytecode = vsBlob->GetBufferPointer();
//	pipelineDesc.VS.BytecodeLength = vsBlob->GetBufferSize();
//	pipelineDesc.PS.pShaderBytecode = psBlob->GetBufferPointer();
//	pipelineDesc.PS.BytecodeLength = psBlob->GetBufferSize();
//
//	pipelineDesc.SampleMask = D3D12_DEFAULT_SAMPLE_MASK;
//
//	// ãƒ©ã‚¹ã‚¿ãƒ©ã‚¤ã‚¶ã®è¨­å®š
//	pipelineDesc.RasterizerState.CullMode = D3D12_CULL_MODE_NONE; // ã‚«ãƒªãƒ³ã‚°ã—ãªã„
//	pipelineDesc.RasterizerState.FillMode = D3D12_FILL_MODE_SOLID; // ãƒãƒªã‚´ãƒ³å†…å¡—ã‚Šã¤ã¶ã—
//	pipelineDesc.RasterizerState.DepthClipEnable = true; // æ·±åº¦ã‚¯ãƒªãƒƒãƒ”ãƒ³ã‚°ã‚’æœ‰åŠ¹ã«
//
//	// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ãƒ–ãƒ¬ãƒ³ãƒ‰è¨­å®š
//	D3D12_RENDER_TARGET_BLEND_DESC& blenddesc = pipelineDesc.BlendState.RenderTarget[0];
//	blenddesc.RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;	// RBGAå…¨ã¦ã®ãƒãƒ£ãƒ³ãƒãƒ«ã‚’æç”»
//	blenddesc.BlendEnable = true;
//	blenddesc.BlendOp = D3D12_BLEND_OP_ADD;
//	blenddesc.SrcBlend = D3D12_BLEND_SRC_ALPHA;
//	blenddesc.DestBlend = D3D12_BLEND_INV_SRC_ALPHA;
//
//	blenddesc.BlendOpAlpha = D3D12_BLEND_OP_ADD;
//	blenddesc.SrcBlendAlpha = D3D12_BLEND_ONE;
//	blenddesc.DestBlendAlpha = D3D12_BLEND_ZERO;
//
//	// ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚¹ãƒ†ãƒ¼ãƒˆ
//	//pipelineDesc.BlendState.RenderTarget[0].RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL; 
//
//	// é ‚ç‚¹ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®è¨­å®š
//	pipelineDesc.InputLayout.pInputElementDescs = inputLayout;
//	pipelineDesc.InputLayout.NumElements = _countof(inputLayout);
//
//	// å›³å½¢ã®å½¢çŠ¶è¨­å®š
//	pipelineDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
//
//	// ãã®ä»–ã®è¨­å®š
//	pipelineDesc.NumRenderTargets = 1; // æç”»å¯¾è±¡ã¯1ã¤
//	pipelineDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB; // 0~255æŒ‡å®šã®RGBA
//	pipelineDesc.SampleDesc.Count = 1; // 1ãƒ”ã‚¯ã‚»ãƒ«ã«ã¤ã1å›žã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
//
//	D3D12_DESCRIPTOR_RANGE descriptorRange{};
//	descriptorRange.NumDescriptors = 1;		//ä¸€åº¦ã®æç”»ã«ä½¿ã†ãƒ†ã‚¯ã‚¹ãƒãƒ£ãŒ1æžšãªã®ã§1
//	descriptorRange.RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
//	descriptorRange.BaseShaderRegister = 0;	//ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ¬ã‚¸ã‚¹ã‚¿0ç•ª
//	descriptorRange.OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND;
//
//
//
//	D3D12_ROOT_PARAMETER rootParams[3] = {};
//
//	rootParams[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
//	rootParams[0].Descriptor.ShaderRegister = 0;
//	rootParams[0].Descriptor.RegisterSpace = 0;
//	rootParams[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;
//
//	//ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ¬ã‚¸ã‚¹ã‚¿0ç•ª
//	rootParams[1].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;	//ç¨®é¡ž
//	rootParams[1].DescriptorTable.pDescriptorRanges = &descriptorRange;			//ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¬ãƒ³ã‚¸
//	rootParams[1].DescriptorTable.NumDescriptorRanges = 1;						//ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¬ãƒ³ã‚¸æ•°
//	rootParams[1].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;				//å…¨ã¦ã®ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‹ã‚‰è¦‹ãˆã‚‹
//
//	//å®šæ•°ãƒãƒƒãƒ•ã‚¡1ç•ª
//	rootParams[2].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;		//ç¨®é¡ž
//	rootParams[2].Descriptor.ShaderRegister = 1;						//å®šæ•°ãƒãƒƒãƒ•ã‚¡ç•ªå·
//	rootParams[2].Descriptor.RegisterSpace = 0;							//ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
//	rootParams[2].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;		//å…¨ã¦ã®ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‹ã‚‰è¦‹ãˆã‚‹
//
//	D3D12_STATIC_SAMPLER_DESC samplerDesc{};
//	samplerDesc.AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP;					//æ¨ªç¹°ã‚Šè¿”ã—(ã‚¿ã‚¤ãƒªãƒ³ã‚°)
//	samplerDesc.AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP;					//ç¸¦ç¹°ã‚Šè¿”ã—(ã‚¿ã‚¤ãƒªãƒ³ã‚°)
//	samplerDesc.AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;					//å¥¥è¡Œç¹°ã‚Šè¿”ã—(ã‚¿ã‚¤ãƒªãƒ³ã‚°)
//	samplerDesc.BorderColor = D3D12_STATIC_BORDER_COLOR_TRANSPARENT_BLACK;	//ãƒœãƒ¼ãƒ€ãƒ¼ã®æ™‚ã¯é»’
//	samplerDesc.Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;					//å…¨ã¦ãƒªãƒ‹ã‚¢è£œé–“
//	samplerDesc.MaxLOD = D3D12_FLOAT32_MAX;									//ãƒŸãƒƒãƒ—ãƒžãƒƒãƒ—æœ€å¤§å€¤
//	samplerDesc.MinLOD = 0.0f;
//	samplerDesc.ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;
//	samplerDesc.ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;			//ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‹ã‚‰ã®ã¿ä½¿ç”¨å¯èƒ½
//	
//	
//	
//	D3D12_ROOT_SIGNATURE_DESC rootSignatureDesc{};
//	rootSignatureDesc.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
//	rootSignatureDesc.pParameters = rootParams;
//	rootSignatureDesc.NumParameters = _countof(rootParams);
//	rootSignatureDesc.pStaticSamplers = &samplerDesc;
//	rootSignatureDesc.NumStaticSamplers = 1;
//
//	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º
//	ID3DBlob* rootSigBlob = nullptr;
//	result = D3D12SerializeRootSignature(&rootSignatureDesc, D3D_ROOT_SIGNATURE_VERSION_1_0,
//		&rootSigBlob, &errorBlob);
//	assert(SUCCEEDED(result));
//	result = device->CreateRootSignature(0, rootSigBlob->GetBufferPointer(), rootSigBlob->GetBufferSize(),
//		IID_PPV_ARGS(&rootsignature));
//	assert(SUCCEEDED(result));
//	rootSigBlob->Release();
//	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã«ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã‚’ã‚»ãƒƒãƒˆ
//	pipelineDesc.pRootSignature = rootsignature.Get();
//
//	// ãƒ‘ã‚¤ãƒ—ãƒ©ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã®ç”Ÿæˆ
//	result = device->CreateGraphicsPipelineState(&pipelineDesc, IID_PPV_ARGS(&pipelinestate));
//	assert(SUCCEEDED(result));
//}
//
//void Sprite::CreateDescriptorHeap()
//{
//	HRESULT result = S_FALSE;
//
//	D3D12_DESCRIPTOR_HEAP_DESC descHeapDesc = {};
//	descHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
//	descHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;//ã‚·ã‚§ãƒ¼ãƒ€ã‹ã‚‰è¦‹ãˆã‚‹ã‚ˆã†ã«
//	descHeapDesc.NumDescriptors = SrvCount;
//	result = device->CreateDescriptorHeap(&descHeapDesc, IID_PPV_ARGS(&descHeap));//ç”Ÿæˆ
//	assert(SUCCEEDED(result));
//
//	srvHandle = descHeap->GetCPUDescriptorHandleForHeapStart();
//
//}
//
//void Sprite::LoadTexture(UINT texnumber, const wchar_t* filename)
//{
//	HRESULT result = S_FALSE;
//
//	TexMetadata metadata{};
//	ScratchImage scratchImg{};
//
//	result = LoadFromWICFile(
//		filename,
//		WIC_FLAGS_NONE,
//		&metadata, scratchImg
//	);
//
//	ScratchImage mipChain{};
//
//	result = GenerateMipMaps(
//		scratchImg.GetImages(), scratchImg.GetImageCount(), scratchImg.GetMetadata(),
//		TEX_FILTER_DEFAULT, 0, mipChain);
//	if (SUCCEEDED(result)) {
//		scratchImg = std::move(mipChain);
//		metadata = scratchImg.GetMetadata();
//	}
//
//	metadata.format = MakeSRGB(metadata.format);
//
//	D3D12_HEAP_PROPERTIES HeapProp{};
//	HeapProp.Type = D3D12_HEAP_TYPE_CUSTOM;
//	HeapProp.CPUPageProperty = D3D12_CPU_PAGE_PROPERTY_WRITE_BACK;
//	HeapProp.MemoryPoolPreference = D3D12_MEMORY_POOL_L0;
//
//	D3D12_RESOURCE_DESC rsDesc{};
//	rsDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
//	rsDesc.Format = metadata.format;
//	rsDesc.Width = metadata.width;
//	rsDesc.Height = (UINT)metadata.height;
//	rsDesc.DepthOrArraySize = (UINT16)metadata.arraySize;
//	rsDesc.MipLevels = (UINT16)metadata.mipLevels;
//	rsDesc.SampleDesc.Count = 1;
//
//	result = device->CreateCommittedResource(
//		&HeapProp,		//ãƒ’ãƒ¼ãƒ—è¨­å®š
//		D3D12_HEAP_FLAG_NONE,
//		&rsDesc,	//ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
//		D3D12_RESOURCE_STATE_GENERIC_READ,
//		nullptr,
//		IID_PPV_ARGS(&texBuff[texnumber])
//	);
//
//	for (size_t i = 0; i < metadata.mipLevels; i++) {
//		const Image* img = scratchImg.GetImage(i, 0, 0); // ç”Ÿãƒ‡ãƒ¼ã‚¿æŠ½å‡º
//		result = texBuff[texnumber]->WriteToSubresource(
//			(UINT)i,
//			nullptr,              // å…¨é ˜åŸŸã¸ã‚³ãƒ”ãƒ¼
//			img->pixels,          // å…ƒãƒ‡ãƒ¼ã‚¿ã‚¢ãƒ‰ãƒ¬ã‚¹
//			(UINT)img->rowPitch,  // 1ãƒ©ã‚¤ãƒ³ã‚µã‚¤ã‚º
//			(UINT)img->slicePitch // 1æžšã‚µã‚¤ã‚º
//		);
//		assert(SUCCEEDED(result));
//	}
//
//
//	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc{};
//	srvDesc.Format = rsDesc.Format;
//	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
//	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;
//	srvDesc.Texture2D.MipLevels = rsDesc.MipLevels;
//
//	device->CreateShaderResourceView(texBuff[texnumber].Get(), &srvDesc, srvHandle);
//
//
//
//}
//
//void Sprite::Draw()
//{
//	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã®è¨­å®šã‚³ãƒžãƒ³ãƒ‰
//	commandList->IASetVertexBuffers(0, 1, &vbView);
//
//	commandList->IASetIndexBuffer(&ibView);
//	
//	commandList->SetGraphicsRootConstantBufferView(0, this->constBuff->GetGPUVirtualAddress());
//	
//	ID3D12DescriptorHeap* ppHeaps[] = { descHeap.Get() };
//
//	commandList->SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);
//
//	D3D12_GPU_DESCRIPTOR_HANDLE srvGpuHandle = descHeap.Get()->GetGPUDescriptorHandleForHeapStart();
//
//	commandList->SetGraphicsRootDescriptorTable(1, srvGpuHandle);
//	
//	commandList->SetGraphicsRootConstantBufferView(2, this->constBuff->GetGPUVirtualAddress());
//
//	// æç”»ã‚³ãƒžãƒ³ãƒ‰
//	//commandList->DrawInstanced(3, 1, 0, 0); // å…¨ã¦ã®é ‚ç‚¹ã‚’ä½¿ã£ã¦æç”»
//	commandList->DrawIndexedInstanced(6, 1, 0, 0, 0); // å…¨ã¦ã®é ‚ç‚¹ã‚’ä½¿ã£ã¦æç”»
//}
//


============================================================
File Path: SourceCode/Engine/Draw/2D/Sprite.h
============================================================
//#pragma once
//#include <Windows.h>
//#include <wrl.h>
//#include <d3d12.h>
//
//#include"myMath.h"
//
//using namespace DirectX;
//
//using namespace Microsoft::WRL;
//
//class Sprite
//{
//
//private:
//
//	//static const int vertexcount = 3;
//
//
//public:
//
//	struct VertexPos
//	{
//		Vector3 pos; // xyzåº§æ¨™
//		Vector2 uv;
//	};
//
//	struct ConstBufferDataMaterial
//	{
//		Float4 color;
//		Matrix4 mat;
//	};
//
//
//	void StaticInitialize(ID3D12Device* device);
//
//	/// <param name="cmdList">æç”»ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆ</param>
//	void PreDraw(ID3D12GraphicsCommandList* cmdList);
//
//	/// <summary>
//	/// æç”»å¾Œå‡¦ç†
//	/// </summary>
//	void PostDraw();
//
//
//
//
//public:
//
//	void Initialize();
//
//	void InitializeGraphicsPipeline();
//
//	void CreateDescriptorHeap();
//
//	void LoadTexture(UINT texnumber, const wchar_t* filename);
//
//	
//	
//
//
//	void Draw();
//
//private:
//
//	static const int SrvCount = 512;
//
//	ID3D12Device* device;
//
//	ComPtr<ID3D12DescriptorHeap> descHeap;
//
//	// ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆ
//	ID3D12GraphicsCommandList* commandList;
//
//	ComPtr<ID3D12Resource> vertBuff;
//
//	ComPtr<ID3D12Resource> indexBuff;
//	// å®šæ•°ãƒãƒƒãƒ•ã‚¡
//	ComPtr<ID3D12Resource> constBuff;
//
//	ComPtr<ID3D12Resource> texBuff[SrvCount];
//
//	ComPtr<ID3D12RootSignature> rootsignature;
//	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
//	ComPtr<ID3D12PipelineState> pipelinestate;
//
//	D3D12_VERTEX_BUFFER_VIEW vbView;
//	D3D12_INDEX_BUFFER_VIEW ibView;
//	D3D12_CPU_DESCRIPTOR_HANDLE srvHandle;
//
//	
//
//	//XMFLOAT3 vertices[vertexcount]; 
//
//
//	
//
//private:
//
//	
//	
//
//};
//


============================================================
File Path: SourceCode/Engine/Draw/2D/Sprite2D.cpp
============================================================
#include "Sprite2D.h"

void Sprite2D::Initialize(SpriteCommon* _spritecommon,uint32_t handle)
{
	spritecommon = _spritecommon;
	tex = TextureManager::GetTextureData(handle);

	device = spritecommon->GetDirextXCommon()->GetDevice();
	CreateVertexIndexBuffer();
	Wt.CreateConstBuffer(device);

	
}

void Sprite2D::Update()
{
	Wt.UpdateSpriteMatrix(spritecommon->Getmat());
}

void Sprite2D::Draw(float x, float y, float x2, float y2, Vector2 anchor, bool flipX, bool flipY)
{
	int isFlipX, isFlipY;
	if (flipX == false)isFlipX = 1;
	else isFlipX = -1;
	if (flipY == false)isFlipY = 1;
	else isFlipY = -1;

	float left =  x * isFlipX;
	float right = x2 * isFlipX;
	float top = y * isFlipY;
	float bottom =y2 * isFlipY;



	VertexPos vertices[] =
	{
		{{left,top,0.0f},{0.0f,0.0f}	},
		{{left,bottom,0.0f},{0.0f,1.0f}	},
		{{right,top,0.0f},{1.0f,0.0f}	},
		{{right,bottom,0.0f},{1.0f,1.0f}}
	};
	uint32_t indices[] =
	{
		1,0,3,
		2,3,0,
	};



	vertexBuffer->Update(vertices);

	indexBuffer->Update(indices);

	Update();

	spritecommon->DrawCommand(tex, vertexBuffer->GetView(), indexBuffer->GetView(), &Wt);
}

void Sprite2D::Draw(Vector2 anchor, bool flipX, bool flipY)
{
	int isFlipX, isFlipY;
	if (flipX == false)isFlipX = 1;
	else isFlipX = -1;
	if (flipY == false)isFlipY = 1;
	else isFlipY = -1;

	float left = ((0.0f - anchor.x) * tex->width) * isFlipX;
	float right = ((1.0f - anchor.x) * tex->width) * isFlipX;
	float top = ((0.0f - anchor.y) * tex->height) * isFlipY;
	float bottom = ((1.0f - anchor.y) * tex->height) * isFlipY;



	VertexPos vertices[] =
	{
		{{left,top,0.0f},{0.0f,0.0f}	},
		{{left,bottom,0.0f},{0.0f,1.0f}	},
		{{right,top,0.0f},{1.0f,0.0f}	},
		{{right,bottom,0.0f},{1.0f,1.0f}}
	};
	uint32_t indices[] =
	{
		1,0,3,
		2,3,0,
	};

	vertexBuffer->Update(vertices);

	indexBuffer->Update(indices);

	Update();

	spritecommon->DrawCommand(tex, vertexBuffer->GetView(), indexBuffer->GetView(), &Wt);

}

void Sprite2D::DrawClip(Vector2 ClipPos, Vector2 ClipSize, bool flipX, bool flipY)
{
	int isFlipX, isFlipY;
	if (flipX == false)isFlipX = 1;
	else isFlipX = -1;
	if (flipY == false)isFlipY = 1;
	else isFlipY = -1;

	float left = -ClipSize.x * isFlipX;
	float right = ClipSize.x * isFlipX;
	float top = -ClipSize.y * isFlipY;
	float bottom = ClipSize.y * isFlipY;



	VertexPos vertices[] =
	{
		{{left,top,0.0f}	,{(ClipPos.x - ClipSize.x) / tex->width,(ClipPos.y - ClipSize.y) / tex->height}	},
		{{left,bottom,0.0f}	,{(ClipPos.x - ClipSize.x) / tex->width,(ClipPos.y + ClipSize.y) / tex->height}	},
		{{right,top,0.0f}	,{(ClipPos.x + ClipSize.x) / tex->width,(ClipPos.y - ClipSize.y) / tex->height}	},
		{{right,bottom,0.0f},{(ClipPos.x + ClipSize.x) / tex->width,(ClipPos.y + ClipSize.y) / tex->height}}
	};
	uint32_t indices[] =
	{
		1,0,3,
		2,3,0,
	};

	vertexBuffer->Update(vertices);

	indexBuffer->Update(indices);

	Update();

	spritecommon->DrawCommand(tex, vertexBuffer->GetView(), indexBuffer->GetView(), &Wt);

}

void Sprite2D::SetTexture(uint32_t handle)
{
	tex = TextureManager::GetTextureData(handle);
}



void Sprite2D::CreateVertexIndexBuffer()
{
	vertexBuffer = make_unique<VertexBuffer>();
	vertexBuffer->Create(device, 4, sizeof(VertexPos));

	indexBuffer = make_unique<IndexBuffer>();
	indexBuffer->Create(device, 6);
}



============================================================
File Path: SourceCode/Engine/Draw/2D/Sprite2D.h
============================================================
#pragma once
#include"SpriteCommon.h"
#include"WorldTronsform.h"
#include <DirectXTex.h>
#include"TextureManager.h"
#include"IndexBuffer.h"
#include"VertexBuffer.h"
#include"Vector2.h"
class Sprite2D
{
public:

    struct VertexPos
    {
        Vector3 pos; // xyzåº§æ¨™
        Vector2 uv;
    };

    struct ConstBufferDataMaterial
    {
        Float4 color;
        Matrix4 mat;
    };



    void Initialize(SpriteCommon* _spritecommon,uint32_t handle);

    void Update();

    void Draw(float x, float y, float x2, float y2, Vector2 anchor = { 0.5f,0.5f }, bool flipX = false, bool flipY = false);

    void Draw(Vector2 anchor = { 0.5f,0.5f }, bool flipX = false, bool flipY = false);

    void DrawClip(Vector2 ClipPos, Vector2 ClipSize, bool flipX = false, bool flipY = false);

    void SetTexture(uint32_t handle);
    
    WorldTransform Wt;
protected:

    void CreateVertexIndexBuffer();

    SpriteCommon* spritecommon = nullptr;
    ID3D12Device* device = nullptr;

    std::unique_ptr<VertexBuffer> vertexBuffer = {};

    std::unique_ptr<IndexBuffer> indexBuffer = {};

    TextureData* tex;
   
};

============================================================
File Path: SourceCode/Engine/Draw/2D/SpriteCommon.cpp
============================================================
#include "SpriteCommon.h"
#include"DxWindow.h"
#include<string>
#include <DirectXTex.h>
#include <d3dcompiler.h>

#pragma comment(lib, "d3dcompiler.lib")

using namespace SKNEngine;

void SpriteCommon::Initialize(DirectXCommon* _dxcommon)
{
	this->dxcommon = _dxcommon;

	spritepipline = Pipeline::CreateSpritePipline(dxcommon->GetDevice());

	matProjection = Matrix4::OrthoGraphicProjection(0.0f, DxWindow::window_width, 0.0f, DxWindow::window_height,  0.0f, 1.0f);

}

void SpriteCommon::PreDraw()
{
	commandList = dxcommon->GetCommandList();

	dxcommon->GetCommandList()->SetPipelineState(spritepipline.pipelineState.Get());
	dxcommon->GetCommandList()->SetGraphicsRootSignature(spritepipline.rootSignature.Get());

}

void SpriteCommon::PostDraw()
{
	commandList = nullptr;
}

void SpriteCommon::DrawCommand(TextureData* textureData,D3D12_VERTEX_BUFFER_VIEW vbView, D3D12_INDEX_BUFFER_VIEW ibView, WorldTransform* wt)
{
	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã®è¨­å®šã‚³ãƒžãƒ³ãƒ‰
	dxcommon->GetCommandList()->IASetVertexBuffers(0, 1, &vbView);

	dxcommon->GetCommandList()->IASetIndexBuffer(&ibView);
	//ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å½¢çŠ¶ã®è¨­å®šã‚³ãƒžãƒ³ãƒ‰
	dxcommon->GetCommandList()->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST); // ä¸‰è§’å½¢ãƒªã‚¹ãƒˆ

	dxcommon->GetCommandList()->SetDescriptorHeaps(1, textureData->srvHeap.GetAddressOf());
	D3D12_GPU_DESCRIPTOR_HANDLE srvGpuHandle = textureData->gpuHandle;

	dxcommon->GetCommandList()->SetGraphicsRootDescriptorTable(1, srvGpuHandle);

	dxcommon->GetCommandList()->SetGraphicsRootConstantBufferView(0, wt->constBuffB0->GetGPUVirtualAddress());

	// æç”»ã‚³ãƒžãƒ³ãƒ‰
	//commandList->DrawInstanced(3, 1, 0, 0); // å…¨ã¦ã®é ‚ç‚¹ã‚’ä½¿ã£ã¦æç”»
	dxcommon->GetCommandList()->DrawIndexedInstanced(6, 1, 0, 0, 0); // å…¨ã¦ã®é ‚ç‚¹ã‚’ä½¿ã£ã¦æç”»

}



============================================================
File Path: SourceCode/Engine/Draw/2D/SpriteCommon.h
============================================================
#pragma once
#include <Windows.h>
#include <wrl.h>
#include <d3d12.h>
#include <DirectXMath.h>
#include"DirectXCommon.h"
#include"WorldTronsform.h"
#include"Pipeline.h"
#include"TextureManager.h"

using namespace DirectX;

using namespace Microsoft::WRL;

class SpriteCommon
{

public:
    void Initialize(SKNEngine::DirectXCommon* _dxcommon);

    //void InitializeGraphicsPipeline();

    void PreDraw();

    void PostDraw();

    void DrawCommand(TextureData* textureData,D3D12_VERTEX_BUFFER_VIEW vbView, D3D12_INDEX_BUFFER_VIEW ibView,WorldTransform* wt);

    SKNEngine::DirectXCommon* GetDirextXCommon() { return dxcommon; }

    Matrix4 Getmat() { return matProjection; }

private:

    SKNEngine::DirectXCommon* dxcommon;

    PipelineSet spritepipline;

    ID3D12GraphicsCommandList* commandList;

    Matrix4 matProjection{};
};

============================================================
File Path: SourceCode/Engine/Draw/3D/Draw3DLine.cpp
============================================================
#include "Draw3DLine.h"
#include<cassert>

ID3D12Device* Draw3DLine::device;
ID3D12GraphicsCommandList* Draw3DLine::cmdList;
PipelineSet Draw3DLine::pipeline;
Camera* Draw3DLine::camera = nullptr;
void Draw3DLine::Init()
{
	wt.CreateConstBuffer(device);
	CreateColorBuff();
	vertexBuffer = std::make_unique<VertexBuffer>();
	vertexBuffer->Create(device, 2, sizeof(VertexPos));
}

void Draw3DLine::Draw(Vector3 startpos, Vector3 endpos)
{
	VertexPos vertices[] =
	{
		{startpos},
		{endpos},
	};

	TransferColor();
	
	wt.UpdateMatrix(camera->getView());

	vertexBuffer->Update(vertices);

	vbView = vertexBuffer->GetView();

	cmdList->SetPipelineState(pipeline.pipelineState.Get());
	cmdList->SetGraphicsRootSignature(pipeline.rootSignature.Get());

	cmdList->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_LINELIST);
	cmdList->IASetVertexBuffers(0, 1, &vbView);

	cmdList->SetGraphicsRootConstantBufferView(0, wt.constBuffB0->GetGPUVirtualAddress());
	cmdList->SetGraphicsRootConstantBufferView(1, constBuffB1->GetGPUVirtualAddress());

	cmdList->DrawInstanced(_countof(vertices), 1, 0, 0);
}

void Draw3DLine::SetDevice(ID3D12Device* _device, ID3D12GraphicsCommandList* _cmdList)
{
	device = _device;
	cmdList = _cmdList;
	CreateGraphicsPipeline();
}

void Draw3DLine::CreateColorBuff()
{
	HRESULT result = S_FALSE;

	D3D12_HEAP_PROPERTIES cbHeapPropB1{};

	cbHeapPropB1.Type = D3D12_HEAP_TYPE_UPLOAD;
	D3D12_RESOURCE_DESC cbResourceDescB1{};
	//ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
	cbResourceDescB1.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
	cbResourceDescB1.Width = (sizeof(Color) + 0xff) & ~0Xff;	//256ãƒã‚¤ãƒˆã‚¢ãƒ©ã‚¤ãƒ¡ãƒ³ãƒˆ
	cbResourceDescB1.Height = 1;
	cbResourceDescB1.DepthOrArraySize = 1;
	cbResourceDescB1.MipLevels = 1;
	cbResourceDescB1.SampleDesc.Count = 1;
	cbResourceDescB1.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;

	//å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®ç”Ÿæˆ
	result = device->CreateCommittedResource(
		&cbHeapPropB1,		//ãƒ’ãƒ¼ãƒ—è¨­å®š
		D3D12_HEAP_FLAG_NONE,
		&cbResourceDescB1,	//ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&constBuffB1)
	);
	assert(SUCCEEDED(result));
}

void Draw3DLine::TransferColor()
{
	HRESULT result = S_FALSE;
	result = constBuffB1->Map(0, nullptr, (void**)&constMap);
	assert(SUCCEEDED(result));
	constMap->color = color;
	constBuffB1->Unmap(0, nullptr);
}


============================================================
File Path: SourceCode/Engine/Draw/3D/Draw3DLine.h
============================================================
#pragma once
#include "Pipeline.h"
#include "VertexBuffer.h"
#include "Camera.h"
#include "WorldTronsform.h"
#include"Pipeline.h"
#include <wrl.h>
#include"myMath.h"
class Draw3DLine
{
public:

	void Init();

	void Draw(Vector3 startpos, Vector3 endpos);

	void SetColor(Float4 _color){color = _color;}

	static void SetDevice(ID3D12Device* _device, ID3D12GraphicsCommandList* _cmdList);

	static void CreateGraphicsPipeline(){pipeline = Pipeline::Create3DLinePipeline(device);}

	static void SetCamera(Camera* _camera){camera = _camera;}


private:
	void CreateColorBuff();

	void TransferColor();

	struct VertexPos
	{
		Vector3 pos; // xyzåº§æ¨™
	};

	struct Color
	{
		Float4 color;
	};

	static ID3D12Device* device;
	static ID3D12GraphicsCommandList* cmdList;
	static PipelineSet pipeline;
	static Camera* camera;

	WorldTransform wt;

	std::unique_ptr<VertexBuffer> vertexBuffer = {};
	D3D12_VERTEX_BUFFER_VIEW vbView;

	ComPtr<ID3D12Resource> constBuffB1;
	Color* constMap = nullptr;

	Float4 color = { 1.0f,1.0f,1.0f,1.0f };

};



============================================================
File Path: SourceCode/Engine/Draw/3D/FbxLoader.cpp
============================================================
#include "FbxLoader.h"
#include<cassert>

const string FbxLoader::baseDirectory = "Resources/";
const string FbxLoader::defaultTextureFileName = "white1x1.png";

using namespace DirectX;

FbxLoader* FbxLoader::GetInstance()
{
    static FbxLoader instance;
    return &instance;
}

void FbxLoader::Initialize(ID3D12Device* _device)
{
    assert(fbxManager == nullptr);
    assert(_device);

    device = _device;

    fbxManager = FbxManager::Create();

    FbxIOSettings* ios = FbxIOSettings::Create(fbxManager, IOSROOT);

    fbxManager->SetIOSettings(ios);

    fbxImpoter = FbxImporter::Create(fbxManager, "");

}

void FbxLoader::Finalize()
{
    fbxImpoter->Destroy();
    fbxManager->Destroy();


}

Model* FbxLoader::LoadModelFlomFile(const string& modelname)
{
    const string directoryPath = baseDirectory + modelname + "/";

    const string fileName = modelname + ".fbx";

    const string fullpath = directoryPath + fileName;

    if (!fbxImpoter->Initialize(fullpath.c_str(), -1, fbxManager->GetIOSettings()))
    {
        assert(0);
    }

    FbxScene* fbxScene = FbxScene::Create(fbxManager, "fbxScene");

    fbxImpoter->Import(fbxScene);

    Model* model = new Model();
    model->name = modelname;

    int nodeCount = fbxScene->GetNodeCount();

    model->nodes.reserve(nodeCount);

    ParseNodeRecursive(model, fbxScene->GetRootNode());

    //fbxScene->Destroy();

    model->fbxScene = fbxScene;

    return model;

}

void FbxLoader::ParseNodeRecursive(Model* model, FbxNode* fbxNode, Node* parent)
{
    model->nodes.emplace_back();
    Node& node = model->nodes.back();

    node.name = fbxNode->GetName();

    FbxDouble3 rotation = fbxNode->LclRotation.Get();
    FbxDouble3 scaling = fbxNode->LclScaling.Get();
    FbxDouble3 translation = fbxNode->LclTranslation.Get();

    node.rotation = { (float)rotation[0],(float)rotation[1],(float)rotation[2] };
    node.scaling = { (float)scaling[0],(float)scaling[1],(float)scaling[2]};
    node.translation = { (float)translation[0],(float)translation[1],(float)translation[2] };

    node.rotation.x = XMConvertToRadians(node.rotation.x);
    node.rotation.y = XMConvertToRadians(node.rotation.y);
    node.rotation.z = XMConvertToRadians(node.rotation.z);


    node.transform = Matrix4();
    node.transform *= Matrix4::Scaling(node.scaling.x, node.scaling.y, node.scaling.z);
    node.transform *= Matrix4::RotationZXY(node.rotation.x, node.rotation.y, node.rotation.z);
    node.transform *= Matrix4::Translation(node.translation.x, node.translation.y, node.translation.z);

    node.globalTransform = node.transform;
    if (parent)
    {
        node.parent = parent;

        node.globalTransform *= parent->globalTransform;
    }

    //FBXãƒŽãƒ¼ãƒ‰ã®ãƒ¡ãƒƒã‚·ãƒ¥æƒ…å ±ã‚’è§£æž
    FbxNodeAttribute* fbxNodeAttribute = fbxNode->GetNodeAttribute();

    if (fbxNodeAttribute)
    {
        if (fbxNodeAttribute->GetAttributeType() == FbxNodeAttribute::eMesh)
        {
            model->meshNode = &node;
            ParseMesh(model, fbxNode);
        }
    }
    //å­ãƒŽãƒ¼ãƒ‰ã«å¯¾ã—ã¦å†å¸°å‘¼ã³å‡ºã—


    for (int i = 0; i < fbxNode->GetChildCount(); i++)
    {
        ParseNodeRecursive(model, fbxNode->GetChild(i), &node);
    }
}

void FbxLoader::ParseMesh(Model* model, FbxNode* fbxNode)
{
    //ãƒŽãƒ¼ãƒ‰ã®ãƒ¡ãƒƒã‚·ãƒ¥ã‚’å–å¾—
    FbxMesh* fbxMesh = fbxNode->GetMesh();
    //é ‚ç‚¹åº§æ¨™èª­ã¿å–ã‚Š
    ParseMeshVertices(model, fbxMesh);
    //é¢ã‚’æ§‹æˆã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿å–ã‚Š
    ParseMeshFaces(model, fbxMesh);
    //ãƒžãƒ†ãƒªã‚¢ãƒ«ã®èª­ã¿å–ã‚Š
    ParseMaterial(model, fbxNode);
    //ã‚¹ã‚­ãƒ‹ãƒ³ã‚°ã®èª­ã¿å–ã‚Š
    ParseSkin(model, fbxMesh);
}

void FbxLoader::ParseMeshVertices(Model* model, FbxMesh* fbxMesh)
{
    auto& vertices = model->vertices;
    //é ‚ç‚¹åº§æ¨™ãƒ‡ãƒ¼ã‚¿ã®æ•°
    const int contorolPointCount = fbxMesh->GetControlPointsCount();
    //å¿…è¦æ•°ã ã‘é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿é…åˆ—ã‚’ç¢ºä¿
    Model::VertexPosNormalUvSkin vert{};
    model->vertices.resize(contorolPointCount, vert);
    //FBXãƒ¡ãƒƒã‚·ãƒ¥ã®é ‚ç‚¹åº§æ¨™é…åˆ—ã‚’å–å¾—
    FbxVector4* pCoord = fbxMesh->GetControlPoints();
    //FBXãƒ¡ãƒƒã‚·ãƒ¥ã®å…¨é ‚ç‚¹åº§æ¨™ã‚’ãƒ¢ãƒ‡ãƒ«å†…ã®é…åˆ—ã«ã‚³ãƒ”ãƒ¼ã™ã‚‹ã€‚
    for (int i = 0; i < contorolPointCount; i++)
    {
        Model::VertexPosNormalUvSkin& vertex = vertices[i];
        //åº§æ¨™ã®ã‚³ãƒ”ãƒ¼
        vertex.pos.x = (float)pCoord[i][0];
        vertex.pos.y = (float)pCoord[i][1];
        vertex.pos.z = (float)pCoord[i][2];
    }

}

void FbxLoader::ParseMeshFaces(Model* model, FbxMesh* fbxMesh)
{
    auto& vertices = model->vertices;
    auto& indices = model->indices;

    assert(indices.size() == 0);
    //é¢ã®æ•°
    const int polygonCount = fbxMesh->GetPolygonCount();
    //UVãƒ‡ãƒ¼ã‚¿ã®æ•°
    const int textureUVCount = fbxMesh->GetTextureUVCount();
    //UVåãƒªã‚¹ãƒˆ
    FbxStringList uvNames;
    fbxMesh->GetUVSetNames(uvNames);
    //é¢ã”ã¨ã®æƒ…å ±èª­ã¿å–ã‚Š
    for (int i = 0; i < polygonCount; i++)
    {
        //é¢ã‚’æ§‹æˆã™ã‚‹é ‚ç‚¹ã®æ•°ã‚’å–å¾—(3ãªã‚‰ä¸‰è§’å½¢ãƒãƒªã‚´ãƒ³)
        const int polygonSize = fbxMesh->GetPolygonSize(i);
        assert(polygonSize <= 4);

        //1é ‚ç‚¹ãšã¤å‡¦ç†
        for (int j = 0; j < polygonSize; j++)
        {
            //FBXé ‚ç‚¹é…åˆ—ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
            int index = fbxMesh->GetPolygonVertex(i, j);
            assert(index >= 0);
            //é ‚ç‚¹æ³•ç·šèª­ã¿è¾¼ã¿
            Model::VertexPosNormalUvSkin& vertex = vertices[index];
            FbxVector4 normal;
            if (fbxMesh->GetPolygonVertexNormal(i, j, normal))
            {
                vertex.normal.x = (float)normal[0];
                vertex.normal.y = (float)normal[1];
                vertex.normal.z = (float)normal[2];
            }
            //ãƒ†ã‚¯ã‚¹ãƒãƒ£UVèª­ã¿è¾¼ã¿
            if (textureUVCount > 0)
            {
                FbxVector2 uvs;
                bool lUnmappedUV;
                //0ç•ªæ±ºã‚æ‰“ã¡
                if (fbxMesh->GetPolygonVertexUV(i, j, uvNames[0], uvs, lUnmappedUV))
                {
                    vertex.uv.x = (float)uvs[0];
                    vertex.uv.y = (float)uvs[1];
                }
                //ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹é…åˆ—ã«é ‚ç‚¹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹è¿½åŠ 
                //3é ‚ç‚¹ç›®ã¾ã§ãªã‚‰
                if (j < 3)
                {
                    //1ç‚¹è¿½åŠ ã—ã€ä»–2ç‚¹ã¨ä¸‰è§’å½¢ã‚’æ§‹ç¯‰ã™ã‚‹
                    indices.push_back(index);
                }
                //4é ‚ç‚¹ç›®
                else
                {
                    //3ç‚¹è¿½åŠ ã—
                    //ã‚·è§’å½¢ã®0,1,2ã®å†…,3,0ã§ä¸‰è§’å½¢ã‚’æ§‹ç¯‰
                    int index2 = indices[indices.size() - 1];
                    int index3 = index;
                    int index0 = indices[indices.size() - 3];

                    indices.push_back(index2);
                    indices.push_back(index3);
                    indices.push_back(index0);

                }
            }

        }

    }
}

void FbxLoader::ParseMaterial(Model* model, FbxNode* fbxNode)
{
    const int materialCount = fbxNode->GetMaterialCount();
    if (materialCount > 0)
    {
        //å…ˆé ­ã®ãƒžãƒ†ãƒªã‚¢ãƒ«ã‚’å–å¾—
        FbxSurfaceMaterial* material = fbxNode->GetMaterial(0);
        //ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’èª­ã¿è¾¼ã‚“ã ã‹ã©ã†ã‹ã‚’è¡¨ã™ãƒ•ãƒ©ã‚°
        bool textureLoaded = false;

        if (material)
        {
            //FbxSurfaceLambertã‚¯ãƒ©ã‚¹ã‹ã©ã†ã‹ã‚’èª¿ã¹ã‚‹
            if (material->GetClassId().Is(FbxSurfaceLambert::ClassId))
            {
                FbxSurfaceLambert* lambert = static_cast<FbxSurfaceLambert*>(material);

                model->material = Model::Material();
                //ç’°å¢ƒåå°„å…‰
                FbxPropertyT<FbxDouble3> ambient = lambert->Ambient;
                model->material.ambient.x = (float)ambient.Get()[0];
                model->material.ambient.y = (float)ambient.Get()[1];
                model->material.ambient.z = (float)ambient.Get()[2];
                //æ‹¡æ•£åå°„å…‰ä¿‚æ•°
                FbxPropertyT<FbxDouble3>diffuse = lambert->Diffuse;
                model->material.diffuse.x = (float)diffuse.Get()[0];
                model->material.diffuse.y = (float)diffuse.Get()[1];
                model->material.diffuse.z = (float)diffuse.Get()[2];
                //ãƒ‡ã‚£ãƒ•ãƒ¼ã‚ºãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’å–ã‚Šå‡ºã™
                const FbxProperty diffuseProperty = material->FindProperty(FbxSurfaceMaterial::sDiffuse);
                if (diffuseProperty.IsValid())
                {
                    const FbxFileTexture* texture = diffuseProperty.GetSrcObject<FbxFileTexture>();
                    if (texture)
                    {
                        const char* filepath = texture->GetFileName();
                        //ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«åæŠ½å‡º
                        string path_str(filepath);
                        string name = ExtractFileName(path_str);
                        //ãƒ†ã‚¯ã‚¹ãƒãƒ£èª­ã¿è¾¼ã¿
                        LoadTexture(model, baseDirectory + model->name + "/" + name);
                        textureLoaded = true;
                    }
                }


            }
        }
        //ãƒ†ã‚¯ã‚¹ãƒãƒ£ãŒãªã„å ´åˆã¯ç™½ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’è²¼ã‚‹
        if (!textureLoaded)
        {
            LoadTexture(model, baseDirectory + defaultTextureFileName);
        }
    }


}

void FbxLoader::ParseSkin(Model* model, FbxMesh* fbxMesh)
{
    FbxSkin* fbxSkin = static_cast<FbxSkin*>(fbxMesh->GetDeformer(0, FbxDeformer::eSkin));

    if (fbxSkin == nullptr)
    {
        for (size_t i = 0; i < model->vertices.size(); i++)
        {
            model->vertices[i].boneIndex[0] = 0;
            model->vertices[i].boneWeight[0] = 1.0f;
        }

        return;
    }

    vector<Model::Bone>& bones = model->bones;

    int clusterCount = fbxSkin->GetClusterCount();
    bones.reserve(clusterCount);

    for (int i = 0; i < clusterCount; i++)
    {
        FbxCluster* fbxCluster = fbxSkin->GetCluster(i);

        const char* boneName = fbxCluster->GetLink()->GetName();

        bones.emplace_back(Model::Bone(boneName));
        Model::Bone& bone = bones.back();

        bone.fbxCluster = fbxCluster;

        FbxAMatrix fbxMat;
        fbxCluster->GetTransformLinkMatrix(fbxMat);

        Matrix4 initialPose;
        ConvertMatrixFromFbx(&initialPose, fbxMat);

        bone.invInitialPose = -initialPose;

    }

    struct WeightSet
    {
        UINT index;
        float weight;
    };

    vector<list<WeightSet>>weightLists(model->vertices.size());

    for (int i = 0; i < clusterCount; i++)
    {
        FbxCluster* fbxCluster = fbxSkin->GetCluster(i);

        int contorolPointIndicesCount = fbxCluster->GetControlPointIndicesCount();

        int* controlPointIndices = fbxCluster->GetControlPointIndices();
        double* controlPointWeights = fbxCluster->GetControlPointWeights();

        for (int j = 0; j < contorolPointIndicesCount; j++)
        {
            int vertIndex = controlPointIndices[j];

            float weight = (float)controlPointWeights[j];

            weightLists[vertIndex].emplace_back(WeightSet{ (UINT)i,weight });
        }
    }

    auto& vertices = model->vertices;

    for (size_t i = 0; i < vertices.size(); i++)
    {
        auto& weightList = weightLists[i];

        weightList.sort([](auto const& lhs, auto const& rhs) {return lhs.weight > rhs.weight; });

        int weightArrayIndex = 0;

        for (auto& WeightSet : weightList)
        {
            vertices[i].boneIndex[weightArrayIndex] = WeightSet.index;
            vertices[i].boneWeight[weightArrayIndex] = WeightSet.weight;

            if (++weightArrayIndex >= Model::MAX_BONE_INDICES)
            {
                float weight = 0.0f;
                for (int j = 1; j < Model::MAX_BONE_INDICES; j++)
                {
                    weight += vertices[i].boneWeight[j];
                }
                vertices[i].boneWeight[0] = 1.0f - weight;
                break;
            }
        }
    }

}

void FbxLoader::LoadTexture(Model* model, const std::string& fullpath)
{
    uint32_t handl = TextureManager::Load(fullpath);

    model->tex = TextureManager::GetTextureData(handl);


}

string FbxLoader::ExtractFileName(const string& path)
{
    size_t pos1;
    //åŒºåˆ‡ã‚Šæ–‡å­—ã€€'\\' ãŒå‡ºã¦ãã‚‹ä¸€ç•ªæœ€å¾Œã®éƒ¨åˆ†ã‚’æ¤œç´¢
    pos1 = path.rfind('\\');
    if (pos1 != string::npos)
    {
        return path.substr(pos1 + 1, path.size() - pos1 - 1);
    }
    //åŒºåˆ‡ã‚Šæ–‡å­— '/' ãŒå‡ºã¦ãã‚‹ä¸€ç•ªæœ€å¾Œã®éƒ¨åˆ†ã‚’æ¤œç´¢
    pos1 = path.rfind('/');
    if (pos1 != string::npos)
    {
        return path.substr(pos1 + 1, path.size() - pos1 - 1);
    }
    return path;
}

void FbxLoader::ConvertMatrixFromFbx(Matrix4* dst, const FbxAMatrix& src)
{
    Matrix4 mat((float)src.Get(0, 0), (float)src.Get(0, 1), (float)src.Get(0, 2), (float)src.Get(0, 3),
                (float)src.Get(1, 0), (float)src.Get(1, 1), (float)src.Get(1, 2), (float)src.Get(1, 3),
                (float)src.Get(2, 0), (float)src.Get(2, 1), (float)src.Get(2, 2), (float)src.Get(2, 3),
                (float)src.Get(3, 0), (float)src.Get(3, 1), (float)src.Get(3, 2), (float)src.Get(3, 3));

    dst = &mat;

}


============================================================
File Path: SourceCode/Engine/Draw/3D/FbxLoader.h
============================================================
#pragma once

#pragma warning(push)
#pragma warning(disable:26495)
#pragma warning(disable:26812)
#pragma warning(disable:26451)
#include <fbxsdk.h>
#pragma warning(pop)


#include <d3d12.h>
#include <d3dx12.h>
#include<string>
#include"Model.h"
#include"TextureManager.h"

using namespace std;

class FbxLoader
{
private:

	using string = std::string;


public:
	/// <summary>
	/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
	/// </summary>
	/// <returns>ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹</returns>
	static FbxLoader* GetInstance();

	void Initialize(ID3D12Device* device);

	void Finalize();

	Model* LoadModelFlomFile(const string& modelname);

	void ParseNodeRecursive(Model* model, FbxNode* fbxNode, Node* parent = nullptr);
	/// <summary>
	/// ãƒ¡ãƒƒã‚·ãƒ¥èª­ã¿å–ã‚Š
	/// </summary>
	/// <param name="model">èª­ã¿è¾¼ã¿å…ˆãƒ¢ãƒ‡ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ</param>
	/// <param name="fbxNode">è§£æžå¯¾è±¡ã®ãƒŽãƒ¼ãƒ‰å¯¾è±¡</param>
	void ParseMesh(Model* model, FbxNode* fbxNode);
	//é ‚ç‚¹åº§æ¨™èª­ã¿è¾¼ã¿
	void ParseMeshVertices(Model* model, FbxMesh* fbxMesh);
	//é¢æƒ…å ±èª­ã¿è¾¼ã¿
	void ParseMeshFaces(Model* model, FbxMesh* fbxMesh);
	//ãƒžãƒ†ãƒªã‚¢ãƒ«èª­ã¿è¾¼ã¿
	void ParseMaterial(Model* model, FbxNode* fbxNode);
	//ã‚¹ã‚­ãƒ‹ãƒ³ã‚°æƒ…å ±ã®èª­ã¿å–ã‚Š
	void ParseSkin(Model* model, FbxMesh* fbxMesh);
	//ãƒ†ã‚¯ã‚¹ãƒãƒ£èª­ã¿è¾¼ã¿
	void LoadTexture(Model* model, const std::string& fullpath);

	static const string baseDirectory;
	//ãƒ‡ã‚£ãƒ¬ã‚¯ãƒªã‚’å«ã‚“ã ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«åã‚’æŠ½å‡ºã™ã‚‹
	string ExtractFileName(const string& path);

	static void ConvertMatrixFromFbx(Matrix4* dst, const FbxAMatrix& src);

private:

	static const string defaultTextureFileName;

	ID3D12Device* device = nullptr;

	FbxManager* fbxManager = nullptr;

	FbxImporter* fbxImpoter = nullptr;

	// privateãªã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ï¼ˆã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
	FbxLoader() = default;
	// privateãªãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ï¼ˆã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
	~FbxLoader() = default;
	// ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ç¦æ­¢ï¼ˆã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
	FbxLoader(const FbxLoader& obj) = delete;
	// ã‚³ãƒ”ãƒ¼ä»£å…¥æ¼”ç®—å­ã‚’ç¦æ­¢ï¼ˆã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
	void operator=(const FbxLoader& obj) = delete;
};

============================================================
File Path: SourceCode/Engine/Draw/3D/Model.cpp
============================================================
#include "Model.h"
#include<cassert>
#include<fstream>
#include<sstream>
#include <DirectXTex.h>


Model::~Model()
{
	fbxScene->Destroy();
}

//void Model::Finalize()
//{
//	fbxScene->Destroy();
//}

void Model::CreateBuffers(ID3D12Device* device)
{
	vertexBuffer = make_unique<VertexBuffer>();
	vertexBuffer->Create(device, vertices.size(), sizeof(VertexPosNormalUvSkin), vertices.data());

	indexBuffer = make_unique<IndexBuffer>();
	indexBuffer->Create(device, indices.size(),indices.data());

	

}

void Model::Draw(ID3D12GraphicsCommandList* cmdList)
{
	vertexBuffer->Update(vertices.data());
	indexBuffer->Update(indices.data());

	vbView = vertexBuffer->GetView();
	ibView = indexBuffer->GetView();

	cmdList->IASetVertexBuffers(0, 1,&vbView);
	cmdList->IASetIndexBuffer(&ibView);

	cmdList->SetDescriptorHeaps(1, tex->srvHeap.GetAddressOf());

	D3D12_GPU_DESCRIPTOR_HANDLE srvGpuHandle = tex->gpuHandle;

	cmdList->SetGraphicsRootDescriptorTable(1, srvGpuHandle);

	cmdList->DrawIndexedInstanced((UINT)indices.size(), 1, 0, 0, 0);

}







/*-----------------------------------------ä»¥ä¸‹OBJ----------------------------------------------------
ID3D12Device* Model::device = nullptr;

Model* Model::LoadFromOBJ(const string& modelname, bool smoothing)
{
    Model* model = new Model();

	model->LoadFromOBJInternal(modelname,smoothing);

	model->CreateBuffers();

    return model;
}

void Model::Draw(ID3D12GraphicsCommandList* commandList, UINT rootParamIndexMaterial)
{
	commandList->IASetVertexBuffers(0, 1, &vbView);

	commandList->IASetIndexBuffer(&ibView);

	commandList->SetGraphicsRootConstantBufferView(rootParamIndexMaterial, constBuffB1->GetGPUVirtualAddress());

	commandList->SetDescriptorHeaps(1, tex->srvHeap.GetAddressOf());

	if (material.textureFilename.size() > 0)
	{
		commandList->SetGraphicsRootDescriptorTable(2, tex->gpuHandle);
	}
	//commandList->SetGraphicsRootDescriptorTable(2, srvGpuHandle);
	commandList->DrawIndexedInstanced((UINT)indices.size(), 1, 0, 0, 0);
}



void Model::LoadFromOBJInternal(const string& modelname, bool smoothing)
{
	HRESULT result;

	ifstream file;
	//file.open("Resources/triangle_tex/triangle_tex.obj");
	//const string modelname = "triangle_mat";
	const string filename = modelname + ".obj";
	const string directoryPath = "Resources/" + modelname + "/";
	file.open(directoryPath + filename);
	assert(!file.fail());

	vector<XMFLOAT3> positions;
	vector<XMFLOAT3> normals;
	vector<XMFLOAT2> texcoords;

	string line;
	while (getline(file, line))
	{

		istringstream line_stream(line);
		string key;
		getline(line_stream, key, ' ');

		if (key == "mtllib")
		{
			string filename;
			line_stream >> filename;

			LoadMaterial(directoryPath, filename);
		}
		if (key == "v")
		{
			XMFLOAT3 position{};
			line_stream >> position.x;
			line_stream >> position.y;
			line_stream >> position.z;
			positions.emplace_back(position);
		}
		if (key == "vt")
		{
			XMFLOAT2 texcoord{};
			line_stream >> texcoord.x;
			line_stream >> texcoord.y;

			texcoord.y = 1.0f - texcoord.y;

			texcoords.emplace_back(texcoord);
		}
		if (key == "vn")
		{
			XMFLOAT3 normal{};
			line_stream >> normal.x;
			line_stream >> normal.y;
			line_stream >> normal.z;

			normals.emplace_back(normal);
		}
		if (key == "f")
		{
			string index_string;
			while (getline(line_stream, index_string, ' '))
			{
				istringstream index_stream(index_string);
				unsigned short indexPosition, indexNormal, indexTexcoord;
				index_stream >> indexPosition;
				index_stream.seekg(1, ios_base::cur);
				index_stream >> indexTexcoord;
				index_stream.seekg(1, ios_base::cur);
				index_stream >> indexNormal;

				VertexPos vertex{};
				vertex.pos = positions[indexPosition - 1];
				vertex.normal = normals[indexNormal - 1];
				vertex.uv = texcoords[indexTexcoord - 1];
				vertices.emplace_back(vertex);
				if (smoothing)
				{
					AddSmoothData(indexPosition, (unsigned short)vertices.size() - 1);
				}

				indices.emplace_back((unsigned short)indices.size());
			}
		}
	}

	file.close();

	if (smoothing)
	{
		CaliculateSmoothedVertexNormals();
	}

	UINT sizeVB = static_cast<UINT>(sizeof(VertexPos) * vertices.size());

	D3D12_HEAP_PROPERTIES heapProp{};
	heapProp.Type = D3D12_HEAP_TYPE_UPLOAD;

	D3D12_RESOURCE_DESC resDesc{};
	resDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
	resDesc.Width = sizeVB;
	resDesc.Height = 1;
	resDesc.DepthOrArraySize = 1;
	resDesc.MipLevels = 1;
	resDesc.SampleDesc.Count = 1;
	resDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;

	result = device->CreateCommittedResource(
		&heapProp,
		D3D12_HEAP_FLAG_NONE,
		&resDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&vertBuff)
	);
	assert(SUCCEEDED(result));


	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã¸ã®ãƒ‡ãƒ¼ã‚¿è»¢é€
	VertexPos* vertMap = nullptr;
	result = vertBuff->Map(0, nullptr, (void**)&vertMap);
	if (SUCCEEDED(result))
	{
		//memcpy(vertMap, vertices, sizeof(vertices));
		copy(vertices.begin(), vertices.end(), vertMap);
		vertBuff->Unmap(0, nullptr);
	}

	vbView.BufferLocation = vertBuff->GetGPUVirtualAddress();
	vbView.SizeInBytes = sizeVB;
	vbView.StrideInBytes = sizeof(vertices[0]);

	//UINT sizeIB = static_cast<UINT>(sizeof(uint16_t) * _countof(indices));
	UINT sizeIB = static_cast<UINT>(sizeof(unsigned short) * indices.size());

	resDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;

	resDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
	resDesc.Width = sizeIB;	//ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æƒ…å ±ãŒå…¥ã‚‹ã‚µã‚¤ã‚º
	resDesc.Height = 1;
	resDesc.DepthOrArraySize = 1;
	resDesc.MipLevels = 1;
	resDesc.SampleDesc.Count = 1;
	resDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;

	result = device->CreateCommittedResource(
		&heapProp,	//ãƒ’ãƒ¼ãƒ—è¨­å®š
		D3D12_HEAP_FLAG_NONE,
		&resDesc,	//ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&indexBuff)
	);

	uint16_t* indexMap = nullptr;
	result = indexBuff->Map(0, nullptr, (void**)&indexMap);
	if (SUCCEEDED(result))
	{
		//memcpy(indexMap, indices, sizeof(indices));
		copy(indices.begin(), indices.end(), indexMap);
		indexBuff->Unmap(0, nullptr);
	}

	ibView.BufferLocation = indexBuff->GetGPUVirtualAddress();
	ibView.Format = DXGI_FORMAT_R16_UINT;
	ibView.SizeInBytes = sizeIB;
}

void Model::LoadMaterial(const string& directoryPath, const string& filename)
{
	ifstream file;
	file.open(directoryPath + filename);
	if (file.fail())
	{
		assert(0);
	}

	string line;
	while (getline(file, line))
	{
		istringstream line_stream(line);
		string key;
		getline(line_stream, key, ' ');

		if (key[0] == '\t')
		{
			key.erase(key.begin());
		}
		if (key == "newmtl")
		{
			line_stream >> material.name;
		}
		if (key == "Ka")
		{
			line_stream >> material.ambient.x;
			line_stream >> material.ambient.y;
			line_stream >> material.ambient.z;
		}
		if (key == "Kd")
		{
			line_stream >> material.diffuse.x;
			line_stream >> material.diffuse.y;
			line_stream >> material.diffuse.z;
		}
		if (key == "Ks")
		{
			line_stream >> material.specular.x;
			line_stream >> material.specular.y;
			line_stream >> material.specular.z;
		}
		if (key == "map_Kd")
		{
			line_stream >> material.textureFilename;
			LoadTexture(directoryPath, material.textureFilename);
		}
	}
	file.close();
}

void Model::LoadTexture(const string& directoryPath, const string& filename)
{
	string filepath = directoryPath + filename;

	uint32_t handl = TextureManager::Load(filepath);

	tex = TextureManager::GetTextureData(handl);
}

void Model::CreateBuffers()
{
	HRESULT result = S_FALSE;

	D3D12_HEAP_PROPERTIES cbHeapPropB1{};

	cbHeapPropB1.Type = D3D12_HEAP_TYPE_UPLOAD;
	D3D12_RESOURCE_DESC cbResourceDescB1{};
	//ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
	cbResourceDescB1.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
	cbResourceDescB1.Width = (sizeof(ConstBufferDataMaterial) + 0xff) & ~0Xff;	//256ãƒã‚¤ãƒˆã‚¢ãƒ©ã‚¤ãƒ¡ãƒ³ãƒˆ
	cbResourceDescB1.Height = 1;
	cbResourceDescB1.DepthOrArraySize = 1;
	cbResourceDescB1.MipLevels = 1;
	cbResourceDescB1.SampleDesc.Count = 1;
	cbResourceDescB1.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;

	//å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®ç”Ÿæˆ
	result = device->CreateCommittedResource(
		&cbHeapPropB1,		//ãƒ’ãƒ¼ãƒ—è¨­å®š
		D3D12_HEAP_FLAG_NONE,
		&cbResourceDescB1,	//ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&constBuffB1)
	);
	assert(SUCCEEDED(result));

	ConstBufferDataMaterial* constMap1 = nullptr;
	result = constBuffB1->Map(0, nullptr, (void**)&constMap1);
	assert(SUCCEEDED(result));
	//constMap->color = color;
	//constMap->mat =matWorld* matView * matProjection;
	//constBuff->Unmap(0, nullptr);
	constMap1->ambient = material.ambient;
	constMap1->diffuse = material.diffuse;
	constMap1->specular = material.specular;
	constMap1->alpha = material.alpha;
	constBuffB1->Unmap(0, nullptr);

}

void Model::AddSmoothData(unsigned short indexPosition, unsigned short indexVertex)
{
	smoothData[indexPosition].emplace_back(indexVertex);
}

void Model::CaliculateSmoothedVertexNormals()
{
	auto itr = smoothData.begin();
	for (; itr != smoothData.end(); ++itr)
	{
		std::vector<unsigned short>& v = itr->second;

		XMVECTOR normal = {};
		for (unsigned short index : v)
		{
			normal += XMVectorSet(vertices[index].normal.x, vertices[index].normal.y, vertices[index].normal.z, 0);
		}
		normal = XMVector3Normalize(normal / (float)v.size());
		for (unsigned short index : v)
		{
			vertices[index].normal = { normal.m128_f32[0],normal.m128_f32[1],normal.m128_f32[2] };
		}

	}
}
*/



============================================================
File Path: SourceCode/Engine/Draw/3D/Model.h
============================================================
#pragma once
#include<string>
#include"DxWindow.h"
#include<vector>
#include <d3d12.h>
#include <wrl.h>
#include"TextureManager.h"
#include"WorldTronsform.h"
#include"IndexBuffer.h"
#include"VertexBuffer.h"
#include <fbxsdk.h>
#include"myMath.h"


using namespace DirectX;

using namespace Microsoft::WRL;

using namespace std;

struct Node
{
	string name;

	Vector3 scaling = { 1,1,1 };

	Vector3 rotation = { 0,0,0 };

	Vector3 translation = { 0,0,0 };

	Matrix4 transform;

	Matrix4 globalTransform;

	Node* parent = nullptr;
};



class Model
{


private:

	

public:

	~Model();

	static const int MAX_BONE_INDICES = 4;
	//é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿æ§‹é€ ä½“
	struct VertexPosNormalUvSkin
	{
		Vector3 pos;	//xyzåº§æ¨™
		Vector3 normal;//æ³•ç·šãƒ™ã‚¯ãƒˆãƒ«
		Vector2 uv;	//uvåº§æ¨™
		UINT boneIndex[MAX_BONE_INDICES];
		float boneWeight[MAX_BONE_INDICES];
	};
	struct Material
	{
		Vector3 ambient;
		Vector3 diffuse;
		Vector3 specular;

		float alpha;
		Material()
		{
			ambient = { 0.3f,0.3f,0.3f };
			diffuse = { 0.0f,0.0f,0.0f };
			specular = { 0.0f,0.0f,0.0f };
			alpha = 1.0f;

		}

	};
	struct Bone
	{
		std::string name;

		Matrix4 invInitialPose;

		FbxCluster* fbxCluster;

		Bone(const std::string& name)
		{
			this->name = name;
		}
	};

	
	

	friend class FbxLoader;
	FbxScene* fbxScene = nullptr;
	
	

	void CreateBuffers(ID3D12Device* device);


	const Matrix4& GetModelTransform() { return meshNode->globalTransform; }
	void Draw(ID3D12GraphicsCommandList* cmdList);
	vector<Bone>& GetBones() { return bones; }
	FbxScene* GetFbxScene() { return fbxScene; }
private:

	string name;

	vector<Node> nodes;

	vector<Bone> bones;



	D3D12_VERTEX_BUFFER_VIEW vbView;
	D3D12_INDEX_BUFFER_VIEW ibView;

	//ãƒ¡ãƒƒã‚·ãƒ¥ã‚’æŒã¤ãƒŽãƒ¼ãƒ‰
	Node* meshNode = nullptr;
	//é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿
	vector<VertexPosNormalUvSkin>vertices;

	Material material;
	//é ‚ç‚¹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹é…åˆ—
	vector<uint32_t> indices;

	//ComPtr<ID3D12Resource> texBuff;

	unique_ptr<VertexBuffer> vertexBuffer = {};

	unique_ptr<IndexBuffer> indexBuffer = {};

	TextureData* tex;

	

};




/*----------------------------ä»¥ä¸‹OBJ------------------------------------------ -
class Model
{

public:

	struct VertexPos
	{
		XMFLOAT3 pos; // xyzåº§æ¨™
		XMFLOAT3 normal;
		XMFLOAT2 uv;
	};


	struct Material
	{
		string name;
		XMFLOAT3 ambient;
		XMFLOAT3 diffuse;
		XMFLOAT3 specular;

		float alpha;
		string textureFilename;

		Material()
		{
			ambient = { 0.06f,0.06f,0.06f };
			diffuse = { 0.8f,0.8f,0.8f };
			specular = { 0.1f,0.1f,0.1f };
			alpha = 1.0f;

		}

	};

	struct ConstBufferDataMaterial
	{
		XMFLOAT3 ambient;
		float pad1;
		XMFLOAT3 diffuse;
		float pad2;
		XMFLOAT3 specular;
		float alpha;
	};


	Material material;

	static Model* LoadFromOBJ(const string& modelname, bool smoothing = false);

	static void SetDevice(ID3D12Device* device) { Model::device = device; }

	void Draw(ID3D12GraphicsCommandList* commandList, UINT rootParamIndexMaterial);

private:

	static ID3D12Device* device;

	void LoadFromOBJInternal(const string& modelname,bool smoothing);

	void LoadMaterial(const string& directoryPath, const string& filename);

	void LoadTexture(const string& directoryPath, const string& filename);

	void CreateBuffers();

	void AddSmoothData(unsigned short indexPosition, unsigned short indexVertex);

	void CaliculateSmoothedVertexNormals();

	vector<unsigned short>indices;
	vector<VertexPos> vertices;

	ComPtr<ID3D12Resource> vertBuff;

	ComPtr<ID3D12Resource> indexBuff;

	ComPtr<ID3D12Resource> texBuff;

	D3D12_VERTEX_BUFFER_VIEW vbView;
	D3D12_INDEX_BUFFER_VIEW ibView;
	
	ComPtr<ID3D12Resource> constBuffB1;

	unordered_map<unsigned short, vector<unsigned short>>smoothData;

	TextureData* tex;
};

*/

============================================================
File Path: SourceCode/Engine/Draw/3D/OBJ3D.cpp
============================================================
#include "OBJ3D.h"
#include"DxWindow.h"
#include<string>
#include <DirectXTex.h>
#include <d3dcompiler.h>
#include<fstream>
#include<sstream>
#include<vector>

using namespace std;

#pragma comment(lib, "d3dcompiler.lib")

ID3D12Device* OBJ3D::device = nullptr;
ID3D12GraphicsCommandList* OBJ3D::commandList;
PipelineSet OBJ3D::ObjPipeline;
LightGroup* OBJ3D::lightGroup = nullptr;



OBJ3D::OBJ3D()
{

	color = { 1,1,1,1 };

	scale = { 1,1,1 };

	rotation = { 0,0,0 };

	position = { 0.0f,0,0 };

	matWorld =Matrix4();
}

void OBJ3D::StaticInitialize(ID3D12Device* _device)
{
	assert(_device);

	OBJ3D::device = _device;
	ObjModel::SetDevice(device);

	ObjPipeline = Pipeline::CreateModelPipline(device);
}

void OBJ3D::PreDraw(ID3D12GraphicsCommandList* cmdList)
{
	commandList = cmdList;

	
}


OBJ3D* OBJ3D::Create()
{
	OBJ3D* obj = new OBJ3D();
	if (obj == nullptr) {
		return nullptr;
	}

	// åˆæœŸåŒ–
	if (!obj->Initialize()) {
		delete obj;
		assert(0);
		return nullptr;
	}

	float scale_val = 10;
	obj->Wt.scale_ = { scale_val ,scale_val ,scale_val };

	return obj;
}

bool OBJ3D::Initialize()
{
	Wt.CreateConstBuffer(device);
	
	return true;
}

void OBJ3D::Update(ViewProjection* camera)
{
	

	Wt.color = color;
	
	Wt.UpdateMatrix(camera);
	
}

void OBJ3D::Draw()
{
	commandList->SetPipelineState(ObjPipeline.pipelineState.Get());
	commandList->SetGraphicsRootSignature(ObjPipeline.rootSignature.Get());
	// ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å½¢çŠ¶ã®è¨­å®šã‚³ãƒžãƒ³ãƒ‰
	commandList->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST); // ä¸‰è§’å½¢ãƒªã‚¹ãƒˆ
	
	if (model == nullptr) return;

	commandList->SetGraphicsRootConstantBufferView(0, Wt.constBuffB0->GetGPUVirtualAddress());
	lightGroup->Draw(commandList, 3);
	model->Draw(commandList, 1);
}



============================================================
File Path: SourceCode/Engine/Draw/3D/OBJ3D.h
============================================================
#pragma once
//å¾Œã€…Objct3Dã‚’æ”¹é€ ã—ã‚¯ãƒ©ã‚¹çµ±åˆäºˆå®š
#include <Windows.h>
#include <wrl.h>
#include <d3d12.h>
#include <DirectXMath.h>
#include"WorldTronsform.h"
#include<vector>
#include<string>
#include"ObjModel.h"
#include"Pipeline.h"
#include"ViewProjection.h"
#include"LightGroup.h"


using namespace DirectX;

using namespace Microsoft::WRL;

using namespace std;


class OBJ3D
{



public:

	OBJ3D();


	static void StaticInitialize(ID3D12Device* device);

	/// <param name="cmdList">æç”»ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆ</param>
	static void PreDraw(ID3D12GraphicsCommandList* cmdList);

	static OBJ3D* Create();

	static void SetLight(LightGroup* light) { OBJ3D::lightGroup = light; }

private:

	static ID3D12Device* device;

	// ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆ
	static ID3D12GraphicsCommandList* commandList;

	static LightGroup* lightGroup;


public:

	void SetModel(ObjModel* _model) { model = _model; }

	bool Initialize();

	void Update(ViewProjection* camera);

	void Draw();

	Float4 color;
					  
	Vector3 scale;
					  
	Vector3 rotation;
					  
	Vector3 position;

	Matrix4 matWorld;

	WorldTransform Wt;
private:
	ComPtr<ID3D12Resource> constBuffB1;

private:

	ObjModel* model = nullptr;



	static PipelineSet ObjPipeline;
	 


};


============================================================
File Path: SourceCode/Engine/Draw/3D/ObjModel.cpp
============================================================
#include "ObjModel.h"
#include "Model.h"
#include<cassert>
#include<fstream>
#include<sstream>
#include <DirectXTex.h>



ID3D12Device* ObjModel::device = nullptr;

ObjModel* ObjModel::LoadFromOBJ(const string& modelname, bool smoothing)
{
	ObjModel* model = new ObjModel();

	model->LoadFromOBJInternal(modelname,smoothing);

	model->CreateBuffers();

	return model;
}

void ObjModel::Draw(ID3D12GraphicsCommandList* commandList, UINT rootParamIndexMaterial)
{
	commandList->IASetVertexBuffers(0, 1, &vbView);

	commandList->IASetIndexBuffer(&ibView);

	commandList->SetGraphicsRootConstantBufferView(rootParamIndexMaterial, constBuffB1->GetGPUVirtualAddress());

	commandList->SetDescriptorHeaps(1, tex->srvHeap.GetAddressOf());

	if (material.textureFilename.size() > 0)
	{
		commandList->SetGraphicsRootDescriptorTable(2, tex->gpuHandle);
	}
	//commandList->SetGraphicsRootDescriptorTable(2, srvGpuHandle);
	commandList->DrawIndexedInstanced((UINT)indices.size(), 1, 0, 0, 0);
}



void ObjModel::LoadFromOBJInternal(const string& modelname, bool smoothing)
{
	HRESULT result;

	ifstream file;
	//file.open("Resources/triangle_tex/triangle_tex.obj");
	//const string modelname = "triangle_mat";
	const string filename = modelname + ".obj";
	const string directoryPath = "Resources/" + modelname + "/";
	file.open(directoryPath + filename);
	assert(!file.fail());

	vector<Vector3> positions;
	vector<Vector3> normals;
	vector<Vector2> texcoords;

	string line;
	while (getline(file, line))
	{

		istringstream line_stream(line);
		string key;
		getline(line_stream, key, ' ');

		if (key == "mtllib")
		{
			string _filename;
			line_stream >> _filename;

			LoadMaterial(directoryPath, _filename);
		}
		if (key == "v")
		{
			Vector3 position;
			line_stream >> position.x;
			line_stream >> position.y;
			line_stream >> position.z;
			positions.emplace_back(position.x, position.y, position.z);
		}
		if (key == "vt")
		{
			Vector2 texcoord;
			line_stream >> texcoord.x;
			line_stream >> texcoord.y;

			texcoord.y = 1.0f - texcoord.y;

			texcoords.emplace_back(texcoord.x,texcoord.y);
		}
		if (key == "vn")
		{
			Vector3 normal;
			line_stream >> normal.x;
			line_stream >> normal.y;
			line_stream >> normal.z;

			normals.emplace_back(normal.x, normal.y, normal.z);
		}
		if (key == "f")
		{
			string index_string;
			while (getline(line_stream, index_string, ' '))
			{
				istringstream index_stream(index_string);
				unsigned short indexPosition, indexNormal, indexTexcoord;
				index_stream >> indexPosition;
				index_stream.seekg(1, ios_base::cur);
				index_stream >> indexTexcoord;
				index_stream.seekg(1, ios_base::cur);
				index_stream >> indexNormal;

				VertexPos vertex{};
				vertex.pos = positions[indexPosition - 1];
				vertex.normal = normals[indexNormal - 1];
				vertex.uv = texcoords[indexTexcoord - 1];
				vertices.emplace_back(vertex);
				if (smoothing)
				{
					AddSmoothData(indexPosition, (unsigned short)vertices.size() - 1);
				}

				indices.emplace_back((unsigned short)indices.size());
			}
		}
	}

	file.close();

	if (smoothing)
	{
		CaliculateSmoothedVertexNormals();
	}

	UINT sizeVB = static_cast<UINT>(sizeof(VertexPos) * vertices.size());

	D3D12_HEAP_PROPERTIES heapProp{};
	heapProp.Type = D3D12_HEAP_TYPE_UPLOAD;

	D3D12_RESOURCE_DESC resDesc{};
	resDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
	resDesc.Width = sizeVB;
	resDesc.Height = 1;
	resDesc.DepthOrArraySize = 1;
	resDesc.MipLevels = 1;
	resDesc.SampleDesc.Count = 1;
	resDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;

	result = device->CreateCommittedResource(
		&heapProp,
		D3D12_HEAP_FLAG_NONE,
		&resDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&vertBuff)
	);
	assert(SUCCEEDED(result));


	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã¸ã®ãƒ‡ãƒ¼ã‚¿è»¢é€
	VertexPos* vertMap = nullptr;
	result = vertBuff->Map(0, nullptr, (void**)&vertMap);
	if (SUCCEEDED(result))
	{
		//memcpy(vertMap, vertices, sizeof(vertices));
		copy(vertices.begin(), vertices.end(), vertMap);
		vertBuff->Unmap(0, nullptr);
	}

	vbView.BufferLocation = vertBuff->GetGPUVirtualAddress();
	vbView.SizeInBytes = sizeVB;
	vbView.StrideInBytes = sizeof(vertices[0]);

	//UINT sizeIB = static_cast<UINT>(sizeof(uint16_t) * _countof(indices));
	UINT sizeIB = static_cast<UINT>(sizeof(unsigned short) * indices.size());

	resDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;

	resDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
	resDesc.Width = sizeIB;	//ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æƒ…å ±ãŒå…¥ã‚‹ã‚µã‚¤ã‚º
	resDesc.Height = 1;
	resDesc.DepthOrArraySize = 1;
	resDesc.MipLevels = 1;
	resDesc.SampleDesc.Count = 1;
	resDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;

	result = device->CreateCommittedResource(
		&heapProp,	//ãƒ’ãƒ¼ãƒ—è¨­å®š
		D3D12_HEAP_FLAG_NONE,
		&resDesc,	//ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&indexBuff)
	);

	uint16_t* indexMap = nullptr;
	result = indexBuff->Map(0, nullptr, (void**)&indexMap);
	if (SUCCEEDED(result))
	{
		//memcpy(indexMap, indices, sizeof(indices));
		copy(indices.begin(), indices.end(), indexMap);
		indexBuff->Unmap(0, nullptr);
	}

	ibView.BufferLocation = indexBuff->GetGPUVirtualAddress();
	ibView.Format = DXGI_FORMAT_R16_UINT;
	ibView.SizeInBytes = sizeIB;
}

void ObjModel::LoadMaterial(const string& directoryPath, const string& filename)
{
	ifstream file;
	file.open(directoryPath + filename);
	if (file.fail())
	{
		assert(0);
	}

	string line;
	while (getline(file, line))
	{
		istringstream line_stream(line);
		string key;
		getline(line_stream, key, ' ');

		if (key[0] == '\t')
		{
			key.erase(key.begin());
		}
		if (key == "newmtl")
		{
			line_stream >> material.name;
		}
		if (key == "Ka")
		{
			line_stream >> material.ambient.x;
			line_stream >> material.ambient.y;
			line_stream >> material.ambient.z;
		}
		if (key == "Kd")
		{
			line_stream >> material.diffuse.x;
			line_stream >> material.diffuse.y;
			line_stream >> material.diffuse.z;
		}
		if (key == "Ks")
		{
			line_stream >> material.specular.x;
			line_stream >> material.specular.y;
			line_stream >> material.specular.z;
		}
		if (key == "map_Kd")
		{
			line_stream >> material.textureFilename;
			//LoadTexture(directoryPath, material.textureFilename);
		}
	}
	file.close();
}

void ObjModel::LoadTexture(const string& directoryPath, const string& filename)
{
	string filepath = directoryPath + filename;

	uint32_t handl = TextureManager::Load(filepath);

	tex = TextureManager::GetTextureData(handl);
}

void ObjModel::CreateBuffers()
{
	HRESULT result = S_FALSE;

	D3D12_HEAP_PROPERTIES cbHeapPropB1{};

	cbHeapPropB1.Type = D3D12_HEAP_TYPE_UPLOAD;
	D3D12_RESOURCE_DESC cbResourceDescB1{};
	//ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
	cbResourceDescB1.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
	cbResourceDescB1.Width = (sizeof(ConstBufferDataMaterial) + 0xff) & ~0Xff;	//256ãƒã‚¤ãƒˆã‚¢ãƒ©ã‚¤ãƒ¡ãƒ³ãƒˆ
	cbResourceDescB1.Height = 1;
	cbResourceDescB1.DepthOrArraySize = 1;
	cbResourceDescB1.MipLevels = 1;
	cbResourceDescB1.SampleDesc.Count = 1;
	cbResourceDescB1.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;

	//å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®ç”Ÿæˆ
	result = device->CreateCommittedResource(
		&cbHeapPropB1,		//ãƒ’ãƒ¼ãƒ—è¨­å®š
		D3D12_HEAP_FLAG_NONE,
		&cbResourceDescB1,	//ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&constBuffB1)
	);
	assert(SUCCEEDED(result));

	ConstBufferDataMaterial* constMap1 = nullptr;
	result = constBuffB1->Map(0, nullptr, (void**)&constMap1);
	assert(SUCCEEDED(result));
	//constMap->color = color;
	//constMap->mat =matWorld* matView * matProjection;
	//constBuff->Unmap(0, nullptr);
	constMap1->ambient = material.ambient;
	constMap1->diffuse = material.diffuse;
	constMap1->specular = material.specular;
	constMap1->alpha = material.alpha;
	constBuffB1->Unmap(0, nullptr);

}

void ObjModel::AddSmoothData(unsigned short indexPosition, unsigned short indexVertex)
{
	smoothData[indexPosition].emplace_back(indexVertex);
}

void ObjModel::CaliculateSmoothedVertexNormals()
{
	auto itr = smoothData.begin();
	for (; itr != smoothData.end(); ++itr)
	{
		std::vector<unsigned short>& v = itr->second;

		XMVECTOR normal = {};
		for (unsigned short index : v)
		{
			normal += XMVectorSet(vertices[index].normal.x, vertices[index].normal.y, vertices[index].normal.z, 0);
		}
		normal = XMVector3Normalize(normal / (float)v.size());
		for (unsigned short index : v)
		{
			vertices[index].normal = { normal.m128_f32[0],normal.m128_f32[1],normal.m128_f32[2] };
		}

	}
}




============================================================
File Path: SourceCode/Engine/Draw/3D/ObjModel.h
============================================================
#pragma once
//å¾Œã€…Modelã‚’æ”¹é€ ã—ã‚¯ãƒ©ã‚¹çµ±åˆäºˆå®š
#include<string>
#include"DxWindow.h"
#include<vector>
#include <d3d12.h>
#include <wrl.h>
#include"TextureManager.h"
#include"WorldTronsform.h"
#include"IndexBuffer.h"
#include"VertexBuffer.h"
#include"Vector2.h"


using namespace DirectX;

using namespace Microsoft::WRL;

using namespace std;


class ObjModel
{

public:

	struct VertexPos
	{
		Vector3 pos; // xyzåº§æ¨™
		Vector3 normal;
		Vector2 uv;
	};


	struct Material
	{
		string name;
		Vector3 ambient;
		Vector3 diffuse;
		Vector3 specular;

		float alpha;
		string textureFilename;

		Material()
		{
			ambient = { 0.3f,0.3f,0.3f };
			diffuse = { 0.0f,0.0f,0.0f };
			specular = { 0.0f,0.0f,0.0f };
			alpha = 1.0f;

		}

	};

	struct ConstBufferDataMaterial
	{
		Vector3 ambient;
		float pad1;
		Vector3 diffuse;
		float pad2;
		Vector3 specular;
		float alpha;
	};


	Material material;

	static ObjModel* LoadFromOBJ(const string& modelname, bool smoothing = false);

	static void SetDevice(ID3D12Device* _device) { ObjModel::device = _device; }

	void Draw(ID3D12GraphicsCommandList* commandList, UINT rootParamIndexMaterial);

private:

	static ID3D12Device* device;

	void LoadFromOBJInternal(const string& modelname,bool smoothing);

	void LoadMaterial(const string& directoryPath, const string& filename);

	void LoadTexture(const string& directoryPath, const string& filename);

	void CreateBuffers();

	void AddSmoothData(unsigned short indexPosition, unsigned short indexVertex);

	void CaliculateSmoothedVertexNormals();

	vector<unsigned short>indices;
	vector<VertexPos> vertices;

	ComPtr<ID3D12Resource> vertBuff;

	ComPtr<ID3D12Resource> indexBuff;

	ComPtr<ID3D12Resource> texBuff;

	D3D12_VERTEX_BUFFER_VIEW vbView;
	D3D12_INDEX_BUFFER_VIEW ibView;

	ComPtr<ID3D12Resource> constBuffB1;

	unordered_map<unsigned short, vector<unsigned short>>smoothData;

	TextureData* tex;
};



============================================================
File Path: SourceCode/Engine/Draw/3D/Object3D.cpp
============================================================
#include"Object3D.h"
#include"DxWindow.h"
#include<string>
#include <DirectXTex.h>
#include <d3dcompiler.h>
#include<fstream>
#include<sstream>
#include<vector>

#include <FbxLoader.h>


using namespace std;

#pragma comment(lib, "d3dcompiler.lib")

ID3D12Device* Object3D::device = nullptr;
ViewProjection* Object3D::camera = nullptr;
PipelineSet Object3D::fbxPipeline;

//ID3D12GraphicsCommandList* Object3D::commandList;
//PipelineSet Object3D::ObjPipeline;
//LightGroup* Object3D::lightGroup = nullptr;
//
//Object3D::Object3D(WorldTransform* wt)
//{
//	Wt = wt;
//
//	color = { 1,1,1,1 };
//
//	scale = { 1,1,1 };
//
//	rotation = { 0,0,0 };
//
//	position = { 0.0f,0,0 };
//
//	matWorld = XMMatrixIdentity();
//}
//
//void Object3D::StaticInitialize(ID3D12Device* device, int window_width, int window_height)
//{
//	assert(device);
//
//	Object3D::device = device;
//	Model::SetDevice(device);
//
//	ObjPipeline = Pipeline::CreateModelPipline(device);
//}
//
//void Object3D::PreDraw(ID3D12GraphicsCommandList* cmdList)
//{
//	commandList = cmdList;
//
//	commandList->SetPipelineState(ObjPipeline.pipelineState.Get());
//	commandList->SetGraphicsRootSignature(ObjPipeline.rootSignature.Get());
//	// ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å½¢çŠ¶ã®è¨­å®šã‚³ãƒžãƒ³ãƒ‰
//	commandList->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST); // ä¸‰è§’å½¢ãƒªã‚¹ãƒˆ
//}
//
//void Object3D::PostDraw()
//{
//	Object3D::commandList = nullptr;
//}
//
//Object3D* Object3D::Create(WorldTransform* wt)
//{
//	// Spriteã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆ
//	Object3D* obj = new Object3D(wt);
//	if (obj == nullptr) {
//		return nullptr;
//	}
//
//	// åˆæœŸåŒ–
//	if (!obj->Initialize()) {
//		delete obj;
//		assert(0);
//		return nullptr;
//	}
//
//	float scale_val = 10;
//	obj->Wt->scale_ = { scale_val ,scale_val ,scale_val };
//
//	return obj;
//}
//
//bool Object3D::Initialize()
//{
//	Wt->CreateConstBuffer(device);
//	
//	return true;
//}
//
//void Object3D::Update(ViewProjection* camera)
//{
//	
//	Wt->Map();
//
//	Wt->color = color;
//	
//	Wt->UpdateMatrix(camera->GetMAtView(), camera->GetMatProjection(),camera->Geteye());
//	
//}
//
//void Object3D::Draw()
//{
//	
//	if (model == nullptr) return;
//
//	commandList->SetGraphicsRootConstantBufferView(0, this->Wt->constBuffB0->GetGPUVirtualAddress());
//	lightGroup->Draw(commandList, 3);
//	model->Draw(commandList, 1);
//}

void Object3D::CreateGraphicsPipeline()
{
	fbxPipeline = Pipeline::CreateFBXPipeline(device);
}

void Object3D::Initilaize(WorldTransform* Wt)
{
	wt = Wt;
	wt->CreateConstBuffer(device);

	HRESULT result;

	D3D12_HEAP_PROPERTIES cbHeapPropB1{};

	cbHeapPropB1.Type = D3D12_HEAP_TYPE_UPLOAD;
	D3D12_RESOURCE_DESC cbResourceDescB1{};
	//ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
	cbResourceDescB1.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
	cbResourceDescB1.Width = (sizeof(ConstBufferDataSkin) + 0xff) & ~0Xff;	//256ãƒã‚¤ãƒˆã‚¢ãƒ©ã‚¤ãƒ¡ãƒ³ãƒˆ
	cbResourceDescB1.Height = 1;
	cbResourceDescB1.DepthOrArraySize = 1;
	cbResourceDescB1.MipLevels = 1;
	cbResourceDescB1.SampleDesc.Count = 1;
	cbResourceDescB1.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;

	//å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®ç”Ÿæˆ
	result = device->CreateCommittedResource(
		&cbHeapPropB1,		//ãƒ’ãƒ¼ãƒ—è¨­å®š
		D3D12_HEAP_FLAG_NONE,
		&cbResourceDescB1,	//ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&constBuffSkin)
	);

	ConstBufferDataSkin* constMapSkin = nullptr;
	result = constBuffSkin->Map(0, nullptr, (void**)&constMapSkin);
	for (int i = 0; i < MAX_BONES; i++)
	{
		constMapSkin->bones[i] = Matrix4();
	}
	constBuffSkin->Unmap(0, nullptr);
	frameTime.SetTime(0, 0, 0, 1, 0, FbxTime::EMode::eFrames60);
}

void Object3D::Update()
{

	HRESULT result;


	wt->UpdateMatrix(camera);

	vector<Model::Bone>& bones = model->GetBones();

	ConstBufferDataSkin* constMapSkin = nullptr;
	
	result = constBuffSkin->Map(0, nullptr, (void**)&constMapSkin);

	if (isPlay)
	{
		currentTime += frameTime;
		if (currentTime > endTime)
		{
			currentTime = startTime;
		}
	}

	for (size_t i = 0; i < bones.size(); i++)
	{
		Matrix4 matCurrentPose;

		FbxAMatrix fbxCurrentPose = bones[i].fbxCluster->GetLink()->EvaluateGlobalTransform(currentTime);

		FbxLoader::ConvertMatrixFromFbx(&matCurrentPose, fbxCurrentPose);

		constMapSkin->bones[i] = bones[i].invInitialPose * matCurrentPose;
	}
	constBuffSkin->Unmap(0, nullptr);

}

void Object3D::SetModel(Model* _model)
{
	model = _model;
	model->CreateBuffers(device);
}

void Object3D::PlayAnimation()
{
	FbxScene* fbxScene = model->GetFbxScene();

	FbxAnimStack* animstack = fbxScene->GetSrcObject<FbxAnimStack>(0);

	const char* animstackname = animstack->GetName();

	FbxTakeInfo* takeinfo = fbxScene->GetTakeInfo(animstackname);

	startTime = takeinfo->mLocalTimeSpan.GetStart();

	endTime = takeinfo->mLocalTimeSpan.GetStop();

	currentTime = startTime;

	isPlay = true;

}

void Object3D::Draw(ID3D12GraphicsCommandList* cmdList)
{
	if (model == nullptr)
	{
		return;
	}

	cmdList->SetPipelineState(fbxPipeline.pipelineState.Get());

	cmdList->SetGraphicsRootSignature(fbxPipeline.rootSignature.Get());

	cmdList->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

	cmdList->SetGraphicsRootConstantBufferView(0, wt->constBuffB0->GetGPUVirtualAddress());
	cmdList->SetGraphicsRootConstantBufferView(2, constBuffSkin->GetGPUVirtualAddress());
	model->Draw(cmdList);
}


============================================================
File Path: SourceCode/Engine/Draw/3D/Object3D.h
============================================================
#pragma once
#include <Windows.h>
#include <wrl.h>
#include <d3d12.h>
#include"WorldTronsform.h"
#include<vector>
#include<string>
#include"Model.h"
#include"Pipeline.h"
#include"ViewProjection.h"
#include"LightGroup.h"
#include"Matrix4.h"


using namespace DirectX;

using namespace Microsoft::WRL;

using namespace std;


class Object3D
{
public:

	static const int MAX_BONES = 32;

	ComPtr<ID3D12Resource> constBuffSkin;

	struct ConstBufferDataSkin
	{
		Matrix4 bones[MAX_BONES];
	};

	static void SetDevice(ID3D12Device* Device) { Object3D::device = Device; }
	static void SetCamera(ViewProjection* Camera) { Object3D::camera = Camera; }
	static void CreateGraphicsPipeline();

	void Initilaize(WorldTransform* Wt);

	void Update();

	void Draw(ID3D12GraphicsCommandList* cmdList);

	void SetModel(Model* model);

	void PlayAnimation();

private:

	static ID3D12Device* device;

	static ViewProjection* camera;

	static PipelineSet fbxPipeline;

	FbxTime frameTime;

	FbxTime startTime;

	FbxTime endTime;

	FbxTime currentTime;

	bool isPlay = false;
protected:
	WorldTransform* wt = nullptr;

	Model* model = nullptr;

};



//class Object3D
//{
//
//
//
//public:
//
//	Object3D(WorldTransform* wt);
//
//	static void StaticInitialize(ID3D12Device* device, int window_width, int window_height);
//
//	/// <param name="cmdList">æç”»ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆ</param>
//	static void PreDraw(ID3D12GraphicsCommandList* cmdList);
//
//	/// <summary>
//	/// æç”»å¾Œå‡¦ç†
//	/// </summary>
//	static void PostDraw();
//
//	static Object3D* Create(WorldTransform* wt);
//
//	static void SetLight(LightGroup* light) { Object3D::lightGroup = light; }
//
//private:
//
//	static ID3D12Device* device;
//
//	// ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆ
//	static ID3D12GraphicsCommandList* commandList;
//
//	static LightGroup* lightGroup;
//
//
//public:
//
//	void SetModel(Model* model) { this->model = model; }
//
//	bool Initialize();
//
//	void Update(ViewProjection* camera);
//
//	void Draw();
//
//	XMFLOAT4 color;
//					  
//	XMFLOAT3 scale;
//					  
//	XMFLOAT3 rotation;
//					  
//	XMFLOAT3 position;
//
//	XMMATRIX matWorld;
//
//	WorldTransform* Wt;
//private:
//	ComPtr<ID3D12Resource> constBuffB1;
//
//private:
//
//	Model* model = nullptr;
//
//
//
//	static PipelineSet ObjPipeline;
//	 
//
//
//};
//


============================================================
File Path: SourceCode/Engine/Draw/ParticleManager.cpp
============================================================
#include "ParticleManager.h"
ID3D12Device* ParticleManager::device = nullptr;
ID3D12GraphicsCommandList* ParticleManager::commandList;
PipelineSet ParticleManager::ParPipeline;
ComPtr<ID3D12Resource> ParticleManager::vertBuff;
D3D12_VERTEX_BUFFER_VIEW ParticleManager::vbView{};
ParticleManager::VertexPos ParticleManager::vertices[vertexCount];



ParticleManager::ParticleManager(uint32_t handle)
{
	tex = TextureManager::GetTextureData(handle);
}

void ParticleManager::StaticInitialize(ID3D12Device* _device)
{
	assert(_device);
	ParticleManager::device = _device;
	ParPipeline = Pipeline::CreateParticlePipline(device);
	CreateModel();

}

void ParticleManager::PreDraw(ID3D12GraphicsCommandList* cmdList)
{
	commandList = cmdList;

	commandList->SetPipelineState(ParPipeline.pipelineState.Get());
	commandList->SetGraphicsRootSignature(ParPipeline.rootSignature.Get());
	// ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å½¢çŠ¶ã®è¨­å®šã‚³ãƒžãƒ³ãƒ‰
	commandList->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_POINTLIST); // ä¸‰è§’å½¢ãƒªã‚¹ãƒˆ
}

void ParticleManager::PostDraw()
{
	ParticleManager::commandList = nullptr;
}

void ParticleManager::CreateModel()
{
	HRESULT result = S_FALSE;

	vector<VertexPos> realVertices;


	unsigned short indicesSquare[] = {
		0,1,2,
		2,1,3,
	};

	//std::copy(std::begin(indicesSquare), std::end(indicesSquare), indices);

	UINT sizeVB = static_cast<UINT>(sizeof(vertices));

	D3D12_HEAP_PROPERTIES heapProp{};
	heapProp.Type = D3D12_HEAP_TYPE_UPLOAD;

	D3D12_RESOURCE_DESC resDesc{};
	resDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
	resDesc.Width = sizeVB;
	resDesc.Height = 1;
	resDesc.DepthOrArraySize = 1;
	resDesc.MipLevels = 1;
	resDesc.SampleDesc.Count = 1;
	resDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;

	result = device->CreateCommittedResource(
		&heapProp,
		D3D12_HEAP_FLAG_NONE,
		&resDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&vertBuff)
	);
	assert(SUCCEEDED(result));


	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã¸ã®ãƒ‡ãƒ¼ã‚¿è»¢é€
	VertexPos* vertMap = nullptr;
	result = vertBuff->Map(0, nullptr, (void**)&vertMap);
	if (SUCCEEDED(result))
	{
		memcpy(vertMap, vertices, sizeof(vertices));
		//memcpy(vertMap, vertices, sizeof(vertices));
		vertBuff->Unmap(0, nullptr);
	}

	vbView.BufferLocation = vertBuff->GetGPUVirtualAddress();
	vbView.SizeInBytes = sizeof(vertices);
	vbView.StrideInBytes = sizeof(vertices[0]);
}

ParticleManager* ParticleManager::Create(uint32_t Handle)
{
	// Spriteã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆ
	ParticleManager* pat = new ParticleManager(Handle);

	if (pat == nullptr) {
		return nullptr;
	}

	// åˆæœŸåŒ–
	if (!pat->Initialize()) {
		delete pat;
		assert(0);
		return nullptr;
	}

	return pat;
}

bool ParticleManager::Initialize()
{
	wt.CreateConstBuffer(device);
	
	return true;
}

void ParticleManager::Update(ViewProjection* camera)
{

	HRESULT result;

	particle.remove_if([](Particle& x) {return x.frame >= x.num_frame; });

	for (std::forward_list<Particle>::iterator it = particle.begin(); it != particle.end(); it++)
	{
		it->frame++;

		it->velocity = it->velocity + it->accel;

		it->position = it->position + it->velocity;

		float f = (float)it->frame / it->num_frame;

		it->scale = (it->e_scale - it->s_scale) * f;
		it->scale += it->s_scale;
	}



	VertexPos* vertMap = nullptr;
	result = vertBuff->Map(0, nullptr, (void**)&vertMap);
	if (SUCCEEDED(result))
	{
		for (std::forward_list<Particle>::iterator it = particle.begin(); it != particle.end(); it++)
		{
			vertMap->pos = it->position;

			vertMap->scale = it->scale;

			vertMap++;
		}
		vertBuff->Unmap(0, nullptr);
	}



	wt.UpdateMatrixBill(camera);
}

void ParticleManager::Draw()
{
	commandList->IASetVertexBuffers(0, 1, &vbView);

	commandList->SetDescriptorHeaps(1, tex->srvHeap.GetAddressOf());
	D3D12_GPU_DESCRIPTOR_HANDLE srvGpuHandle = tex->gpuHandle;

	commandList->SetGraphicsRootDescriptorTable(1, srvGpuHandle);

	commandList->SetGraphicsRootConstantBufferView(0, wt.constBuffB0->GetGPUVirtualAddress());

	commandList->DrawInstanced((UINT)std::distance(particle.begin(), particle.end()), 1, 0, 0);

}

void ParticleManager::Add(int life, Vector3 position, Vector3 velocity, Vector3 accel, float start_scale, float end_scale)
{
	particle.emplace_front();

	Particle& p = particle.front();

	p.position = position;
	p.velocity = velocity;
	p.accel = accel;
	p.num_frame = life;
	p.s_scale = start_scale;
	p.e_scale = end_scale;
}




============================================================
File Path: SourceCode/Engine/Draw/ParticleManager.h
============================================================
#pragma once
#include <Windows.h>
#include <wrl.h>
#include <d3d12.h>
#include"WorldTronsform.h"
#include<vector>
#include<string>
#include"Pipeline.h"
#include"ViewProjection.h"
#include<forward_list>
#include"TextureManager.h"
#include<Camera.h>

using namespace DirectX;

using namespace Microsoft::WRL;

using namespace std;

class ParticleManager
{
public:

	ParticleManager(uint32_t handle);
	struct VertexPos
	{
		Vector3 pos; // xyzåº§æ¨™
		float scale;
	};

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ç”¨ãƒ‡ãƒ¼ã‚¿æ§‹é€ ä½“
	struct ConstBufferData
	{
		Matrix4 mat;	// ï¼“ï¼¤å¤‰æ›è¡Œåˆ—
		Matrix4 matBillboard;
	};

	struct Particle
	{
		
		Vector3 position = {};

		Vector3 velocity = {};

		Vector3 accel = {};

		int frame = 0;

		int num_frame = 0;

		float scale = 1.0f;
		float s_scale = 1.0f;
		float e_scale = 0.0f;
	};

	std::forward_list<Particle> particle;

	static void StaticInitialize(ID3D12Device* device);

	static void PreDraw(ID3D12GraphicsCommandList* cmdList);
	
	static void PostDraw();

	static void CreateModel();

	static ParticleManager* Create(uint32_t Handle);

	bool Initialize();

	void Update(ViewProjection* camera);

	void Draw();

	void Add(int life, Vector3 position, Vector3 velocity, Vector3 accel, float start_scale, float end_scale);

private:
	static ID3D12Device* device;

	static ID3D12GraphicsCommandList* commandList;

	static PipelineSet ParPipeline;

	static const int vertexCount = 1024;

	static VertexPos vertices[vertexCount];

	static ComPtr<ID3D12Resource> vertBuff;
	static D3D12_VERTEX_BUFFER_VIEW vbView;

	TextureData* tex;

	WorldTransform wt;
	
};


============================================================
File Path: SourceCode/Engine/Draw/PostEffect.cpp
============================================================
#include "PostEffect.h"
#include <d3dx12.h>
#include "DxWindow.h"
#include<cassert>

using namespace SKNEngine;
using namespace DirectX;

const float PostEffect::clearcolor[4] = { 0.0f,0.0f,0.0f,0.0f };
PipelineSet PostEffect::pipeline;
DirectXCommon* PostEffect::dxCommon = nullptr;

void PostEffect::CreateGraphicsPipeline()
{
	pipeline = Pipeline::CreatePostEffectPipeline(dxCommon->GetDevice());
}

void PostEffect::Initialize()
{
	//Sprite2D::Initialize(spritecommon, wt, a);

	CreateBuffer();

	//Wt->CreateConstBuffer(dxCommon->GetDevice());

	CreateTexBuff();

	CreateSRV();

	CreateRTV();
	
	CreateDepth();
	
	CreateDSV();

	


}

void PostEffect::PreDrawScene(ID3D12GraphicsCommandList* cmdlist)
{
	auto barrier = CD3DX12_RESOURCE_BARRIER::Transition(TexBuff.Get(),
		D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE,
		D3D12_RESOURCE_STATE_RENDER_TARGET);

	cmdlist->ResourceBarrier(1, &barrier);

	D3D12_CPU_DESCRIPTOR_HANDLE rtvH = rtvHeap->GetCPUDescriptorHandleForHeapStart();

	D3D12_CPU_DESCRIPTOR_HANDLE dsvH = dsvHeap->GetCPUDescriptorHandleForHeapStart();

	cmdlist->OMSetRenderTargets(1, &rtvH, false, &dsvH);

	auto viewport = CD3DX12_VIEWPORT(0.0f, 0.0f, DxWindow::window_width, DxWindow::window_height);

	cmdlist->RSSetViewports(1, &viewport);

	auto scissorRects = CD3DX12_RECT(0, 0, DxWindow::window_width, DxWindow::window_height);

	cmdlist->RSSetScissorRects(1, &scissorRects);

	cmdlist->ClearRenderTargetView(rtvH, clearcolor, 0, nullptr);

	cmdlist->ClearDepthStencilView(dsvH, D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr);


}

void PostEffect::PostDrawScene(ID3D12GraphicsCommandList* cmdlist)
{
	auto barrier = CD3DX12_RESOURCE_BARRIER::Transition(TexBuff.Get(),
		D3D12_RESOURCE_STATE_RENDER_TARGET,
		D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE);

	cmdlist->ResourceBarrier(1, &barrier);
}

void PostEffect::Draw(ID3D12GraphicsCommandList* cmdlist)
{
	
	VertexPos vertices[] =
	{
		{{-1.0f,-1.0f,0.0f},{0.0f,1.0f}	},
		{{-1.0f,+1.0f,0.0f},{0.0f,0.0f}	},
		{{+1.0f,-1.0f,0.0f},{1.0f,1.0f}	},
		{{+1.0f,+1.0f,0.0f},{1.0f,0.0f}}
	};
	
	uint32_t indices[] =
	{
		1,0,3,
		2,3,0,
	};

	vertexBuffer->Update(vertices);

	indexBuffer->Update(indices);

	D3D12_VERTEX_BUFFER_VIEW vbView = vertexBuffer->GetView();

	D3D12_INDEX_BUFFER_VIEW ibView = indexBuffer->GetView();

	cmdlist->SetPipelineState(pipeline.pipelineState.Get());
	cmdlist->SetGraphicsRootSignature(pipeline.rootSignature.Get());

	//spritecommon->DrawCommand(tex, vertexBuffer->GetView(), indexBuffer->GetView(), Wt);

	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã®è¨­å®šã‚³ãƒžãƒ³ãƒ‰
	cmdlist->IASetVertexBuffers(0, 1, &vbView);

	cmdlist->IASetIndexBuffer(&ibView);
	//ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å½¢çŠ¶ã®è¨­å®šã‚³ãƒžãƒ³ãƒ‰
	cmdlist->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST); // ä¸‰è§’å½¢ãƒªã‚¹ãƒˆ

	//cmdlist->SetDescriptorHeaps(1, dxCommon->GetDescriptorHeap()->GetHeap().GetAddressOf());
	D3D12_GPU_DESCRIPTOR_HANDLE srvGpuHandle = gpuHandle;

	cmdlist->SetGraphicsRootDescriptorTable(1, srvGpuHandle);

	cmdlist->SetGraphicsRootConstantBufferView(0, constBuff->GetGPUVirtualAddress());

	// æç”»ã‚³ãƒžãƒ³ãƒ‰
	cmdlist->DrawIndexedInstanced(6, 1, 0, 0, 0); // å…¨ã¦ã®é ‚ç‚¹ã‚’ä½¿ã£ã¦æç”»
}

void PostEffect::CreateRTV()
{

	D3D12_DESCRIPTOR_HEAP_DESC rtvDescHeapDesc{};

	rtvDescHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;
	rtvDescHeapDesc.NumDescriptors = 1;

	HRESULT result;
	result = dxCommon->GetDevice()->CreateDescriptorHeap(&rtvDescHeapDesc, IID_PPV_ARGS(&rtvHeap));
	assert(SUCCEEDED(result));

	D3D12_RENDER_TARGET_VIEW_DESC renderTargetViewDesc{};

	renderTargetViewDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
	renderTargetViewDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2D;

	dxCommon->GetDevice()->CreateRenderTargetView(TexBuff.Get(), &renderTargetViewDesc, rtvHeap->GetCPUDescriptorHandleForHeapStart());

}

void PostEffect::CreateDSV()
{
	D3D12_DESCRIPTOR_HEAP_DESC DescHeapDesc{};
	DescHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_DSV;
	DescHeapDesc.NumDescriptors = 1;

	HRESULT result;

	result = dxCommon->GetDevice()->CreateDescriptorHeap(&DescHeapDesc, IID_PPV_ARGS(&dsvHeap));

	assert(SUCCEEDED(result));

	D3D12_DEPTH_STENCIL_VIEW_DESC dsvDesc = {};
	dsvDesc.Format = DXGI_FORMAT_D32_FLOAT;
	dsvDesc.ViewDimension = D3D12_DSV_DIMENSION_TEXTURE2D;
	dxCommon->GetDevice()->CreateDepthStencilView(depthBuff.Get(), &dsvDesc, dsvHeap->GetCPUDescriptorHandleForHeapStart());


}

void PostEffect::CreateTexBuff()
{
	HRESULT result;
	texHeapProp.Type = D3D12_HEAP_TYPE_CUSTOM;
	texHeapProp.CPUPageProperty = D3D12_CPU_PAGE_PROPERTY_WRITE_BACK;
	texHeapProp.MemoryPoolPreference = D3D12_MEMORY_POOL_L0;

	D3D12_RESOURCE_DESC rsDesc{};
	rsDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
	rsDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
	rsDesc.Width = DxWindow::window_width;
	rsDesc.Height = DxWindow::window_height;
	rsDesc.DepthOrArraySize = 1;
	rsDesc.MipLevels = 0;
	rsDesc.SampleDesc.Count = 1;
	rsDesc.Flags = D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET;

	auto clearValue = CD3DX12_CLEAR_VALUE(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, clearcolor);

	result = dxCommon->GetDevice()->CreateCommittedResource(
		&texHeapProp,		//ãƒ’ãƒ¼ãƒ—è¨­å®š
		D3D12_HEAP_FLAG_NONE,
		&rsDesc,	//ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
		D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE,
		&clearValue,
		IID_PPV_ARGS(TexBuff.ReleaseAndGetAddressOf())
	);

	const UINT pixelCount = DxWindow::window_width * DxWindow::window_height;

	const UINT rowPitch = sizeof(UINT) * DxWindow::window_width;

	const UINT depthPitch = rowPitch + DxWindow::window_height;

	UINT* img = new UINT[pixelCount];
	for (size_t i = 0; i < pixelCount; i++)
	{
		img[i] = 0xff0000ff;
	}

	result = TexBuff->WriteToSubresource(0, nullptr, img, rowPitch, depthPitch);
	assert(SUCCEEDED(result));
	delete[] img;
}

void PostEffect::CreateSRV()
{
	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc{};
	srvDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;
	srvDesc.Texture2D.MipLevels = 1;

	gpuHandle.ptr = dxCommon->GetDescriptorHeap()->CreateSRV(srvDesc, TexBuff.Get());
}

void PostEffect::CreateDepth()
{
	D3D12_RESOURCE_DESC depthDesc{};
	depthDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
	depthDesc.Format = DXGI_FORMAT_D32_FLOAT;
	depthDesc.Width = DxWindow::window_width;
	depthDesc.Height = DxWindow::window_height;
	depthDesc.DepthOrArraySize = 1;
	depthDesc.MipLevels = 0;
	depthDesc.SampleDesc.Count = 1;
	depthDesc.Flags = D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;

	HRESULT result;

	auto heapProp = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT);

	auto clearValue = CD3DX12_CLEAR_VALUE(DXGI_FORMAT_D32_FLOAT, 1.0f, 0);

	result = dxCommon->GetDevice()->CreateCommittedResource(
		&heapProp,		//ãƒ’ãƒ¼ãƒ—è¨­å®š
		D3D12_HEAP_FLAG_NONE,
		&depthDesc,	//ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
		D3D12_RESOURCE_STATE_DEPTH_WRITE,
		&clearValue,
		IID_PPV_ARGS(&depthBuff)
	);

	assert(SUCCEEDED(result));

}

void PostEffect::CreateBuffer()
{
	vertexBuffer = make_unique<VertexBuffer>();
	vertexBuffer->Create(dxCommon->GetDevice(), 4, sizeof(VertexPos));

	indexBuffer = make_unique<IndexBuffer>();
	indexBuffer->Create(dxCommon->GetDevice(), 6);
	HRESULT result;

	D3D12_HEAP_PROPERTIES cbHeapProp{};

	cbHeapProp.Type = D3D12_HEAP_TYPE_UPLOAD;	//GPUã¸ã®è»¢é€ç”¨

	auto rsDesc = CD3DX12_RESOURCE_DESC::Buffer((sizeof(ConstBufferDataMaterial) + 0xff) & ~0xff);

	//å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®ç”Ÿæˆ
	result = dxCommon->GetDevice()->CreateCommittedResource(
		&cbHeapProp,		//ãƒ’ãƒ¼ãƒ—è¨­å®š
		D3D12_HEAP_FLAG_NONE,
		&rsDesc,	//ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&constBuff)
	);
	assert(SUCCEEDED(result));

	ConstBufferDataMaterial* constMap = nullptr;

	result = constBuff->Map(0, nullptr, (void**)&constMap);
	if (SUCCEEDED(result))
	{
		constMap->color = this->color;
		constMap->mat = Matrix4();
		constBuff->Unmap(0, nullptr);
	}
	
}




============================================================
File Path: SourceCode/Engine/Draw/PostEffect.h
============================================================
#pragma once
#include <TextureManager.h>
#include "WorldTronsform.h"
#include <wrl.h>
#include <DirectXCommon.h>
#include <VertexBuffer.h>
#include <IndexBuffer.h>
#include"TextureManager.h"
#include <Pipeline.h>
#include"Vector2.h"
#include"Vector3.h"
#include"Matrix4.h"
#include"Float4.h"

using namespace Microsoft::WRL;

class PostEffect
{
public:

    //void SetDevice();

    static void CreateGraphicsPipeline();
    static void SetDXCommon(SKNEngine::DirectXCommon* dxcommon) { PostEffect::dxCommon = dxcommon; }

    void Initialize();

    void PreDrawScene(ID3D12GraphicsCommandList* cmdlist);

    void PostDrawScene(ID3D12GraphicsCommandList* cmdlist);

    void Draw(ID3D12GraphicsCommandList* cmdlist);

    void CreateRTV();

    void CreateDSV();

    void CreateTexBuff();

    void CreateSRV();

    void CreateDepth();

    void CreateBuffer();

    //void SetPipeline();


private:

    static const float clearcolor[4];

    struct VertexPos
    {
        Vector3 pos; // xyzåº§æ¨™
        Vector2 uv;
    };

    struct ConstBufferDataMaterial
    {
        Matrix4 mat;
        Float4 color;
    };

    static PipelineSet pipeline;
    static SKNEngine::DirectXCommon* dxCommon;
   

    ComPtr<ID3D12Resource> TexBuff;
    ComPtr <ID3D12DescriptorHeap> srvHeap;
    D3D12_HEAP_PROPERTIES texHeapProp{};

    DescriptorHeap::DescriptorHeapViewHandle handle_;

    D3D12_GPU_DESCRIPTOR_HANDLE gpuHandle{};

    ComPtr<ID3D12Resource> depthBuff;
    
    ComPtr<ID3D12DescriptorHeap> rtvHeap;

    ComPtr<ID3D12DescriptorHeap> dsvHeap;

    std::unique_ptr<VertexBuffer> vertexBuffer = {};

    std::unique_ptr<IndexBuffer> indexBuffer = {};

    // å®šæ•°ãƒãƒƒãƒ•ã‚¡
    ComPtr<ID3D12Resource> constBuff;

    Float4 color = { 1,1,1,1 };

};



============================================================
File Path: SourceCode/Engine/Draw/TextureManager.cpp
============================================================
#include "TextureManager.h"
TextureManager* TextureManager::texManager = nullptr;
vector<string>TextureManager::FilePaths;
unordered_map<string, unique_ptr<TextureData>> TextureManager::texDatas;

using namespace SKNEngine;


void TextureManager::StaticInitialize(DirectXCommon* dxcommon)
{
	dxCommon = dxcommon;

	texHeapProp.Type = D3D12_HEAP_TYPE_CUSTOM;
	texHeapProp.CPUPageProperty = D3D12_CPU_PAGE_PROPERTY_WRITE_BACK;
	texHeapProp.MemoryPoolPreference = D3D12_MEMORY_POOL_L0;

	FilePaths.resize(2056);
}

uint32_t TextureManager::LoadTexture(const string& path)
{
	if (TextureSize > 2056)
	{
		assert(0);
	}

	auto itreter = find_if(texDatas.begin(), texDatas.end(), [&](pair<const string, unique_ptr<TextureData, default_delete<TextureData>>>& ptr)
		{
			return ptr.second->path == path;
		});

	if (itreter == texDatas.end())
	{
		unique_ptr<TextureData> data;

		data.reset(LoadFromTextureData(path));
		data->texHandle = TextureSize;
		data->path = path;

		texDatas[path] = move(data);
		FilePaths[TextureSize] = path;
		uint32_t handl = TextureSize;
		TextureSize++;


		return handl;
	}
	else
	{

		uint32_t modelHandle = texDatas[path]->texHandle;

		return modelHandle;
	}
}

uint32_t TextureManager::Load(const string& path)
{
	return TextureManager::GetInstance()->LoadTexture(path);
}

TextureData* TextureManager::GetTextureData(uint32_t handle)
{
	return texDatas[FilePaths[handle]].get();
}

TextureManager* TextureManager::GetInstance()
{
	if (!texManager)
	{
		texManager = new TextureManager();
	}

	return texManager;
}

void TextureManager::DeleteInstance()
{
	delete texManager;
}

void TextureManager::FileLoad(const string& path, TexMetadata& metadata, ScratchImage& scratchImg)
{
	wchar_t Filepath[256];
	HRESULT result;

	MultiByteToWideChar(CP_ACP, 0, path.c_str(), -1, Filepath, _countof(Filepath));
	
	result = LoadFromWICFile(
		Filepath,
		DirectX::WIC_FLAGS_NONE,
		&metadata, scratchImg);
	assert(SUCCEEDED(result));


}

TextureData* TextureManager::LoadFromTextureData(const string& path)
{
	TextureData* texdata = new TextureData();
	HRESULT result;

	TexMetadata metadata{};
	ScratchImage scratchImg{};
	ScratchImage mipChain{};

	texdata->srvHeap = dxCommon->GetDescriptorHeap()->GetHeap();

	FileLoad(path, metadata, scratchImg);

	
	result = GenerateMipMaps(
		scratchImg.GetImages(), scratchImg.GetImageCount(), scratchImg.GetMetadata(),
		TEX_FILTER_DEFAULT, 0, mipChain);
	if (SUCCEEDED(result)) {
		scratchImg = std::move(mipChain);
		metadata = scratchImg.GetMetadata();
	}

	//èª­ã¿è¾¼ã‚“ã ãƒ‡ã‚£ãƒ•ãƒ¥ãƒ¼ã‚ºãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’SRGBã¨ã—ã¦æ‰±ã†
	metadata.format =MakeSRGB(metadata.format);

	texdata->texBuff = CreateTexBuff(metadata, scratchImg);

	texdata->gpuHandle = CreateSRV(texdata->texBuff.Get(), metadata);

	texdata->width = metadata.width;
	texdata->height = metadata.height;

	return texdata;
}

ComPtr<ID3D12Resource> TextureManager::CreateTexBuff(TexMetadata& metadata, ScratchImage& scratchImg)
{
	ComPtr<ID3D12Resource> texbuff;
	HRESULT result;

	D3D12_RESOURCE_DESC rsDesc{};
	rsDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
	rsDesc.Format = metadata.format;
	rsDesc.Width = metadata.width;
	rsDesc.Height = (UINT)metadata.height;
	rsDesc.DepthOrArraySize = (UINT16)metadata.arraySize;
	rsDesc.MipLevels = (UINT16)metadata.mipLevels;
	rsDesc.SampleDesc.Count = 1;

	result = dxCommon->GetDevice()->CreateCommittedResource(
		&texHeapProp,		//ãƒ’ãƒ¼ãƒ—è¨­å®š
		D3D12_HEAP_FLAG_NONE,
		&rsDesc,	//ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(texbuff.ReleaseAndGetAddressOf())
	);

	for (size_t i = 0; i < metadata.mipLevels; i++) {
		const Image* img = scratchImg.GetImage(i, 0, 0); // ç”Ÿãƒ‡ãƒ¼ã‚¿æŠ½å‡º
		result = texbuff->WriteToSubresource(
			(UINT)i,
			nullptr,              // å…¨é ˜åŸŸã¸ã‚³ãƒ”ãƒ¼
			img->pixels,          // å…ƒãƒ‡ãƒ¼ã‚¿ã‚¢ãƒ‰ãƒ¬ã‚¹
			(UINT)img->rowPitch,  // 1ãƒ©ã‚¤ãƒ³ã‚µã‚¤ã‚º
			(UINT)img->slicePitch // 1æžšã‚µã‚¤ã‚º
		);
		assert(SUCCEEDED(result));
	}

	return texbuff;
}

D3D12_GPU_DESCRIPTOR_HANDLE TextureManager::CreateSRV(ID3D12Resource* texBuff, TexMetadata& metadata)
{
	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc{};
	srvDesc.Format = metadata.format;
	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;
	srvDesc.Texture2D.MipLevels = static_cast<UINT>(metadata.mipLevels);

	D3D12_GPU_DESCRIPTOR_HANDLE srvgpudesc;

	srvgpudesc.ptr = dxCommon->GetDescriptorHeap()->CreateSRV(srvDesc, texBuff);

	return srvgpudesc;
}




============================================================
File Path: SourceCode/Engine/Draw/TextureManager.h
============================================================
#pragma once
#include"DirectXCommon.h"
#include<memory>
#include<DirectXTex.h>
#include<string>
#include <unordered_map>
#include "Float4.h"

using namespace std;

using namespace Microsoft::WRL;

using namespace DirectX;

struct TextureData
{
	ComPtr<ID3D12Resource> texBuff;

	ComPtr <ID3D12DescriptorHeap> srvHeap;

	D3D12_GPU_DESCRIPTOR_HANDLE gpuHandle{};

	size_t width = 0;

	size_t height = 0;

	Float4 color = { 1.0f,1.0f,1.0f,1.0f };

	string path;

	uint32_t texHandle;
};

class TextureManager
{

public:

	void StaticInitialize(SKNEngine::DirectXCommon* dxcommon);
	
	uint32_t LoadTexture(const string& path);

	static uint32_t Load(const string& path);

	static TextureData* GetTextureData(uint32_t handle);

	static TextureManager* GetInstance();

	void DeleteInstance();

private:

	void FileLoad(const string& path, TexMetadata& metadata, ScratchImage& scratchImg);

	TextureData* LoadFromTextureData(const string& path);

	ComPtr<ID3D12Resource>CreateTexBuff(TexMetadata& metadata, ScratchImage& scratchImg);

	D3D12_GPU_DESCRIPTOR_HANDLE CreateSRV(ID3D12Resource* texBuff, TexMetadata& metadata);

	SKNEngine::DirectXCommon* dxCommon;

	static TextureManager* texManager;

	D3D12_HEAP_PROPERTIES texHeapProp{};

	static vector<string>FilePaths;

	static unordered_map<string, unique_ptr<TextureData>> texDatas;

	uint32_t TextureSize;

};



============================================================
File Path: SourceCode/Engine/Light/DirectionLight.cpp
============================================================
#include "DirectionLight.h"
#include<cassert>


ID3D12Device* DirectionLight::device = nullptr;

void DirectionLight::StaticInitialize(ID3D12Device* _device)
{
	assert(!DirectionLight::device);
	assert(_device);
	DirectionLight::device = _device;


}

DirectionLight* DirectionLight::Create()
{
	DirectionLight* instance = new DirectionLight();

	instance->Initialize();

	return instance;
}

void DirectionLight::Initialize()
{
	HRESULT result;
	D3D12_HEAP_PROPERTIES cbHeapProp{};

	cbHeapProp.Type = D3D12_HEAP_TYPE_UPLOAD;	//GPUã¸ã®è»¢é€ç”¨

	D3D12_RESOURCE_DESC cbResourceDesc{};
	//ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
	cbResourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
	cbResourceDesc.Width = (sizeof(ConstBufferData) + 0xff) & ~0Xff;	//256ãƒã‚¤ãƒˆã‚¢ãƒ©ã‚¤ãƒ¡ãƒ³ãƒˆ
	cbResourceDesc.Height = 1;
	cbResourceDesc.DepthOrArraySize = 1;
	cbResourceDesc.MipLevels = 1;
	cbResourceDesc.SampleDesc.Count = 1;
	cbResourceDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;

	//å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®ç”Ÿæˆ
	result = device->CreateCommittedResource(
		&cbHeapProp,		//ãƒ’ãƒ¼ãƒ—è¨­å®š
		D3D12_HEAP_FLAG_NONE,
		&cbResourceDesc,	//ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&constBuff)
	);
	assert(SUCCEEDED(result));

	TransferConstBuffer();

}

void DirectionLight::TransferConstBuffer()
{
	HRESULT result;

	ConstBufferData* constMap = nullptr;

	result = constBuff->Map(0, nullptr, (void**)&constMap);
	if (SUCCEEDED(result))
	{
		constMap->lightv = -lightdir;
		constMap->lightcolor = lightcolor;
		constBuff->Unmap(0, nullptr);
	}



}

void DirectionLight::Update()
{
	if (dirty)
	{
		TransferConstBuffer();
		dirty = false;
	}
}

void DirectionLight::Draw(ID3D12GraphicsCommandList* cmdlist, UINT rootParamIndex)
{
	cmdlist->SetGraphicsRootConstantBufferView(rootParamIndex, constBuff->GetGPUVirtualAddress());
}

void DirectionLight::SetLightDir(const Vector3& _lightdir)
{
	lightdir = _lightdir;
	dirty = true;
}

void DirectionLight::SetLightColor(const Vector3& _lightcolor)
{
	lightcolor = _lightcolor;
	dirty = true;
}


============================================================
File Path: SourceCode/Engine/Light/DirectionLight.h
============================================================
#pragma once
#include <wrl.h>
#include"Matrix4.h"
#include"Vector2.h"
#include"Vector3.h"
#include"Float4.h"
#include <d3d12.h>


class DirectionLight
{
private:

	template<class T>using ComPtr = Microsoft::WRL::ComPtr<T>;

public:

	struct ConstBufferData
	{
		Vector3 lightv;
		Vector3 lightcolor;
		unsigned int active;
	};

	static void StaticInitialize(ID3D12Device* _device);

	static DirectionLight* Create();

	void Initialize();

	void TransferConstBuffer();

	void Update();

	void Draw(ID3D12GraphicsCommandList*cmdlist,UINT rootParamIndex);

	void SetLightDir(const Vector3& _lightdir);

	void SetLightColor(const Vector3& _lightcolor);

	Vector3 GetLightDir() { return lightdir; }

	Vector3 GetLightColor() { return lightcolor; }

	inline void SetActive(bool Active) { this->active = Active; }
	inline bool IsActive() { return active; }

private:



	static ID3D12Device* device;

	ComPtr<ID3D12Resource> constBuff;

	Vector3 lightdir = { 1,0,0};

	Vector3 lightcolor = { 1,1,1 };

	bool dirty = false;

	bool active = false;

};



============================================================
File Path: SourceCode/Engine/Light/LightGroup.cpp
============================================================
#include "LightGroup.h"
#include<cassert>
ID3D12Device* LightGroup::device = nullptr;


void LightGroup::StaticInitialize(ID3D12Device* _device)
{
	assert(!LightGroup::device);

	assert(_device);

	LightGroup::device = _device;
}

LightGroup* LightGroup::Create()
{
	LightGroup* instance = new LightGroup();


	instance->Initialize();

	return instance;
}

void LightGroup::Initialize()
{

	DefaultLightSetting();

	HRESULT result;
	D3D12_HEAP_PROPERTIES cbHeapProp{};

	cbHeapProp.Type = D3D12_HEAP_TYPE_UPLOAD;	

	D3D12_RESOURCE_DESC cbResourceDesc{};
	
	cbResourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
	cbResourceDesc.Width = (sizeof(ConstBufferData) + 0xff) & ~0Xff;	//256ãƒã‚¤ãƒˆã‚¢ãƒ©ã‚¤ãƒ¡ãƒ³ãƒˆ
	cbResourceDesc.Height = 1;
	cbResourceDesc.DepthOrArraySize = 1;
	cbResourceDesc.MipLevels = 1;
	cbResourceDesc.SampleDesc.Count = 1;
	cbResourceDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;

	//å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®ç”Ÿæˆ
	result = device->CreateCommittedResource(
		&cbHeapProp,		//ãƒ’ãƒ¼ãƒ—è¨­å®š
		D3D12_HEAP_FLAG_NONE,
		&cbResourceDesc,	//ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&constBuff)
	);
	assert(SUCCEEDED(result));

	TransferConstBuffer();


}

void LightGroup::Update()
{
	if (dirty)
	{
		TransferConstBuffer();
		dirty = false;
	}

}

void LightGroup::Draw(ID3D12GraphicsCommandList* cmdList, UINT rootParamIndex)
{
	cmdList->SetGraphicsRootConstantBufferView(rootParamIndex, constBuff->GetGPUVirtualAddress());
}

void LightGroup::TransferConstBuffer()
{
	HRESULT result;

	ConstBufferData* constMap = nullptr;

	result = constBuff->Map(0, nullptr, (void**)&constMap);
	if (SUCCEEDED(result))
	{
		constMap->ambientColor = ambientColor;

		for (int i = 0; i < DirLightNum; i++)
		{
			if (dirLights[i].IsActive())
			{
				constMap->dirLights[i].active = 1;
				constMap->dirLights[i].lightv = -dirLights[i].GetLightDir();
				constMap->dirLights[i].lightcolor = dirLights[i].GetLightColor();
			}
			else
			{
				constMap->dirLights[i].active = 0;
			}
		}

		for (int i = 0; i < PointLightNum; i++)
		{
			if (pointLights[i].IsActive())
			{
				constMap->pointLights[i].active = 1;
				constMap->pointLights[i].lightpos = pointLights[i].GetLightPos();
				constMap->pointLights[i].lightcolor = pointLights[i].GetLightColor();
				constMap->pointLights[i].lightatten = pointLights[i].GetLightAtten();
			}
			else
			{
				constMap->pointLights[i].active = 0;
			}
		}


		constBuff->Unmap(0, nullptr);
	}
}

void LightGroup::DefaultLightSetting()
{
	dirLights[0].SetActive(true);
	dirLights[0].SetLightColor({ 1.0f, 1.0f, 1.0f });
	dirLights[0].SetLightDir({ 0.0f, -1.0f, 0.0f });

	dirLights[1].SetActive(true);
	dirLights[1].SetLightColor({ 1.0f, 1.0f, 1.0f });
	dirLights[1].SetLightDir({+0.5f, +0.1f, +0.2f});

	dirLights[2].SetActive(true);
	dirLights[2].SetLightColor({ 1.0f, 1.0f, 1.0f });
	dirLights[2].SetLightDir({ -0.5f, +0.1f, -0.2f });
}

void LightGroup::SetAmbientColor(const Vector3& color)
{
	ambientColor = color;
	dirty = true;
}

void LightGroup::SetDirLightActive(int index, bool active)
{
	assert(0 <= index && index < DirLightNum);

	dirLights[index].SetActive(active);
}

void LightGroup::SetDirLightDir(int index, const Vector3& lightdir)
{
	assert(0 <= index && index < DirLightNum);

	dirLights[index].SetLightDir(lightdir);
	dirty = true;
}

void LightGroup::SetDirLightColor(int index, const Vector3& lightcolor)
{
	assert(0 <= index && index < DirLightNum);

	dirLights[index].SetLightColor(lightcolor);
	dirty = true;
}

void LightGroup::SetPointLightActive(int index, bool active)
{
	assert(0 <= index && index < PointLightNum);
	pointLights[index].SetActive(active);
}

void LightGroup::SetPointLightPos(int index, const Vector3& lightpos)
{
	assert(0 <= index && index < PointLightNum);
	pointLights[index].SetLightPos(lightpos);
	dirty = true;
}

void LightGroup::SetPointLightColor(int index, const Vector3& lightcolor)
{
	assert(0 <= index && index < PointLightNum);
	pointLights[index].SetLightColor(lightcolor);
	dirty = true;
}

void LightGroup::SetPointLightAtten(int index, const Vector3& lightatten)
{
	assert(0 <= index && index < PointLightNum);
	pointLights[index].SetLightAtten(lightatten);
	dirty = true;
}


============================================================
File Path: SourceCode/Engine/Light/LightGroup.h
============================================================
#pragma once
#include <wrl.h>
#include <d3d12.h>
#include"DirectionLight.h"
#include"PointLight.h"

class LightGroup
{
private:
	template<class T>using ComPtr = Microsoft::WRL::ComPtr<T>;

public: 
	static const int DirLightNum = 1;
	static const int PointLightNum = 1;

public: 

	
	struct ConstBufferData
	{
		
		Vector3 ambientColor;
		float pad1;
		DirectionLight::ConstBufferData dirLights[DirLightNum];
		PointLight::ConstBufferData pointLights[PointLightNum];
	};

public: 
	static void StaticInitialize(ID3D12Device* device);

	
	static LightGroup* Create();

private: 
	static ID3D12Device* device;

public: 
	void Initialize();

	
	void Update();

	
	void Draw(ID3D12GraphicsCommandList* cmdList, UINT rootParamIndex);

	
	void TransferConstBuffer();

	
	void DefaultLightSetting();

	
	void SetAmbientColor(const Vector3& color);

	
	void SetDirLightActive(int index, bool active);

	
	void SetDirLightDir(int index, const Vector3& lightdir);

	
	void SetDirLightColor(int index, const Vector3& lightcolor);

	void SetPointLightActive(int index, bool active);

	void SetPointLightPos(int index, const Vector3& lightpos);

	void SetPointLightColor(int index, const Vector3& lightcolor);

	void SetPointLightAtten(int index, const Vector3& lightatten);
private: 
	ComPtr<ID3D12Resource> constBuff;

	
	Vector3 ambientColor = { 1,1,1 };

	
	DirectionLight dirLights[DirLightNum];
	PointLight pointLights[PointLightNum];

	
	bool dirty = false;
};



============================================================
File Path: SourceCode/Engine/Light/PointLight.cpp
============================================================
#include "PointLight.h"


============================================================
File Path: SourceCode/Engine/Light/PointLight.h
============================================================
#pragma once
#include"Vector3.h"

class PointLight
{

public:

	struct ConstBufferData
	{
		Vector3 lightpos;
		float pad1;
		Vector3 lightcolor;
		float pad2;
		Vector3 lightatten;
		unsigned int active;
	};

	inline void SetLightPos(const Vector3& _lightpos) { lightpos = _lightpos; }
	inline const Vector3& GetLightPos() { return lightpos; }
	inline void SetLightColor(const Vector3& _lightcolor) { lightcolor = _lightcolor; }
	inline const Vector3& GetLightColor() { return lightcolor; }
	inline void SetLightAtten(const Vector3& _lightatten) { lightatten = _lightatten; }
	inline const Vector3& GetLightAtten() { return lightatten; }
	inline void SetActive(bool Active) { this->active = Active; }
	inline bool IsActive() { return active; }

private:

	Vector3 lightpos = { 0,0,0 };
	Vector3 lightcolor = { 1,1,1 };
	Vector3 lightatten = { 1.0f,1.0f,1.0f };

	bool active = false;

};



============================================================
File Path: SourceCode/Engine/Math/Easing.cpp
============================================================
#include "Easing.h"

float easeInSine(float start, float end, float movetime, float endtime)
{
	float time = movetime / endtime;
	return start + static_cast<float>((1 - cos((time * PI) / 2))) * (end - start);
}

float easeInQuint(float start, float end, float movetime, float endtime)
{
	float time = movetime / endtime;
	return start + (time * time * time * time * time) * (end - start);
}

float easeOutSine(float start, float end, float movetime, float endtime)
{
	float time = movetime / endtime;
	return start + static_cast<float>(sin((time * PI) / 2)) * (end - start);
}

float easeOutQuint(float start, float end, float movetime, float endtime)
{
	float time = movetime / endtime;

	return start + (1 - static_cast<float>(pow(1 - time, 5))) * (end - start);
}

double EaseInBack(float t, int start, int end, int num, double p1)
{
	const double c1 = p1;
	const double c3 = c1 + 1;

	return (end - start) * pow((c3 * t * t * t - c1 * t * t), num) + start;
}

============================================================
File Path: SourceCode/Engine/Math/Easing.h
============================================================
#pragma once
#include <math.h>
#define PI 3.14f

float easeInSine(float start, float end, float movetime, float endtime);
float easeInQuint(float start, float end, float movetime, float endtime);
float easeOutSine(float start, float end, float movetime, float endtime);
float easeOutQuint(float start, float end, float movetime, float endtime);
double EaseInBack(float t, int start, int end, int num = 1, double p1 = 1.70158);


============================================================
File Path: SourceCode/Engine/Math/Float4.cpp
============================================================
#include "Float4.h"
#include "Vector2.h"
#include "Vector3.h"

Float4::operator Vector2() const
{
    return Vector2(x, y);
}

Float4::operator Vector3() const
{
    return Vector3(x, y, z);
}

Float4 Float4::operator/(const float& s) const
{
	Float4 temp = *this;
	temp.x /= s;
	temp.y /= s;
	temp.z /= s;
	temp.w /= s;
	return temp;
}

Float4& Float4::operator/=(const float& s)
{
	Float4 temp = *this / s;
	*this = temp;
	return *this;
}


============================================================
File Path: SourceCode/Engine/Math/Float4.h
============================================================
#pragma once
#include"Vector3.h"

class Vector2;
class Vector3;

class Float4
{
public:
	float x;
	float y;
	float z;
	float w;

	Float4() : x(0), y(0), z(0), w(0) {}
	Float4(float x, float y, float z, float w) : x(x), y(y), z(z), w(w) {}
	Float4(Vector3 vec,float w):x(vec.x), y(vec.y), z(vec.z), w(w) {}

	//z,wæˆåˆ†ã‚’æ¨ã¦ã¦Vector2ã¸ã‚­ãƒ£ã‚¹ãƒˆ
	operator Vector2() const;

	//wæˆåˆ†ã‚’æ¨ã¦ã¦Vector3ã¸ã‚­ãƒ£ã‚¹ãƒˆ
	operator Vector3() const;

	Float4 operator/(const float& s) const;
	Float4& operator/=(const float& s);
};



============================================================
File Path: SourceCode/Engine/Math/Matrix4.cpp
============================================================
#include "Matrix4.h"
#include "Vector3.h"
#include "Float4.h"
#include <stdexcept>
#include <cmath>

float Matrix4::Row::operator[](const size_t i) const
{
	if (i > 3)
	{
		throw std::out_of_range("æ·»ãˆå­—5ç•ªç›®ä»¥é™desu");
	}
	return c[i];
}

float& Matrix4::Row::operator[](const size_t i)
{
	if (i > 3)
	{
		throw std::out_of_range("æ·»ãˆå­—5ç•ªç›®ä»¥é™desu");
	}
	return c[i];
}

void Matrix4::Row::operator=(const Float4& f)
{
	c[0] = f.x;
	c[1] = f.y;
	c[2] = f.z;
	c[3] = f.w;
}

Matrix4::Matrix4()
{
	m[0][0] = 1;
	m[1][1] = 1;
	m[2][2] = 1;
	m[3][3] = 1;
}

Matrix4::Matrix4(Float4 r0, Float4 r1, Float4 r2, Float4 r3)
{
	m[0] = r0;
	m[1] = r1;
	m[2] = r2;
	m[3] = r3;
}

Matrix4::Matrix4(float r0c0, float r0c1, float r0c2, float r0c3, float r1c0, float r1c1, float r1c2, float r1c3, float r2c0, float r2c1, float r2c2, float r2c3, float r3c0, float r3c1, float r3c2, float r3c3)
{
	m[0][0] = r0c0;
	m[0][1] = r0c1;
	m[0][2] = r0c2;
	m[0][3] = r0c3;
	
	m[1][0] = r1c0;
	m[1][1] = r1c1;
	m[1][2] = r1c2;
	m[1][3] = r1c3;
	
	m[2][0] = r2c0;
	m[2][1] = r2c1;
	m[2][2] = r2c2;
	m[2][3] = r2c3;
	
	m[3][0] = r3c0;
	m[3][1] = r3c1;
	m[3][2] = r3c2;
	m[3][3] = r3c3;
}


Matrix4::Row Matrix4::operator[](const size_t i) const
{
	if (i > 3) {
		throw std::out_of_range("æ·»ãˆå­—5ç•ªç›®ä»¥é™desu");
	}
	return m[i];
}

Matrix4::Row& Matrix4::operator[](const size_t i)
{
	if (i > 3) {
		throw std::out_of_range("æ·»ãˆå­—5ç•ªç›®ä»¥é™desu");
	}
	return m[i];
}

Matrix4 Matrix4::operator-() const
{
	Matrix4 temp;
	float mat[4][8] = {};

	float a;

	for (int32_t i = 0; i < 4; i++) {
		for (int32_t j = 0; j < 4; j++) {
			mat[i][j] = m[i][j];

			if (i == j)mat[i][4 + j] = 1;
		}
	}

	for (int32_t k = 0; k < 4; k++) {
		a = 1 / mat[k][k];

		for (int32_t j = 0; j < 8; j++) {
			mat[k][j] *= a;
		}

		for (int32_t i = 0; i < 4; i++) {
			if (i == k) {
				continue;
			}

			a = -mat[i][k];

			for (int32_t j = 0; j < 8; j++) {
				mat[i][j] += mat[k][j] * a;
			}
		}
	}

	for (int32_t i = 0; i < 4; i++) {
		for (int32_t j = 0; j < 4; j++) {
			temp[i][j] = mat[i][4 + j];
		}
	}
	return temp;
}

Matrix4& Matrix4::Transpose()
{
	for (int32_t i = 0; i < 4; i++)
	{
		for (int32_t j = i; j < 4; j++)
		{
			float f = m[i][j];
			m[i][j] = m[j][i];
			m[j][i] = f;
		}
	}

	return *this;
}

Matrix4 Matrix4::GetTranspose() const
{
	Matrix4 mat;
	for (size_t i = 0; i < 4; i++)
	{
		for (size_t j = 0; j < 4; j++)
		{
			mat[i][j] = m[j][i];
		}
	}
	return mat;
}

Matrix4 Matrix4::operator+(const Matrix4& a) const
{
	return Matrix4(
		m[0][0] + a[0][0],
		m[0][1] + a[0][1],
		m[0][2] + a[0][2],
		m[0][3] + a[0][3],
				  
		m[1][0] + a[1][0],
		m[1][1] + a[1][1],
		m[1][2] + a[1][2],
		m[1][3] + a[1][3],
				  
		m[2][0] + a[2][0],
		m[2][1] + a[2][1],
		m[2][2] + a[2][2],
		m[2][3] + a[2][3],
				  
		m[3][0] + a[3][0],
		m[3][1] + a[3][1],
		m[3][2] + a[3][2],
		m[3][3] + a[3][3]
	);
}

Matrix4& Matrix4::operator+=(const Matrix4& a)
{
	m[0][0] += a[0][0];
	m[0][1] += a[0][1];
	m[0][2] += a[0][2];
	m[0][3] += a[0][3];
			   
	m[1][0] += a[1][0];
	m[1][1] += a[1][1];
	m[1][2] += a[1][2];
	m[1][3] += a[1][3];
			   
	m[2][0] += a[2][0];
	m[2][1] += a[2][1];
	m[2][2] += a[2][2];
	m[2][3] += a[2][3];
			   
	m[3][0] += a[3][0];
	m[3][1] += a[3][1];
	m[3][2] += a[3][2];
	m[3][3] += a[3][3];

	return *this;
}

Matrix4 Matrix4::operator-(const Matrix4& a) const
{
	return Matrix4(
		m[0][0] - a[0][0],
		m[0][1] - a[0][1],
		m[0][2] - a[0][2],
		m[0][3] - a[0][3],

		m[1][0] - a[1][0],
		m[1][1] - a[1][1],
		m[1][2] - a[1][2],
		m[1][3] - a[1][3],

		m[2][0] - a[2][0],
		m[2][1] - a[2][1],
		m[2][2] - a[2][2],
		m[2][3] - a[2][3],

		m[3][0] - a[3][0],
		m[3][1] - a[3][1],
		m[3][2] - a[3][2],
		m[3][3] - a[3][3]
	);
}

Matrix4& Matrix4::operator-=(const Matrix4& a)
{
	m[0][0] -= a[0][0];
	m[0][1] -= a[0][1];
	m[0][2] -= a[0][2];
	m[0][3] -= a[0][3];

	m[1][0] -= a[1][0];
	m[1][1] -= a[1][1];
	m[1][2] -= a[1][2];
	m[1][3] -= a[1][3];

	m[2][0] -= a[2][0];
	m[2][1] -= a[2][1];
	m[2][2] -= a[2][2];
	m[2][3] -= a[2][3];

	m[3][0] -= a[3][0];
	m[3][1] -= a[3][1];
	m[3][2] -= a[3][2];
	m[3][3] -= a[3][3];

	return *this;
}

Matrix4 Matrix4::operator*(const Matrix4& a) const
{
	return Matrix4(
		m[0][0] * a[0][0] + m[0][1] * a[1][0] + m[0][2] * a[2][0] + m[0][3] * a[3][0],
		m[0][0] * a[0][1] + m[0][1] * a[1][1] + m[0][2] * a[2][1] + m[0][3] * a[3][1],
		m[0][0] * a[0][2] + m[0][1] * a[1][2] + m[0][2] * a[2][2] + m[0][3] * a[3][2],
		m[0][0] * a[0][3] + m[0][1] * a[1][3] + m[0][2] * a[2][3] + m[0][3] * a[3][3],

		m[1][0] * a[0][0] + m[1][1] * a[1][0] + m[1][2] * a[2][0] + m[1][3] * a[3][0],
		m[1][0] * a[0][1] + m[1][1] * a[1][1] + m[1][2] * a[2][1] + m[1][3] * a[3][1],
		m[1][0] * a[0][2] + m[1][1] * a[1][2] + m[1][2] * a[2][2] + m[1][3] * a[3][2],
		m[1][0] * a[0][3] + m[1][1] * a[1][3] + m[1][2] * a[2][3] + m[1][3] * a[3][3],

		m[2][0] * a[0][0] + m[2][1] * a[1][0] + m[2][2] * a[2][0] + m[2][3] * a[3][0],
		m[2][0] * a[0][1] + m[2][1] * a[1][1] + m[2][2] * a[2][1] + m[2][3] * a[3][1],
		m[2][0] * a[0][2] + m[2][1] * a[1][2] + m[2][2] * a[2][2] + m[2][3] * a[3][2],
		m[2][0] * a[0][3] + m[2][1] * a[1][3] + m[2][2] * a[2][3] + m[2][3] * a[3][3],

		m[3][0] * a[0][0] + m[3][1] * a[1][0] + m[3][2] * a[2][0] + m[3][3] * a[3][0],
		m[3][0] * a[0][1] + m[3][1] * a[1][1] + m[3][2] * a[2][1] + m[3][3] * a[3][1],
		m[3][0] * a[0][2] + m[3][1] * a[1][2] + m[3][2] * a[2][2] + m[3][3] * a[3][2],
		m[3][0] * a[0][3] + m[3][1] * a[1][3] + m[3][2] * a[2][3] + m[3][3] * a[3][3]
	);
}

Matrix4& Matrix4::operator*=(const Matrix4& a)
{
	*this = *this * a;
	return *this;
}

Matrix4 Matrix4::SetTranslation(const Float4& f)
{
	m[3][0] = f.x;
	m[3][1] = f.y;
	m[3][2] = f.z;
	m[3][3] = f.w;

	return *this;
}

Vector3 Matrix4::GetTranslation()
{
	return Vector3(m[3][0], m[3][1], m[3][2]);
}

Matrix4 Matrix4::Translation(float x, float y, float z)
{
	Matrix4 mat= Matrix4();
	mat[3][0] = x;
	mat[3][1] = y;
	mat[3][2] = z;
	return mat;
}

Matrix4 Matrix4::Scaling(float x, float y, float z)
{
	Matrix4 mat= Matrix4();
	mat[0][0] = x;
	mat[1][1] = y;
	mat[2][2] = z;
	return mat;
}

Matrix4 Matrix4::RotationX(float radian)
{
	Matrix4 mat= Matrix4();
	mat[1][1] = cosf(radian);
	mat[1][2] = sinf(radian);
	mat[2][1] = -sinf(radian);
	mat[2][2] = cosf(radian);
	return mat;
}

Matrix4 Matrix4::RotationY(float radian)
{
	Matrix4 mat= Matrix4();
	mat[0][0] = cosf(radian);
	mat[0][2] = -sinf(radian);
	mat[2][0] = sinf(radian);
	mat[2][2] = cosf(radian);
	return mat;
}

Matrix4 Matrix4::RotationZ(float radian)
{
	Matrix4 mat= Matrix4();
	mat[0][0] = cosf(radian);
	mat[0][1] = sinf(radian);
	mat[1][0] = -sinf(radian);
	mat[1][1] = cosf(radian);
	return mat;
}

Matrix4 Matrix4::RotationZXY(float radianX, float radianY, float radianZ)
{
	Matrix4 mat=Matrix4();
	mat *= RotationZ(radianZ);
	mat *= RotationX(radianX);
	mat *= RotationY(radianY);
	return mat;
}

Matrix4 Matrix4::View(Vector3 eye, Vector3 target, Vector3 up)
{
	Matrix4 mat;

	Vector3 direction = target - eye;
	direction.normalize();

	Vector3 xVec = up.cross(direction);
	xVec.normalize();
	Vector3 yVec = direction.cross(xVec);
	yVec.normalize();

	mat[0][0] = xVec.x;
	mat[0][1] = xVec.y;
	mat[0][2] = xVec.z;
	mat[1][0] = yVec.x;
	mat[1][1] = yVec.y;
	mat[1][2] = yVec.z;
	mat[2][0] = direction.x;
	mat[2][1] = direction.y;
	mat[2][2] = direction.z;
	mat[3][0] = eye.x;
	mat[3][1] = eye.y;
	mat[3][2] = eye.z;

	//mat = -mat;
	return -mat;
}


Matrix4 Matrix4::PerspectiveProjection(float fov, float aspect, float nearZ, float farZ)
{
	Matrix4 result = Matrix4();

	result[1][1] = 1 / tanf(fov / 2);
	result[0][0] = result[1][1] / aspect;
	result[2][2] = farZ / (farZ - nearZ);
	result[3][2] = (farZ * -nearZ) / (farZ - nearZ);
	result[2][3] = 1;
	result[3][3] = 0;

	return result;
}

Matrix4 Matrix4::OrthoGraphicProjection(float left, float right, float top, float bottom, float nearZ, float farZ)
{
	Matrix4 mat=Matrix4();

	float width = 1.0f / (right - left);
	float height = 1.0f / (top - bottom);
	float range = 1.0f / (farZ - nearZ);

	mat[0][0] = width * 2;
	mat[1][1] = height * 2;
	mat[2][2] = range;

	mat[3][0] = -(left + right) * width;
	mat[3][1] = -(top + bottom) * height;
	mat[3][2] = -range * nearZ;
	mat[3][3] = 1.0f;

	return mat;
}

Matrix4 Matrix4::Viewport(float x, float y, float width, float height, float minDepth, float maxDepth)
{
	Matrix4 result=Matrix4();
	result[0][0] = width / 2.0f;
	result[1][1] = -height / 2.0f;
	result[2][2] = maxDepth - minDepth;
	result[3][0] = x + width / 2.0f;
	result[3][1] = y + height / 2.0f;
	result[3][2] = minDepth;
	return result;
}

Vector3 Matrix4::ProjectionDivW(Vector3 pos, Matrix4 mat)
{
	float w = pos.x * mat[0][3] + pos.y * mat[1][3] + pos.z * mat[2][3] + mat[3][3];
	Vector3 result =
	{
		(pos.x * mat[0][0] + pos.y * mat[1][0] + pos.z * mat[2][0] + mat[3][0]) / w,
		(pos.x * mat[0][1] + pos.y * mat[1][1] + pos.z * mat[2][1] + mat[3][1]) / w,
		(pos.x * mat[0][2] + pos.y * mat[1][2] + pos.z * mat[2][2] + mat[3][2]) / w
	};

	return result;
}

Vector3 operator*(const Vector3 vec, const Matrix4 mat)
{
	Vector3 temp = vec;
	temp.x = vec.x * mat[0][0] + vec.y * mat[1][0] + vec.z * mat[2][0];
	temp.y = vec.x * mat[0][1] + vec.y * mat[1][1] + vec.z * mat[2][1];
	temp.z = vec.x * mat[0][2] + vec.y * mat[1][2] + vec.z * mat[2][2];
	return temp;
}

Vector3& operator*=(Vector3& vec, const Matrix4 mat)
{
	Vector3 temp = vec * mat;
	vec = temp;
	return vec;
}

Float4 operator*(const Float4 f, const Matrix4 mat)
{
	Float4 temp = f;
	temp.x = f.x * mat[0][0] + f.y * mat[1][0] + f.z * mat[2][0] + f.w * mat[3][0];
	temp.y = f.x * mat[0][1] + f.y * mat[1][1] + f.z * mat[2][1] + f.w * mat[3][1];
	temp.z = f.x * mat[0][2] + f.y * mat[1][2] + f.z * mat[2][2] + f.w * mat[3][2];
	temp.w = f.x * mat[0][3] + f.y * mat[1][3] + f.z * mat[2][3] + f.w * mat[3][3];
	return temp;
}

Float4& operator*=(Float4& f, const Matrix4 mat)
{
	Float4 temp = f * mat;
	f = temp;
	return f;
}


============================================================
File Path: SourceCode/Engine/Math/Matrix4.h
============================================================
#pragma once
class Vector3;
class Float4;

class Matrix4
{


private:

	class Row
	{
		float c[4] = {};

	public:
		float operator[](const size_t i) const;
		float& operator[](const size_t i);
		void operator = (const Float4& f);
	};


	Row m[4] = {};

public:

	/// <summary>
	/// å˜ä½è¡Œåˆ—
	/// </summary>
	Matrix4();

	/// <summary>
	/// Float4ã‚’4ã¤ã§åˆæœŸåŒ–
	/// <summary>
	Matrix4(Float4 r0, Float4 r1, Float4 r2, Float4 r3);

	/// <summary>
	/// floatã‚’16å€‹ã§åˆæœŸåŒ–
	/// </summary>
	Matrix4(float r0c0, float r0c1, float r0c2, float r0c3,
		float r1c0, float r1c1, float r1c2, float r1c3,
		float r2c0, float r2c1, float r2c2, float r2c3,
		float r3c0, float r3c1, float r3c2, float r3c3);


	Row operator[](const size_t i) const;
	Row& operator[](const size_t i);

	//é€†è¡Œåˆ—
	Matrix4 operator-() const;

	//è»¢ç½®è¡Œåˆ—
	Matrix4& Transpose();

	//è»¢ç½®è¡Œåˆ—ã‚’å–å¾—
	Matrix4 GetTranspose() const;


	//åŠ ç®—
	Matrix4 operator+(const Matrix4& a) const;
	Matrix4& operator+=(const Matrix4& a);

	//æ¸›ç®—
	Matrix4 operator-(const Matrix4& a) const;
	Matrix4& operator-=(const Matrix4& a);
	
	//ä¹—ç®—
	Matrix4 operator*(const Matrix4& a) const;
	Matrix4& operator*=(const Matrix4& a);

	Matrix4 SetTranslation(const Float4& f);

	Vector3 GetTranslation();

	//å¹³è¡Œç§»å‹•è¡Œåˆ—
	static Matrix4 Translation(float x, float y, float z);

	//ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°è¡Œåˆ—
	static Matrix4 Scaling(float x, float y, float z);

	//Xè»¸å›žè»¢è¡Œåˆ—
	static Matrix4 RotationX(float radian);
	//Yè»¸å›žè»¢è¡Œåˆ—
	static Matrix4 RotationY(float radian);
	//Zè»¸å›žè»¢è¡Œåˆ—
	static Matrix4 RotationZ(float radian);

	//ZXY(Roll,Pitch,Yaw)å›žè»¢è¡Œåˆ—
	static Matrix4 RotationZXY(float radianX, float radianY, float radianZ);

	//ãƒ“ãƒ¥ãƒ¼å¤‰æ›è¡Œåˆ—
	static Matrix4 View(Vector3 eye, Vector3 target, Vector3 up);

	//é€è¦–æŠ•å½±å¤‰æ›è¡Œåˆ—
	static Matrix4 PerspectiveProjection(float fov, float aspect, float nearZ, float farZ);

	//å¹³è¡ŒæŠ•å½±å¤‰æ›è¡Œåˆ—
	static Matrix4 OrthoGraphicProjection(float left, float right, float top, float bottom, float nearZ, float farZ);

	//ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆè¡Œåˆ—
	static Matrix4 Viewport(float x, float y, float width, float height, float minDepth, float maxDepth);

	//wé™¤ç®—
	static Vector3 ProjectionDivW(Vector3 pos, Matrix4 mat);
	
};

Vector3 operator*(const Vector3 vec, const Matrix4 mat);
Vector3& operator*=(Vector3& vec, const Matrix4 mat);

Float4 operator*(const Float4 f, const Matrix4 mat);
Float4& operator*=(Float4& f, const Matrix4 mat);

============================================================
File Path: SourceCode/Engine/Math/Vector2.cpp
============================================================
#include "Vector2.h"
#include "Vector3.h"
#include<cmath>	//sqrt

Vector2::Vector2()
	:x(0), y(0)
{
}

Vector2::Vector2(int32_t x, int32_t y):x(static_cast<float>(x)),y(static_cast<float>(y)) {}

Vector2::Vector2(float x, float y): x(x), y(y){}

float Vector2::length() const
{
	return sqrtf((x * x) + (y * y));
}

Vector2& Vector2::normalize()
{
	float len = length();
	if (len != 0)
	{
		x = x / len;
		y = y / len;
	}
	else {
		x = 0;
		y = 0;
	}
	return *this;
}

Vector2 Vector2::getnormalize() const
{
	float len = length();
	float nx = 0;
	float ny = 0;
	if (len != 0)
	{
		nx = x / len;
		ny = y / len;
	}
	return Vector2(nx, ny);
}

float Vector2::dot(const Vector2& v) const
{
	return x * v.x + y * v.y;
}

float Vector2::cross(const Vector2& v) const
{
	return x * v.y - y * v.x;
}


Vector2 Vector2::operator-() const
{
	return Vector2(-x, -y);
}

bool Vector2::operator==(const Vector2& v) const
{
	return x == v.x && y == v.y;
}

bool Vector2::operator!=(const Vector2& v) const
{
	return x != v.x || y != v.y;
}

Vector2& Vector2::operator+=(const Vector2& v)
{
	x += v.x;
	y += v.y;
	return *this;
}

Vector2& Vector2::operator-=(const Vector2& v)
{
	x -= v.x;
	y -= v.y;
	return *this;
}

Vector2& Vector2::operator*=(float s)
{
	x *= s;
	y *= s;
	return *this;
}

Vector2& Vector2::operator/=(float s)
{
	x /= s;
	y /= s;
	return *this;
}

Vector2 Vector2::operator+(const Vector2& v) const
{
	return Vector2(x + v.x,y + v.y);
}

Vector2 Vector2::operator-(const Vector2& v) const
{
	return Vector2(x - v.x, y - v.y);
}

Vector2 Vector2::operator*(const float s) const
{
	return Vector2(x * s, y * s);
}

Vector2 Vector2::operator/(const float s) const
{
	return Vector2(x / s, y / s);
}

Vector2::operator Vector3() const
{
	return Vector3(x, y, 0);
}

Vector2 operator*(const float s, const Vector2& v)
{
	Vector2 temp;

	temp.x = v.x * s;
	temp.y = v.y * s;
	return temp;
}



============================================================
File Path: SourceCode/Engine/Math/Vector2.h
============================================================
#pragma once
#include <cstdint>

class Vector3;
class Float4;

class Vector2
{
public:
	float x;
	float y;

public:
	//é›¶ãƒ™ã‚¯ãƒˆãƒ«ç”Ÿæˆ
	Vector2();			


	//x,yæˆåˆ†ã‚’æŒ‡å®šã—ã¦ç”Ÿæˆ
	Vector2(int32_t x, int32_t y);
	Vector2(float x, float y);	

	//é–¢æ•°
	
	//é•·ã•
	float length()const;				
	//æ­£è¦åŒ–
	Vector2& normalize();		
	//æ­£è¦åŒ–ã‚’å…¥æ‰‹
	Vector2 getnormalize() const;
	//å†…ç©
	float dot(const Vector2& v)const;	
	//å¤–ç©
	float cross(const Vector2& v)const;	

	//é€†ãƒ™ã‚¯
	Vector2 operator-()const;

	//æ¯”è¼ƒçµ„

	bool operator==(const Vector2& v) const;
	bool operator!=(const Vector2& v) const;

	//æ¼”ç®—çµ„
	 
	//è¶³ã—ç®—
	Vector2& operator+=(const Vector2& v);
	//å¼•ãç®—
	Vector2& operator-=(const Vector2& v);
	//æŽ›ã‘ç®—
	Vector2& operator*=(float s);
	//é™¤ç®—
	Vector2& operator/=(float s);

	//è¶³ã—ç®—
	Vector2 operator+(const Vector2& v) const;
	//å¼•ãç®—
	Vector2 operator-(const Vector2& v) const;
	//æŽ›ã‘ç®—
	Vector2 operator*(const float s) const;
	//é™¤ç®—
	Vector2 operator/(const float s) const;

	operator Vector3() const;

};

Vector2 operator*(const float s, const Vector2& v);


============================================================
File Path: SourceCode/Engine/Math/Vector3.cpp
============================================================
#include "Vector3.h"
#include "Vector2.h"
#include<cmath>	//sqrt

Vector3::Vector3() : x(0), y(0), z(0)
{

}

Vector3::Vector3(float x, float y, float z) : x(x), y(y), z(z)
{
}


float Vector3::length() const
{
	return sqrtf((this->x * this->x) + (this->y * this->y) + (this->z * this->z));
}

Vector3& Vector3::normalize()
{
	float len = length();
	if (len != 0)
	{
		return *this /= len;
	}
	else
	{
		this->x = 0;
		this->y = 0;
		this->z = 0;
	}
	return *this;
}

Vector3 Vector3::getnormalize() const
{
	float len = length();
	float nx = 0;
	float ny = 0;
	float nz = 0;
	if (len != 0)
	{
		nx = this->x / len;
		ny = this->y / len;
		nz = this->z / len;
	}
	return Vector3(nx, ny, nz);
}

float Vector3::dot(const Vector3& v) const
{
	return this->x * v.x + this->y * v.y + this->z * v.z;
}

Vector3 Vector3::cross(const Vector3& v) const
{
	return Vector3(this->y * v.z - this->z * v.y, this->z * v.x - this->x * v.z, this->x * v.y - this->y * v.x);
}

Vector2 Vector3::GetXZ() const
{
	return Vector2(x, z);
}

bool Vector3::operator==(const Vector3& a) const
{
	return this->x == a.x && this->y == a.y && this->z == a.z;
}

bool Vector3::operator!=(const Vector3& a) const
{
	return false;
}


Vector3 Vector3::operator-() const
{
	return Vector3(-this->x, -this->y, -this->z);
}

Vector3& Vector3::operator+=(const Vector3& v)
{
	this->x += v.x;
	this->y += v.y;
	this->z += v.z;

	return *this;
}

Vector3& Vector3::operator-=(const Vector3& v)
{
	this->x += v.x;
	this->y += v.y;
	this->z += v.z;

	return *this;
}

Vector3& Vector3::operator*=(float s)
{
	this->x *= s;
	this->y *= s;
	this->z *= s;
	return *this;
}

Vector3& Vector3::operator/=(float s)
{
	this->x /= s;
	this->y /= s;
	this->z /= s;
	return *this;
}

Vector3 Vector3::operator+(const Vector3& v) const
{
	return Vector3(this->x + v.x, this->y + v.y, this->z + v.z);
}

Vector3 Vector3::operator-(const Vector3& v) const
{
	return Vector3(this->x - v.x, this->y - v.y, this->z - v.z);
}

Vector3 Vector3::operator*(const float s) const
{
	return Vector3(this->x * s, this->y * s, this->z * s);
}

Vector3 Vector3::operator/(const float s) const
{
	return Vector3(this->x / s, this->y / s, this->z / s);
}

Vector3::operator Vector2() const
{
	return Vector2(x, y);
}

Vector3 operator*(const float s, const Vector3& v)
{
	Vector3 temp;

	temp.x = v.x * s;
	temp.y = v.y * s;
	temp.z = v.z * s;

	return temp;
}

const Vector3 lerp(const Vector3& start, const Vector3& end, const float t)
{
	return start + (end - start) * t;
}



============================================================
File Path: SourceCode/Engine/Math/Vector3.h
============================================================
#pragma once
class Vector2;

class Vector3
{
public:
	float x;
	float y;
	float z;


public:
	//ã‚¼ãƒ­ãƒ™ã‚¯ãƒˆãƒ«
	Vector3();
	//ä»»æ„ãƒ™ã‚¯ãƒˆãƒ«
	Vector3(float x, float y, float z);

	Vector3(const float* floatArray) :Vector3(floatArray[0], floatArray[1], floatArray[2]){}

	//é–¢æ•°

	//é•·ã•
	float length()const;
	//æ­£è¦åŒ–
	Vector3& normalize();
	//æ­£è¦åŒ–ã‚’å…¥æ‰‹
	Vector3 getnormalize() const;
	//å†…ç©
	float dot(const Vector3& v)const;
	//å¤–ç©
	Vector3 cross(const Vector3& v)const;

	//xzè»¸ã®2Dãƒ™ã‚¯ãƒˆãƒ«
	Vector2 GetXZ()const;

	//é€†ãƒ™ã‚¯
	Vector3 operator-()const;

	//æ¯”è¼ƒçµ„

	bool operator==(const Vector3& v) const;
	bool operator!=(const Vector3& v) const;

	//æ¼”ç®—çµ„

	//è¶³ã—ç®—
	Vector3& operator+=(const Vector3& v);
	//å¼•ãç®—
	Vector3& operator-=(const Vector3& v);
	//æŽ›ã‘ç®—
	Vector3& operator*=(float s);
	//é™¤ç®—
	Vector3& operator/=(float s);

	//è¶³ã—ç®—
	Vector3 operator+(const Vector3& v) const;
	//å¼•ãç®—
	Vector3 operator-(const Vector3& v) const;
	//æŽ›ã‘ç®—
	Vector3 operator*(const float s) const;
	//é™¤ç®—
	Vector3 operator/(const float s) const;

	operator Vector2() const;
};

Vector3 operator*(const float s, const Vector3& v);

const Vector3 lerp(const Vector3& start, const Vector3& end, const float t);

============================================================
File Path: SourceCode/Engine/Math/myMath.cpp
============================================================
#include "myMath.h"



float myMath::LerpShortAngle(float a, float b, float t)
{

	//è§’åº¦å·®åˆ†
	float diff = b - a;

	if (diff > AngleToRadian(360.0f)|| diff < AngleToRadian(-360.0f))
	{
		diff = static_cast<float>(std::fmod(static_cast<double>(diff), static_cast<double>(AngleToRadian(360.0f))));
	}

	if (diff > AngleToRadian(180.0f))
	{
		diff -= AngleToRadian(360.0f);

	}
	else if(diff< AngleToRadian(-180.0f))
	{
		diff += AngleToRadian(360.0f);
	}

	return a + diff * t;
	





	//return 0.0f;
}

float myMath::AngleToRadian(float angle)
{
	return angle * (PI / 180.0f);
}

float myMath::RadianToAngle(float radian)
{
	return radian * (180 / PI);
}



============================================================
File Path: SourceCode/Engine/Math/myMath.h
============================================================
#pragma once
#include"Vector3.h"
#include"Vector2.h"
#include"Float4.h"
#include"Matrix4.h"
#include<cmath>



constexpr float PI = 3.1415926535897932384f;

namespace myMath
{
	template <typename t>

	//æ­£è² ã‚’è¿”ã™
	t sign(t A) 
	{
		return static_cast<t>((A > 0) - (A < 0));
	}

	//double 

	/// <summary>
	/// æœ€çŸ­è§’åº¦è£œé–“
	/// </summary>
	float LerpShortAngle(float a, float b, float t);


	//Degreeã‹ã‚‰Radianã¸å¤‰æ›ã™ã‚‹
	float AngleToRadian(float angle);

	//Radianã‹ã‚‰Degreeã¸å¤‰æ›ã™ã‚‹
	float RadianToAngle(float radian);

}



============================================================
File Path: test.cpp
============================================================

