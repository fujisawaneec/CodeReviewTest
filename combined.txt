============================================================
File Path: SourceCode/App/BulletManager.cpp
============================================================
#include "BulletManager.h"

BulletManager::BulletManager()
{
}

BulletManager::~BulletManager()
{
}

void BulletManager::Initlize(const Vector3& position, const Vector3& rota, const Vector3& velocity)
{
	St->Wt.translation_ = position;
	St->Wt.rotation_ = rota;
	St->Wt.scale_ = { 0.5f,0.5f,0.5f };

	Velocity_ = velocity;
}

void BulletManager::Update()
{
}

void BulletManager::Draw()
{
}

void BulletManager::OnCollision()
{
	isDead_ = true;
}

Vector3 BulletManager::GetWorldPosition()
{
	return St->Wt.translation_;
}

Vector3 BulletManager::GetScale()
{
	return St->Wt.scale_;
}


============================================================
File Path: SourceCode/App/BulletManager.h
============================================================
#pragma once
#include "StuructTransform.h"
using namespace DirectX;

class BulletManager:public StuructTransform
{
public:


	BulletManager();
	virtual ~BulletManager();

	/// <summary>
	/// 初期化
	/// </summary>
	/// <param name="model">モデル</param>
	/// <param name="position">初期座標</param>
	/// <param name="velocity">速度</param>
	virtual void Initlize(const Vector3& position, const Vector3& rota, const Vector3& velocity);

	/// <summary>
	/// 更新
	/// </summary>
	virtual void Update();

	/// <summary>
	/// 描画
	/// </summary>
	/// <param name="viewProjection">ビュープロジェクション</param>
	virtual void Draw();

	virtual bool IsDead()const { return isDead_; }

	//衝突を検出したら呼び出されるコールバック関数
	virtual void OnCollision();

	Vector3 GetWorldPosition();
	Vector3 GetScale();
	Vector3 GetVec() { return Velocity_; }

private:


	//モデル
	//StuructTransform bullet;


	//テクスチャハンドル


	//速度
	Vector3 Velocity_;


	//デスフラグ
	bool isDead_ = false;





};



============================================================
File Path: SourceCode/App/Camera.cpp
============================================================
#include "Camera.h"
#include <cmath>
#include"Input.h"

void Camera::Initialize(ID3D12Device* Device)
{
	wt.CreateConstBuffer(Device);
	wt.translation_ = { 0.0f,0.0f,0.0f };
	wt.rotation_ = { 0.0f,0.0f,0.0f };
	wt.scale_ = { 1.0f,1.0f,1.0f };
}

void Camera::Reset()
{
	wt.translation_ = { 0.0f,0.0f,0.0f };
	wt.rotation_ = { 0.0f,0.0f,0.0f };
	wt.scale_ = { 1.0f,1.0f,1.0f };
	setRotate({ 0,0,0 });
	viewProjection_.Initialize();

	cameraRotateX = 0;
	cameraRotateY = 0;
	rotateX = 0;
	rotateY = 0;

	/*if (targetWT)
	{
		interTarget = targetWT->translation_;
		wt.rotation_.y = targetWT->rotation_.y;
	}*/


	targetWT = nullptr;
}

void Camera::Update()
{

	wt.UpdateMatrix(&viewProjection_);

	viewProjection_.SetEye(wt.translation_);

	//ワールド前方ベクトル
	forward = { 0.0f, 0.0f, 1.0f };

	//レールカメラの回転を反映
	forward = forward*wt.matWorld_;

	//視点から前方に適当な距離進んだ位置が注視点
	viewProjection_.SetTarget(viewProjection_.Geteye() + forward);

	//ワールド上方ベクトル
	Vector3 up(0, 1, 0);

	//レールカメラの回転を反映(レールカメラの上方ベクトル)
	viewProjection_.SetUp(up*wt.matWorld_);

	if (targetWT)
	{
		Vector3 offset = { -20.0f,20.0f,-20.0f };

		Vector2 inputnum = Input::GetRStick(true, true);
		cameraRotateY += (float)inputnum.x * cameraDPI;
		if ((cameraRotateX < 0.27f && (float)inputnum.y / SHRT_MAX>0) || (cameraRotateX > -0.6f && (float)inputnum.y / SHRT_MAX < 0))
		{
			cameraRotateX += (float)inputnum.y * cameraDPI;
			
		}

		Vector3 cameraPoint = targetWT->translation_;

		cameraPoint.y += 5.0f;
		

		offset.x = offset.x * sinf(cameraRotateY);
		offset.z = offset.z * cosf(cameraRotateY);
		offset.y = offset.y * sinf(-cameraRotateX);



		
		viewProjection_.SetEye(cameraPoint + offset);
		
		viewProjection_.SetTarget(cameraPoint);

		forward = cameraPoint - (cameraPoint + offset);


	}


	viewProjection_.Update();

}

ViewProjection* Camera::getView()
{
	return &viewProjection_;
}

Matrix4 Camera::getMatWorld()
{
	return wt.matWorld_;
}

Vector3 Camera::getForwardVec()
{

	return forward.getnormalize();
}


void Camera::setPos(Vector3 pos)
{
	wt.translation_ = pos;
	wt.UpdateMatrix(&viewProjection_);
}

void Camera::setTarget(Vector3 Target)
{
	viewProjection_.SetTarget(Target);
}

void Camera::setRotate(Vector3 rotate)
{
	wt.rotation_ = rotate;
	wt.UpdateMatrix(&viewProjection_);
}

void Camera::setWorldMat(Matrix4 woeldMat)
{
	wt.matWorld_ = woeldMat;
}




============================================================
File Path: SourceCode/App/Camera.h
============================================================
#pragma once
#include <d3d12.h>
#include "WorldTronsform.h"
#include "ViewProjection.h"
#include"myMath.h"

class Camera
{
public:
	/// <summary>
	/// 初期化
	/// </summary>
	/// <param name="worldTransform">ワールド座標</param>
	/// <param name="Rot">回転角(ラジアン)</param>
	void Initialize(ID3D12Device* Device);

	void Reset();

	/// <summary>
	/// 更新
	/// </summary>
	void Update();

	ViewProjection* getView();

	Matrix4 getMatWorld();

	Vector3 getForwardVec();



	void setPos(Vector3 pos);

	void setTarget(Vector3 Target);
	/// <summary>
	/// カメラに追従先のトランスフォームを渡す
	/// </summary>
	void setTarget(WorldTransform* target) { targetWT = target; }

	void setRotate(Vector3 rotate);

	void setWorldMat(Matrix4 woeldMat);

private:

	const WorldTransform* targetWT = nullptr;

	ViewProjection viewProjection_;

	//ワールド変換データ(適当読み込み)
	WorldTransform wt;

	//ビュープロジェクション

	Vector3 forward = { 0.0f, 0.0f, 1.0f };

	Vector3 interTarget = {};

	float cameraRotateX = 0;
	float cameraRotateY = 0;
	float rotateX = 0;
	float rotateY = 0;

	const float cameraDPI = 0.05f;

};



============================================================
File Path: SourceCode/App/Collision.cpp
============================================================
#include "Collision.h"

bool Collision::CheckSphere2Plane(const Sphere& sphere, const Plane& plane, Vector3* inter)
{
	float distV = sphere.center.dot(plane.normal);

	float dist = distV - plane.distance;

	if (fabsf(dist) > sphere.radius)
	{
		return false;
	}

	if (inter)
	{
		*inter = -dist * plane.normal + sphere.center;
	}

	return true;
}

void Collision::ClosestPtPoint2Triangle(const Vector3& point, const Triangle& triangle, Vector3* closest)
{
	Vector3 p0_p1 = triangle.p1 - triangle.p0;
	Vector3 p0_p2 = triangle.p2 - triangle.p0;
	Vector3 p0_pt = point - triangle.p0;

	float d1 = p0_p1.dot(p0_pt);
	float d2 = p0_p2.dot(p0_pt);

	if (d1 <= 0.0f && d2 <= 0.0f)
	{
		*closest = triangle.p0;
		return;
	}
	
	Vector3 p1_p0 = triangle.p0 - triangle.p1;
	Vector3 p1_p2 = triangle.p2 - triangle.p1;

	Vector3 p1_pt = point - triangle.p1;

	float d3 = p1_p0.dot(p1_pt);
	float d4 = p1_p2.dot(p1_pt);

	if (d3>= 0.0f && d4<= d3)
	{
		*closest = triangle.p1;
		return;
	}

	float vc = d1* d4 - d3 * d2;
	if (vc <= 0.0f && d1>= 0.0f && d3 <= 0.0f)
	{
		float v = d1/ (d1- d3);
		*closest = triangle.p0 + v * p0_p1;
		return;
	}
	Vector3 p2_p0 = triangle.p0 - triangle.p2;
	Vector3 p2_p1 = triangle.p1 - triangle.p2;

	
	Vector3 p2_pt = point - triangle.p2;

	float d5 = p2_p0.dot(p2_pt);
	float d6 = p2_p1.dot(p2_pt);
	if (d6>= 0.0f && d5<= d6)
	{
		*closest = triangle.p2;
		return;
	}

	float vb = d5* d2- d1 * d6;
	if (vb <= 0.0f && d2>= 0.0f && d6<= 0.0f)
	{
		float w = d2/ (d2- d6);
		*closest = triangle.p0 + w * p0_p2;
		return;
	}

	float va = d3 * d6 - d5 * d4;
	if (va <= 0.0f && (d4 - d3) >= 0.0f && (d5 - d6) >= 0.0f)
	{
		float w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
		*closest = triangle.p1 + w * (triangle.p2 - triangle.p1);
		return;
	}

	float denom = 1.0f / (va + vb + vc);
	float v = vb * denom;
	float w = vc * denom;
	*closest = triangle.p0 + p0_p1 * v + p0_p2 * w;
}

bool Collision::CheckSphere2Triangle(const Sphere& sphere, const Triangle& triangle, Vector3* inter)
{
	Vector3 p;

	ClosestPtPoint2Triangle(sphere.center, triangle, &p);

	Vector3 v = p - sphere.center;

	float vf = v.dot(v);

	if (vf > sphere.radius * sphere.radius)
	{
		return false;
	}
	if (inter)
	{
		*inter = p;
	}


	return true;
}

bool Collision::CheckRay2Plane(const Ray& ray, const Plane& plane, float* distance, Vector3* inter)
{
	const float epslion = 1.0e-5f;

	float d1 = plane.normal.dot(ray.dir);

	if (d1 > -epslion)
	{
		return false;
	}

	float d2 =plane.normal.dot(ray.start);

	float dist = d2 - plane.distance;

	float t = dist / -d1;

	if (t < 0)
	{
		return false;
	}

	if (distance)
	{
		*distance = t;
	}

	if (inter)
	{
		*inter = ray.start + t * ray.dir;
	}

	return true;
}

bool Collision::CheckRay2Triangle(const Ray& ray, const Triangle& triangle, float* distance, Vector3* inter)
{
	Plane plane;
	Vector3 interPlane;

	plane.normal = triangle.normal;

	plane.distance = triangle.normal.dot(triangle.p0);

	if (!CheckRay2Plane(ray, plane, distance, &interPlane))
	{
		return false;
	}

	const float epsilon = 1.0e-5f;
	Vector3 m;

	Vector3 pt_p0 = triangle.p0 - interPlane;
	Vector3 p0_p1 = triangle.p1 - triangle.p0;
	m = pt_p0.cross(p0_p1);
	if (m.dot(triangle.normal) < -epsilon)
	{
		return false;
	}
	Vector3 pt_p1 = triangle.p1 - interPlane;
	Vector3 p1_p2 = triangle.p2 - triangle.p1;
	m = pt_p1.cross(p1_p2);
	if (m.dot(triangle.normal) < -epsilon)
	{
		return false;
	}
	Vector3 pt_p2 = triangle.p2 - interPlane;
	Vector3 p2_p0 = triangle.p0 - triangle.p2;
	m = pt_p2.cross(p2_p0);
	if (m.dot(triangle.normal) < -epsilon)
	{
		return false;
	}

	if (inter)
	{
		*inter = interPlane;
	}


	return true;;
}

bool Collision::CheckRay2Sphere(const Ray& ray, const Sphere& sphere, float* distance, Vector3* inter)
{
	Vector3 m = ray.start - sphere.center;
	float b = m.dot( ray.dir);
	float c = m.dot( m) - sphere.radius * sphere.radius;

	if (c > 0.0f && b > 0.0f)
	{
		return false;
	}

	float discr = b * b - c;

	if (discr < 0.0f)
	{
		return false;
	}

	float t = -b - sqrtf(discr);

	if (t < 0)
	{
		t = 0.0f;
	}
	if(distance)
	{
		*distance = t;
	}
	if (inter)
	{
		*inter = ray.start + t * ray.dir;
	}
	


	return true;
}

bool Collision::CheckSphereToSphere(const Sphere& sphere, const Sphere& sphere2)
{

	Vector3 a = sphere2.center - sphere.center;

	


	if (a.length() < sphere.radius + sphere2.radius)
	{
		return true;
	}


	return false;
}


============================================================
File Path: SourceCode/App/Collision.h
============================================================
#pragma once
#include"CollisionPrimitive.h"

class Collision
{
public:
	static bool CheckSphere2Plane(const Sphere& sphere, const Plane& plane, Vector3* inter = nullptr);

	static void ClosestPtPoint2Triangle(const Vector3& point, const Triangle& triangle, Vector3* closest);

	static bool CheckSphere2Triangle(const Sphere& sphere, const Triangle& triangle, Vector3* inter = nullptr);

	static bool CheckRay2Plane(const Ray& ray, const Plane& plane, float* distance = nullptr, Vector3* inter = nullptr);

	static bool CheckRay2Triangle(const Ray& ray, const Triangle& triangle, float* distance = nullptr, Vector3* inter = nullptr);

	static bool CheckRay2Sphere(const Ray& ray, const Sphere& sphere, float* distance = nullptr, Vector3* inter = nullptr);

	static bool CheckSphereToSphere(const Sphere& sphere, const Sphere& sphere2);
};



============================================================
File Path: SourceCode/App/CollisionPrimitive.h
============================================================
#pragma once

#include"myMath.h"
struct Sphere
{
	Vector3 center = { 0,0,0};

	float radius = 1.0f;
};

struct Plane
{
	Vector3 normal = { 0,1,0};

	float distance = 0.0f;
};

class Triangle
{
public:
	Vector3 p0;
	Vector3 p1;
	Vector3 p2;

	Vector3 normal;
};

struct Ray
{
	Vector3 start = { 0,0,0};

	Vector3 dir = { 1,0,0};
};

============================================================
File Path: SourceCode/App/DeathParticle.cpp
============================================================
#include "DeathParticle.h"
#include <iostream>
#include <random>
#include"Easing.h"
#include"Player.h"
#include"myMath.h"
std::unique_ptr<ObjModel> DeathParticle::Premodel;

DeathParticle::DeathParticle()
{
	ModelInit(Premodel.get());
	Velocity_ = { 0,0,0 };
}

DeathParticle::~DeathParticle()
{
}

void DeathParticle::SetModel(ObjModel* model)
{
	Premodel.reset(model);
}

void DeathParticle::CreateDeathParticle(const Vector3& position, const Vector3& rota, const Vector3& velocity, float _scale, Float4 color)
{
	St->Wt.translation_ = position;
	St->Wt.rotation_ = rota;
	startScale = _scale;
	scale = 0;
	St->Wt.scale_ = { startScale,startScale,startScale };
	St->color =color;

	std::random_device rd;
	std::default_random_engine eng(rd());
	std::default_random_engine eng2(rd());
	std::default_random_engine eng3(rd());
	std::uniform_real_distribution<float> distr(-180.0f, 180.0f);

	romdom = { distr(eng),distr(eng2),distr(eng3) };

	romdom.normalize();
	romdom *= spead;

	mode = Pattern::SCATTER;

	Velocity_ = velocity;
}

void DeathParticle::CreateHitParticle(const Vector3& position, const Vector3& rota, const Vector3& velocity, float _scale, Float4 color)
{
	St->Wt.translation_ = position;
	St->Wt.rotation_ = rota;
	startScale = _scale;
	scale = 0;
	St->Wt.scale_ = { startScale,startScale,startScale };
	St->color = color;
	Velocity_ = velocity;
	Velocity_.y = 0;
	Velocity_.normalize();

	std::random_device rd;
	std::default_random_engine eng(rd());
	std::default_random_engine eng2(rd());
	std::default_random_engine eng3(rd());
	std::uniform_real_distribution<float> distr(-60.0f, 60.0f);

	romdom = { distr(eng),distr(eng2),distr(eng3) };

	Matrix4 rotaMat;

	

	rotaMat *= Matrix4::RotationY(distr(eng));
	rotaMat *= Matrix4::RotationX(distr(eng2));

	mode = Pattern::HIT;
	kLifeTime = 30;
	deathTimer_ = kLifeTime;

	Velocity_ = Velocity_ * rotaMat;

	Velocity_.normalize();
	romdom *= spead;
	Velocity_ *= (spead*2);
}

void DeathParticle::Update()
{
	switch (mode)
	{
	case Pattern::STRAIGHT:


		break;

	case Pattern::HIT:
		scale = easeInSine(0, startScale, static_cast<float>(deathTimer_), static_cast<float>(kLifeTime));
		//St->color.z = easeInSine(0, 1.0f, static_cast<float>(deathTimer_), static_cast<float>(kLifeTime));
		St->Wt.translation_ = St->Wt.translation_ + Velocity_;
		St->Wt.rotation_ = St->Wt.rotation_ + romdom;
		St->Wt.scale_ = { scale,scale,scale };

		break;
	case Pattern::SCATTER:

		scale = easeInSine(0, startScale, static_cast<float>(deathTimer_), static_cast<float>(kLifeTime));
		St->color.z= easeInSine(0, 1.0f, static_cast<float>(deathTimer_), static_cast<float>(kLifeTime));
		St->Wt.translation_ = St->Wt.translation_ + romdom;
		St->Wt.rotation_ = St->Wt.rotation_ + romdom;
		St->Wt.scale_ = { scale,scale,scale };
		break;
	}

	St->Update(camera->getView());
	if (deathTimer_ <= 0)
	{
		deathTimer_ = 0;
	}

	//デスタイマーをひいて0以下になったらフラグを立てる
	if (--deathTimer_ <= 0)
	{
		isDead_ = true;
	}

}

void DeathParticle::Draw()
{
	St->Draw();
}

void DeathParticle::Death()
{
	isDead_ = true;
}


============================================================
File Path: SourceCode/App/DeathParticle.h
============================================================
#pragma once
#include "StuructTransform.h"
using namespace DirectX;

enum struct Pattern
{
	STRAIGHT,
	HIT,
	SCATTER
};

class DeathParticle :public StuructTransform
{

public:
	DeathParticle();
	~DeathParticle();

	static void SetModel(ObjModel* model);

	/// <summary>
	/// 初期化
	/// </summary>
	/// <param name="model">モデル</param>
	/// <param name="position">初期座標</param>
	/// <param name="velocity">速度</param>
	void CreateDeathParticle(const Vector3& position, const Vector3& rota, const Vector3& velocity,float _scale,Float4 color);

	/// <summary>
	/// 初期化
	/// </summary>
	/// <param name="model">モデル</param>
	/// <param name="position">初期座標</param>
	/// <param name="velocity">速度</param>
	void CreateHitParticle(const Vector3& position, const Vector3& rota, const Vector3& velocity, float _scale, Float4 color);

	/// <summary>
	/// 更新
	/// </summary>
	void Update();

	/// <summary>
	/// 描画
	/// </summary>
	/// <param name="viewProjection">ビュープロジェクション</param>
	void Draw();

	bool IsDead()const { return isDead_; }

	//衝突を検出したら呼び出されるコールバック関数
	void Death();

private:

	static std::unique_ptr<ObjModel> Premodel;

	Vector3 romdom = { 0,0,0 };

	const float spead = 0.3f;

	float startScale = 0;

	float scale = 0;

	//モデル
	//StuructTransform bullet;


	//テクスチャハンドル


	//速度
	Vector3 Velocity_;

	//寿命<frm>
	int32_t kLifeTime = 60;

	//デスタイマー
	int32_t deathTimer_ = kLifeTime;

	//デスフラグ
	bool isDead_ = false;

	Pattern mode = Pattern::SCATTER;

};



============================================================
File Path: SourceCode/App/Enemy/BossEnemy.cpp
============================================================
#include "BossEnemy.h"
#include"ImGuiManager.h"
#include"Easing.h"
#include"Field.h"
#include"myMath.h"
#include <random>
#include<cmath>

#include <iostream>     // cout
#include <ctime>        // time
#include <cstdlib>      // srand,rand

BossEnemy::BossEnemy()
{
}

void BossEnemy::Init()
{
	ModelInit("enemy");
	EnemyNormalBullet::SetModel(ObjModel::LoadFromOBJ("maru"));
	EnemyMine::SetModel(ObjModel::LoadFromOBJ("maru"));
	//St->Wt.scale_ = { 20.0f,20.0f,20.0f };
	St->color = { 1.0f,1.0f,1.0f,1.0f };
	LeserPoint.Init();
	HP = MaxHP;

	colBox.reset(OBJ3D::Create());
	colBox->SetModel(ObjModel::LoadFromOBJ("maru"));


	HpBarHandle = texMana->LoadTexture("Resources/HpBar.png");


	colBox->Wt.scale_ = St->Wt.scale_;
	colBox->color = { 1.0f,1.0f,1.0f,1.0f };


	sprite_HPbar = std::make_unique<Sprite2D>();
	sprite_HPbar->Initialize(spCommon, HpBarHandle);
	sprite_HPbar->Wt.translation_ = { DxWindow::window_width / 2.0f,DxWindow::window_height / 22.5f ,0.0f };
	sprite_HPbar->Wt.scale_.x = 30.0f;
	sprite_HPbar->Wt.color = { 1.0f,0.0f,0.0f,1.0f };

}

void BossEnemy::Reset()
{

	
	LeserPoint.Init();
	St->Wt.translation_ = { 0,0.0f,20.0f };
	HP = MaxHP;
	//エフェクトや弾周りの初期化
	const std::list<std::unique_ptr<EnemyNormalBullet>>& Bullets = GetBullets();
	for (const std::unique_ptr<EnemyNormalBullet>& bullet : Bullets)
	{

		bullet->OnCollision();

	}
	const std::list<std::unique_ptr<EnemyMine>>& Mines = GetMines();
	for (const std::unique_ptr<EnemyMine>& mine : Mines)
	{

		mine->Destoroy();

	}
	//弾消し関数
	Bulletremove();
	//死亡時パーティクル初期化
	const std::list<std::unique_ptr<DeathParticle>>& Dps = GetDps();
	for (const std::unique_ptr<DeathParticle>& Dp : Dps)
	{

		Dp->Death();

	}

	deathPaticles.remove_if([](std::unique_ptr<DeathParticle>& dp)
		{
			return dp->IsDead();
		});

	//各パラメータ初期化
	BossAtk = AtkPattern::MISSILE;
	BossMove = MovePattern::NONE;
	chargeMoveAniTimer = 0;
	chargeCool = 0;
	mineCool = 0;
	TargetTimer = 0;
	MoveTimer = 0;
	stopTimer = 0;
	WaitTimer = 0;
	endFlag = false;
	DeathTimer = 0;

	aimingTargetPos = { 0,0,0 };

	rotaVec = { 0,0,1.0f };
	DpRate = 0;
	scale = 4.0f;
	criAimTimer = 0;
	crossLine = 0;
	//St->Wt.scale_ = { scale,scale,scale };
}

void BossEnemy::Update(bool flag)
{
	//弾やパーティクルを消していく
	Bulletremove();
	deathPaticles.remove_if([](std::unique_ptr<DeathParticle>& dp)
		{
			return dp->IsDead();
		});

	//死んだとき
	if (Death())
	{
		DeathAnimetion();
	}

	//平面上の距離
	Vector3 plUnderPos = player->GetUnderPos() - St->Wt.translation_;
	Lange = plUnderPos.length();

	sprite_HPbar->Wt.scale_.x = (30.0f * HP / MaxHP);

	St->Wt.translation_.y -= 0.5f;

	//地面押し戻し
	if (St->Wt.translation_.y - (St->Wt.scale_.y/3.0f) < 0.0f)
	{
		St->Wt.translation_.y = (St->Wt.scale_.y / 3.0f);
	}

	chargeCool--;
	mineCool--;

	//突進してないときの基本的な行動テーブル
	if (BossAtk != AtkPattern::CHARGE&&!flag&&!Death())
	{
		
		
		Vector3 Flont = { 0,0,1.0f };
		Flont.normalize();
		plUnderPos.normalize();
		

		float p_pos = atan2(plUnderPos.x, plUnderPos.z);
		float c_vec = atan2(Flont.x, Flont.z);

		St->Wt.rotation_.y = (p_pos + c_vec);

		//行動state
		switch (BossMove)
		{
		case MovePattern::NONE:

			//stopTimer = stopTime;
			MoveTable();
			break;
		case MovePattern::BACK:
			BackMove();
			break;
		case MovePattern::CLOSEMOVE:
			CloseMove();
			break;
		}
	}

	if (!flag && !Death())
	{
		aiming();
		//攻撃state
		switch (BossAtk)
		{
		case AtkPattern::NONE:

			AimMode = false;
			WaitTimer = WaitTimer;
			AtkTable();

			break;
		case AtkPattern::SIMPLESHOT:

			SimpleShot();

			break;
		case AtkPattern::CHARGE:


			ChargeAtk();
			break;
		case AtkPattern::HARDSHOT:
			HardShot();
			break;
		case AtkPattern::MISSILE:

			break;
		case AtkPattern::MINE:
			MineAttack();
			break;
		}
	}

	//弾更新
	for (std::unique_ptr<EnemyNormalBullet>& bullet : Normalbullets_)
	{
		bullet->Update();
	}

	for (std::unique_ptr<EnemyMine>& mine : Mines_)
	{
		mine->Update();
	}


	//パーティクル更新
	for (std::unique_ptr<DeathParticle>& dp : deathPaticles)
	{
		dp->Update();
	}


#ifdef _DEBUG
	ImGuiSet();
#endif

	//エリア外行かないように
	if (St->Wt.translation_.x + St->Wt.scale_.x > Field::GetArea() || St->Wt.translation_.x - St->Wt.scale_.x < -Field::GetArea())
	{
		St->Wt.translation_.x = Field::GetArea() - St->Wt.scale_.x * (abs(St->Wt.translation_.x) / St->Wt.translation_.x);
	}
	if (St->Wt.translation_.z + St->Wt.scale_.z >= Field::GetArea() || St->Wt.translation_.z - St->Wt.scale_.z <= -Field::GetArea())
	{
		St->Wt.translation_.z = Field::GetArea() - St->Wt.scale_.z * (abs(St->Wt.translation_.z) / St->Wt.translation_.z);
	}

	colBox->Wt = St->Wt;

	St->Update(camera->getView());
	colBox->Update(camera->getView());
	sprite_HPbar->Update();
}

void BossEnemy::Damege(float dmg)
{
	HP -= dmg;
}

void BossEnemy::Draw()
{
	for (std::unique_ptr<EnemyNormalBullet>& bullet : Normalbullets_)
	{
		bullet->Draw();
	}
	for (std::unique_ptr<EnemyMine>& mine : Mines_)
	{
		mine->Draw();
	}
	for (std::unique_ptr<DeathParticle>& dp : deathPaticles)
	{
		dp->Draw();
	}

	St->Draw();
	if (colLock)
	{

		colBox->Draw();
	}
	
	//白線描画
	if (AimMode)
	{
		LeserPoint.Draw(St->Wt.translation_, TargetPos);
	}
}

void BossEnemy::DrawUI()
{
	if (HP > 0)
	{
		sprite_HPbar->Draw();
	}
}

void BossEnemy::HitParticle(Vector3 vec)
{
	for (size_t i = 0; i < 10; i++)
	{
		std::unique_ptr <DeathParticle> newBullet = std::make_unique<DeathParticle>();
		newBullet->CreateHitParticle(St->Wt.translation_, St->Wt.rotation_, vec, 2.0f, { 1.f,0.0f,0.0f,1.0f });

		deathPaticles.push_back(std::move(newBullet));
	}
}

void BossEnemy::AtkTable()
{
	//攻撃間のクールタイム参照
	if (WaitTimer < 0)
	{
		//突進攻撃のレンジにいないとき
		if (Lange > LangeMax)
		{
			mt19937 mt{ random_device{}() };

			uniform_int_distribution<int> dist(1, 6);

			int aktmode = dist(mt);

			if (aktmode >=2)
			{
				TargetTimer = TargetTime;
				BossAtk = AtkPattern::SIMPLESHOT;
				BurstTime = BurstNum * BurstRate;
			}
			else
			{
				TargetTimer = TargetTime;
				BossAtk = AtkPattern::HARDSHOT;
				BurstTime = BurstNum * BurstRate;
			}


			

		}
		//突進攻撃範囲内
		if (Lange < LangeMax)
		{
			if (chargeCool < 0)
			{
				

				
				BossAtk = AtkPattern::CHARGE;
				prePos = St->Wt.translation_;
				prePos.y = 0;
				TargetVec = player->GetPos() - St->Wt.translation_;
				TargetVec.y = 0;
				chargeLenge = TargetVec.length();
				TargetVec.normalize();
				chargeCool = chargeCoolTime;
				chargeMoveAniTimer = chargeMoveAniTime;
				

				
			}
			else if(mineCool<0)
			{
				BossAtk = AtkPattern::MINE;
				TargetVec = player->GetPos() - St->Wt.translation_;
				TargetVec.y = 0;
				TargetVec.normalize();
				mineThrowTimer = 0;
				mineThrowDeg = 0;
				mineCool = mineCoolTime;

				

			}
			else if(mineCool>0&& chargeCool>0)
			{
				TargetTimer = TargetTime;
				BossAtk = AtkPattern::SIMPLESHOT;
				BurstTime = BurstNum * BurstRate;
			}


		}

	}
	//攻撃間のクールタイムカウントダウン
	WaitTimer--;
}

void BossEnemy::MoveTable()
{
	if (stopTimer < 0)
	{
		bool TimeRand = rand() % 1;
		if (Lange > LangeMax)
		{
			BossMove = MovePattern::CLOSEMOVE;
			
		}
		else
		{
			BossMove = MovePattern::BACK;
		}

		if (TimeRand)
		{
			MoveTimer = LongMoveTime;
		}
		else
		{
			MoveTimer = MidMoveTime;
		}
	}

	stopTimer--;

}

void BossEnemy::BackMove()
{
	Vector3 moveVec = St->Wt.translation_ - player->GetPos();
	moveVec.y = 0;

	moveVec.normalize();

	moveVec *= 0.4f;

	St->Wt.translation_ += moveVec;

	MoveTimer--;
	if (MoveTimer < 0) { BossMove = MovePattern::NONE; }
}

void BossEnemy::CloseMove()
{
	Vector3 moveVec = player->GetPos() - St->Wt.translation_;
	moveVec.y = 0;

	moveVec.normalize();

	moveVec *= 0.4f;

	St->Wt.translation_ += moveVec;


	MoveTimer--;
	if (MoveTimer < 0) { BossMove = MovePattern::NONE; }
}


void BossEnemy::SimpleShot()
{

	Vector3 BulletVec;
	//照準時間
	if (TargetTimer > 0)
	{
		if (TargetTimer > 10)
		{
			TargetPos = player->GetPos();

		}
		TargetTimer--;
		AimMode = true;
	}
	else//照準終わり時の攻撃
	{
		

		AimMode = false;
		if (CriticalAim)
		{
			BulletVec = aimingTargetPos - St->Wt.translation_;
		}
		else
		{
			BulletVec = player->GetPos() - St->Wt.translation_;
		}
		BulletVec.normalize();

		BulletVec *= nBulletSpeed;
		
		

		//発射レート
		if (BurstTime % BurstRate == 0)
		{
			std::unique_ptr <EnemyNormalBullet> newBullet = std::make_unique<EnemyNormalBullet>();
			newBullet->Initlize(St->Wt.translation_, St->Wt.rotation_, BulletVec);

			Normalbullets_.push_back(std::move(newBullet));

		}
		BurstTime--;
		//射撃時間終わったら
		if (BurstTime <= 0)
		{
			BossAtk = AtkPattern::NONE;

		}
	}

}

void BossEnemy::ChargeAtk()
{


	Vector3 chargeMoved = St->Wt.translation_ - prePos;
	chargeMoved.y = 0;

	St->Wt.translation_ += TargetVec * 1.5f;

	if (chargeLenge + 5.0f < chargeMoved.length())
	{
		BossAtk = AtkPattern::NONE;
	}


}

void BossEnemy::HardShot()
{
	//照準
	if (TargetTimer > 0)
	{
		if (TargetTimer > 10)
		{
			TargetPos = aimingTargetPos;

		}
		TargetTimer--;
		AimMode = true;
	}
	else
	{
		
		AimMode = false;
		Vector3 BulletVec = player->GetPos() - St->Wt.translation_;
		BulletVec.normalize();

		Matrix4 matRot[3];

		

		// スケール、回転、平行移動行列の計算
		matRot[0] *= Matrix4::RotationX(5.0f);
		matRot[1] *= Matrix4::RotationX(-5.0f);;
		matRot[2] *= Matrix4::RotationX(0);

		for (size_t i = 0; i < 3; i++)
		{
			Vector3 HardBullet = BulletVec * matRot[i];
			HardBullet.normalize();
			HardBullet *= hBulletSpeed;

			std::unique_ptr <EnemyNormalBullet> newBullet = std::make_unique<EnemyNormalBullet>();
			newBullet->Initlize(St->Wt.translation_, St->Wt.rotation_, HardBullet);

			Normalbullets_.push_back(std::move(newBullet));

		}
		
		BossAtk = AtkPattern::NONE;

		
	}
}

void BossEnemy::MissileShot()
{




}

void BossEnemy::MineAttack()
{
	Vector3 throwVec = { 0,0,0 };

	

	if (mineThrowTimer == 0)
	{
		for (size_t i = 0; i < mineNum; i++)
		{

			size_t preMineNum = 60*i;

			float deg = XMConvertToRadians(static_cast<float>(preMineNum));

			throwVec.x = TargetVec.x * cosf(deg) - TargetVec.z * sinf(deg);

			throwVec.z = TargetVec.x * sinf(deg) + TargetVec.z * cosf(deg);

			throwVec.normalize();
			throwVec *= 1.0f;

			std::unique_ptr <EnemyMine> newMine = std::make_unique<EnemyMine>();
			newMine->Initlize(St->Wt.translation_, St->Wt.rotation_, throwVec);

			Mines_.push_back(std::move(newMine));

		}
	}

	mineThrowTimer++;
	
	mineThrowDeg = easeOutQuint(0.0, 360.0f, static_cast<float>(mineThrowTimer), static_cast<float>(mineThrowTime));

	St->Wt.rotation_.y += XMConvertToRadians(mineThrowDeg);

	
	

	if (mineThrowTimer >= mineThrowTime)
	{
		
		mineThrowTimer = mineThrowTime;
		mineThrowDeg = 0;
		BossAtk = AtkPattern::NONE;
	}


}

void BossEnemy::ImGuiSet()
{
	//ImguI
	ImGui::SetNextWindowPos({ ImGui::GetMainViewport()->WorkPos.x + 400, ImGui::GetMainViewport()->WorkPos.y + 10 }, ImGuiCond_Once);
	ImGui::SetNextWindowSize({ 400, 500 });

	ImGuiWindowFlags window_flags = 0;
	window_flags |= ImGuiWindowFlags_NoResize;
	ImGui::Begin("Boss", NULL, window_flags);
	ImGui::Text("Scale_X::%5.2f", St->Wt.scale_.x);
	ImGui::Text("Scale_Y::%5.2f", St->Wt.scale_.y);
	ImGui::Text("Scale_Z::%5.2f", St->Wt.scale_.z);
	ImGui::NewLine();
	ImGui::Text("colScale_X::%5.2f", colBox->Wt.scale_.x);
	ImGui::Text("colScale_Y::%5.2f", colBox->Wt.scale_.y);
	ImGui::Text("colScale_Z::%5.2f", colBox->Wt.scale_.z);

	ImGui::NewLine();
	ImGui::Text("Position");
	ImGui::DragFloat("X", &St->Wt.translation_.x, 0.5f);
	ImGui::DragFloat("Y", &St->Wt.translation_.y, 0.5f);
	ImGui::DragFloat("Z", &St->Wt.translation_.z, 0.5f);
	ImGui::NewLine();
	ImGui::Text("Lange::%5.2f", Lange);
	ImGui::DragFloat("Min", &LangeMin, 0.5f);
	ImGui::DragFloat("Max", &LangeMax, 0.5f);
	ImGui::NewLine();
	static int AtkmodeNum = 0;
	const char* AtkModes[] = { "NONE", "SIMPLESHOT", "CHARGE","HARDSHOT","MISSILE","MINE"};
	ImGui::Combo("##AtkmodeNumCombo", &AtkmodeNum, AtkModes, IM_ARRAYSIZE(AtkModes));
	ImGui::SameLine();
	if (ImGui::Button("Change"))
	{
		switch (AtkmodeNum)
		{
		case 0:
			BossAtk = AtkPattern::NONE;
			break;
		case 1:
			TargetTimer = TargetTime;
			BossAtk = AtkPattern::SIMPLESHOT;
			BurstTime = BurstNum * BurstRate;
			break;
		case 2:
			BossAtk = AtkPattern::CHARGE;
			break;
		case 3:
			BossAtk = AtkPattern::HARDSHOT;
			break;
		case 4:
			BossAtk = AtkPattern::MISSILE;
			break;
		case 5:
			BossAtk = AtkPattern::MINE;
			break;
		}

	}
	ImGui::Text("BossAtkPattern::%s", AtkModes[static_cast<int>(BossAtk)]);

	ImGui::NewLine();
	static int MovemodeNum = 0;
	const char* MoveModes[] = { "NONE", "BACK", "CLOSEMOVE" };
	ImGui::Combo("##MovemodeNumCombo", &MovemodeNum, MoveModes, IM_ARRAYSIZE(MoveModes));
	ImGui::SameLine();
	if (ImGui::Button("Change"))
	{
		switch (MovemodeNum)
		{
		case 0:
			BossMove = MovePattern::NONE;
			break;
		case 1:
			BossMove = MovePattern::BACK;
			break;
		case 2:
			BossMove = MovePattern::CLOSEMOVE;
			break;
		}

	}
	ImGui::Text("BossMoveMode::%s", MoveModes[static_cast<int>(BossMove)]);
	ImGui::NewLine();
	ImGui::Text("HP::%5.2f", HP);
	ImGui::DragFloat("HP", &HP, 0.2f);
	ImGui::Checkbox("CriticalAim", &CriticalAim);
	ImGui::Checkbox("colLock", &colLock);

	ImGui::End();
}

void BossEnemy::aiming()
{
	Vector3 criticalAimPos = LinePrediction2(St->Wt.translation_, player->GetPos(), player->GetPredictionPoint(), nBulletSpeed);

	float judgeLine = crossLine;

	aimingTargetPos = player->GetPos();

	aimingTargetPos = lerp(player->GetPos(), criticalAimPos, static_cast<float>(criAimTimer / criAimTime));

	criAimTimer++;
	/*LinePrediction2(St->Wt.translation_, player->GetPos(), player->GetPredictionPoint(), nBulletSpeed)*/
	if (criAimTimer > criAimTime)criAimTimer = criAimTime;

	Vector2 a = (player->GetPos() - St->Wt.translation_).GetXZ();
	Vector2 b = (criticalAimPos - St->Wt.translation_).GetXZ();

	a.normalize();
	b.normalize();

	crossLine = a.cross(b);
	if (myMath::sign(crossLine) != myMath::sign(judgeLine))criAimTimer = 0;

}

void BossEnemy::DeathAnimetion()
{

	DpRate++;
	DeathTimer++;

	scale = easeInSine(4.0f, 0, static_cast<float>(DeathTimer), static_cast<float>(DeathTime));

	St->Wt.scale_ = { scale,scale,scale };

	if (DpRate >= DpRateNum)
	{

		std::unique_ptr <DeathParticle> newBullet = std::make_unique<DeathParticle>();
		newBullet->CreateDeathParticle(St->Wt.translation_, St->Wt.rotation_, -rotaVec,scale/3.0f, { 1.0f,0.0f,0.0f,1.0f });

		deathPaticles.push_back(std::move(newBullet));
		DpRate = 0;
	}
	if (DeathTimer >= DeathTime)
	{
		endFlag = true;
		DeathTimer = DeathTime;
	}

	
}

Vector3 BossEnemy::LinePrediction2(Vector3 shotPosition, Vector3 targetPosition, Vector3 targetPrePosition, float bulletSpeed)
{
	
	Vector3 v3_Mv = targetPosition - targetPrePosition;
	Vector3 v3_Pos = targetPosition - shotPosition;

	
	float A = (v3_Mv.x * v3_Mv.x + v3_Mv.y * v3_Mv.y + v3_Mv.z * v3_Mv.z) - bulletSpeed * bulletSpeed;
	float B = 2 * (v3_Pos.x * v3_Mv.x + v3_Pos.y * v3_Mv.y + v3_Pos.z * v3_Mv.z);
	float C = (v3_Pos.x * v3_Pos.x + v3_Pos.y * v3_Pos.y + v3_Pos.z * v3_Pos.z);

	
	if (A == 0)
	{
		if (B == 0)
		{
			return targetPosition;
		}
		else
		{
			return targetPosition + v3_Mv * (-C / B);
		}
	}

	
	float flame1, flame2;
	float D = B * B - 4 * A * C;
	if (D > 0)
	{
		float E = sqrtf(D);
		flame1 = (-B - E) / (2 * A);
		flame2 = (-B + E) / (2 * A);
		
		flame1 = PlusMin(flame1, flame2);
	}
	else
	{
		
		flame1 = 0;
	}

	
	return targetPosition + v3_Mv * flame1;
}

void BossEnemy::Bulletremove()
{
	Normalbullets_.remove_if([](std::unique_ptr<EnemyNormalBullet>& bullet)
		{
			return bullet->IsDead();
		});
	Mines_.remove_if([](std::unique_ptr<EnemyMine>& mine)
		{
			return mine->IsDead();
		});

}

============================================================
File Path: SourceCode/App/Enemy/BossEnemy.h
============================================================
#pragma once
//敵
#include"StuructTransform.h"
#include"EnemyNormalBullet.h"
#include"EnemyMine.h"
#include"Draw3DLine.h"
#include"Player.h"
#include"DeathParticle.h"

enum struct AtkPattern
{
	NONE,
	SIMPLESHOT,
	CHARGE,
	HARDSHOT,
	MISSILE,
	MINE
};

enum struct MovePattern
{
	NONE,
	BACK,
	CLOSEMOVE,
};

class BossEnemy : public StuructTransform
{
public:

	/// <summary>
	/// コンストラクタ
	/// </summary>
	BossEnemy();

	/// <summary>
	/// プレイヤーポインタ
	/// </summary>
	/// <param name="pl"></param>
	void SetPlayer(Player* pl)
	{
		player = pl;
	}


	/// <summary>
	/// 初期化
	/// </summary>
	void Init();

	/// <summary>
	/// リセット
	/// </summary>
	void Reset();

	/// <summary>
	/// 更新
	/// </summary>
	void Update(bool flag=false);

	/// <summary>
	/// 被ダメ
	/// </summary>
	/// <param name="dmg"></param>
	void Damege(float dmg);

	/// <summary>
	/// 描画
	/// </summary>
	void Draw();

	/// <summary>
	/// UI描画
	/// </summary>
	void DrawUI();

	/// <summary>
	/// 攻撃パターン取得
	/// </summary>
	/// <returns></returns>
	AtkPattern GetAtkPattern()
	{
		return BossAtk;
	}

	/// <summary>
	/// 弾削除
	/// </summary>
	void Bulletremove();
	const std::list<std::unique_ptr<EnemyNormalBullet>>& GetBullets() { return Normalbullets_; }
	const std::list<std::unique_ptr<EnemyMine>>& GetMines() { return Mines_; };

	/// <summary>
	/// 生きてるか
	/// </summary>
	/// <returns></returns>
	bool Death()
	{
		if (HP <= 0)
		{
			return true;
		}
		else
		{
			return false;
		}
	}

	/// <summary>
	/// ゲームエンド時
	/// </summary>
	/// <returns></returns>
	bool GameEnd()
	{
		return endFlag;
	}

	/// <summary>
	/// 被弾時パーティクル
	/// </summary>
	/// <param name="vec"></param>
	void HitParticle(Vector3 vec);

	const std::list<std::unique_ptr<DeathParticle>>& GetDps() { return deathPaticles; };

	/// <summary>
	/// 座標取得
	/// </summary>
	/// <returns></returns>
	Vector3 GetPos()
	{
		return St->Wt.translation_;
	}
private:

	/// <summary>
	/// 攻撃テーブル
	/// </summary>
	void AtkTable();

	/// <summary>
	/// 移動テーブル
	/// </summary>
	void MoveTable();

	/// <summary>
	/// 後退
	/// </summary>
	void BackMove();

	/// <summary>
	/// 接近
	/// </summary>
	void CloseMove();

	/// <summary>
	/// 通常射撃
	/// </summary>
	void SimpleShot();

	/// <summary>
	/// 突進攻撃
	/// </summary>
	void ChargeAtk();

	/// <summary>
	/// 強射撃
	/// </summary>
	void HardShot();

	/// <summary>
	/// ミサイル
	/// </summary>
	void MissileShot();

	/// <summary>
	/// 地雷
	/// </summary>
	void MineAttack();

	/// <summary>
	/// ImGui関係
	/// </summary>
	void ImGuiSet();

	void aiming();

	/// <summary>
	/// 死亡時の動き
	/// </summary>
	void DeathAnimetion();

	Vector3 LinePrediction2(Vector3 shotPosition, Vector3 targetPosition, Vector3 targetPrePosition, float bulletSpeed);

	float PlusMin(float a, float b)
	{
		if (a < 0 && b < 0) return 0;
		if (a < 0) return b;
		if (b < 0) return a;
		return a < b ? a : b;
	}

private:

	std::unique_ptr<OBJ3D> colBox;
	bool colLock = false;

	//演出周り

	std::list<std::unique_ptr<DeathParticle>> deathPaticles;

	//--------

	Vector3 rotaVec = { 0,0,0 };

	float scale = 4.0f;
	int DpRate = 0;
	const int DpRateNum = 1;

	int DeathTimer = 0;

	const int DeathTime = 120;

	int SceneCameraTimer = 0;

	const int SceneCameraTime = 120;

	bool startFlag = false;

	bool endFlag = false;

	//汎用
	Vector3 prePos = { 0,0,0 };
	Player* player;

	Vector3 aimingTargetPos = { 0,0,0 };
	//攻撃パターン
	AtkPattern BossAtk = AtkPattern::NONE;

	//HP
	std::unique_ptr<Sprite2D> sprite_HPbar;

	uint32_t HpBarHandle;
	const float MaxHP = 100.0f;
	float HP = 0.0f;

	//行動パターン
	MovePattern BossMove = MovePattern::NONE;

	const int LongMoveTime = 60 * 6;

	const int MidMoveTime = 60 * 3;

	int MoveTimer = 0;

	float Angle = 0;

	Draw3DLine LeserPoint;

	int stopTimer = 0;
	const int stopTime = 120;

	int WaitTimer = 0;
	const int WaitTime = 180;

	//弾関連
	std::list<std::unique_ptr<EnemyNormalBullet>> Normalbullets_;

	std::list<std::unique_ptr<EnemyMine>> Mines_;

	const float nBulletSpeed = 2.0f;
	const float hBulletSpeed = 5.0f;

	//照準周り
	Vector3 TargetPos = { 0,0,0 };

	const int TargetTime = 60 * 2;

	int TargetTimer = 0;

	bool AimMode = false;

	//通常射撃

	const int BurstRate = 3;
	const int BurstNum = 40;
	int BurstTime = BurstNum * BurstRate;

	bool CriticalAim = true;

	//予測撃ち関係
	const size_t criAimTime = 30;
	size_t criAimTimer = 0;

	float crossLine = 0;


	//突進攻撃
	Vector3 TargetVec = { 0,0,0 };
	float chargeLenge = 0;
	int chargeCool = 0;
	const int chargeCoolTime = 600;

	int chargeMoveAniTimer = 0;

	const int chargeMoveAniTime = 30;

	//認知範囲
	float Lange = 0;
	float LangeMax = 50;
	float LangeMin = 10;

	//地雷
	const size_t mineNum = 6;

	float mineThrowDeg = 0;

	size_t mineThrowTimer = 0;

	const size_t mineThrowTime = 40;

	int mineCool = 0;
	const int mineCoolTime = 300;

	

};

============================================================
File Path: SourceCode/App/Enemy/EnemyMine.cpp
============================================================
#include "EnemyMine.h"
#include <random>
#include "Field.h"
#include"Easing.h"


std::unique_ptr<ObjModel> EnemyMine::Premodel;


EnemyMine::EnemyMine()
{

	ModelInit(Premodel.get());
	Velocity_ = { 0,0,0 };
}

EnemyMine::~EnemyMine()
{
}

void EnemyMine::SetModel(ObjModel* _model)
{
	Premodel.reset(_model);
}

void EnemyMine::Initlize(const Vector3& position, const Vector3& rota, const Vector3& velocity)
{
	St->Wt.translation_ = position;
	St->Wt.rotation_ = rota;
	St->Wt.scale_ = { scale,scale,scale };
	St->color = { 1.0f,0.6f,0.0f,1.0f };

	mineTimer = mineTime;
	stopCounter = stopCount;
	explodeTimer = 0;
	Velocity_ = velocity;

	Velocity_.y = -0.2f;
}

void EnemyMine::Update()
{

	

	if (St->Wt.translation_.y <= 0)
	{
		St->Wt.translation_.y = 0;
		onField = true;
		
	}
	
	if(!onField)
	{
		St->Wt.translation_ = St->Wt.translation_ + Velocity_;
	}
	
	if (onField)
	{
		switch (state)
		{
		case WAIT:
			mineTimer--;
			if (mineTimer <= 0)
			{
				state = mineState::EXPLOSION;
				explode = true;
			}
			break;
		case EXPLOSION:
			explodeTimer++;
			scale = easeOutQuint(1.0f, 4.0f, static_cast<float>(explodeTimer), static_cast<float>(explodeTime));

			if (explodeTimer >= explodeTime)state = mineState::STOPEXPLOSION;
			break;
		case STOPEXPLOSION:
			stopCounter--;
			if (stopCounter <= 0)
			{
				state = mineState::END;
				explodeTimer = 0;
			}
			break;
		case END:
			explodeTimer++;
			scale = easeInQuint(4.0f, 0.0f, static_cast<float>(explodeTimer), static_cast<float>(explodeTime));

			if (explodeTimer >= explodeTime)isDead_ = true;
			break;
		}
		
	}

	St->Wt.scale_ = { scale,scale,scale };


	St->Update(camera->getView());

	
}

void EnemyMine::Draw()
{
	St->Draw();
}

bool EnemyMine::IsHit() const
{
	if (!hited && explode)
	{
		return true;
	}
	return false;
}

void EnemyMine::Destoroy()
{
	isDead_ = true;
}

void EnemyMine::OnCol()
{
	hited = true;
}


============================================================
File Path: SourceCode/App/Enemy/EnemyMine.h
============================================================
#pragma once
#include "StuructTransform.h"
using namespace DirectX;

enum mineState
{
	WAIT,
	EXPLOSION,
	STOPEXPLOSION,
	END

};

class EnemyMine:public StuructTransform
{
public:

	EnemyMine();
	~EnemyMine();

	static void SetModel(ObjModel* _model);

	/// <summary>
	/// 初期化
	/// </summary>
	/// <param name="model">モデル</param>
	/// <param name="position">初期座標</param>
	/// <param name="velocity">速度</param>
	void Initlize(const Vector3& position, const Vector3& rota, const Vector3& velocity);

	/// <summary>
	/// 更新
	/// </summary>
	void Update();

	/// <summary>
	/// 描画
	/// </summary>
	/// <param name="viewProjection">ビュープロジェクション</param>
	void Draw();

	bool IsDead()const { return isDead_; }

	bool IsHit()const;

	//衝突を検出したら呼び出されるコールバック関数
	void Destoroy();

	void OnCol();



	Vector3 GetWorldPosition() { return St->Wt.translation_; }
	Vector3 GetScale() { return St->Wt.scale_; }
	Vector3 GetVec() { return Velocity_; }




private:

	static std::unique_ptr<ObjModel> Premodel;

	//モデル
	//StuructTransform bullet;


	//テクスチャハンドル


	//速度
	Vector3 Velocity_;

	//デスフラグ
	bool isDead_ = false;

	size_t mineTimer = 0;
	const size_t mineTime = 60;

	size_t explodeTimer = 0;
	const size_t explodeTime = 20;

	size_t stopCounter = 0;
	const size_t stopCount = 120;

	bool onField = false;

	mineState state = mineState::WAIT;

	float scale = 1.0f;

	bool hited = false;
	bool explode = false;

};



============================================================
File Path: SourceCode/App/Enemy/EnemyNormalBullet.cpp
============================================================
#include "EnemyNormalBullet.h"

std::unique_ptr<ObjModel> EnemyNormalBullet::Premodel;

EnemyNormalBullet::EnemyNormalBullet()
{
	ModelInit(Premodel.get());
	Velocity_ = { 0,0,0 };
}

EnemyNormalBullet::~EnemyNormalBullet()
{
}

void EnemyNormalBullet::SetModel(ObjModel* _model)
{
	Premodel.reset(_model);
}

void EnemyNormalBullet::Initlize(const Vector3& position, const Vector3& rota, const Vector3& velocity)
{
	St->Wt.translation_ = position;
	St->Wt.rotation_ = rota;
	St->Wt.scale_ = { 0.5f,0.5f,0.5f };
	St->color = { 1.0f,0,0,1.0f };

	Velocity_ = velocity;
}

void EnemyNormalBullet::Update()
{
	St->Wt.translation_ = St->Wt.translation_ + Velocity_;

	St->Update(camera->getView());

	//デスタイマーをひいて0以下になったらフラグを立てる
	if (--deathTimer_ <= 0)
	{
		isDead_ = true;
	}
}

void EnemyNormalBullet::Draw()
{
	St->Draw();
}

void EnemyNormalBullet::OnCollision()
{
	isDead_ = true;
}


============================================================
File Path: SourceCode/App/Enemy/EnemyNormalBullet.h
============================================================
#pragma once
#include "StuructTransform.h"
using namespace DirectX;

class EnemyNormalBullet:public StuructTransform
{
public:
	EnemyNormalBullet();
	~EnemyNormalBullet();

	static void SetModel(ObjModel* _model);

	/// <summary>
	/// 初期化
	/// </summary>
	/// <param name="model">モデル</param>
	/// <param name="position">初期座標</param>
	/// <param name="velocity">速度</param>
	void Initlize(const Vector3& position, const Vector3& rota, const Vector3& velocity);

	/// <summary>
	/// 更新
	/// </summary>
	void Update();

	/// <summary>
	/// 描画
	/// </summary>
	/// <param name="viewProjection">ビュープロジェクション</param>
	void Draw();

	bool IsDead()const { return isDead_; }

	//衝突を検出したら呼び出されるコールバック関数
	void OnCollision();

	Vector3 GetWorldPosition() { return St->Wt.translation_; }
	Vector3 GetScale() { return St->Wt.scale_; }
	Vector3 GetVec() { return Velocity_; }


private:

	static std::unique_ptr<ObjModel> Premodel;

	//モデル
	//StuructTransform bullet;


	//テクスチャハンドル


	//速度
	Vector3 Velocity_;

	//寿命<frm>
	static const int32_t kLifeTime = 60 * 5;

	//デスタイマー
	int32_t deathTimer_ = kLifeTime;

	//デスフラグ
	bool isDead_ = false;


};



============================================================
File Path: SourceCode/App/Field.cpp
============================================================
#include "Field.h"

#include"ImGuiManager.h"
const float Field::AreaLimit = 250.0f;	//半径

void Field::Init(Camera* _camera)
{

	ground.clear();
	ground_model.reset(ObjModel::LoadFromOBJ("555"));

	for (size_t i = 0; i < TileNum; i++)
	{
		std::unique_ptr<OBJ3D > g = std::make_unique<OBJ3D>();

		ground.push_back(std::move(g));
	}

	for (auto& Ground : ground)
	{
		Ground.reset(OBJ3D::Create());
		Ground->SetModel(ground_model.get());
		Ground->Wt.scale_ = { TileSize / 2.0f,0.0f,TileSize / 2.0f };
	}

	for (size_t i = 0; i < ground.size(); i++)
	{
		ground[i]->Wt.translation_.x = -((AreaLimit / 2.0f) - (TileSize / 2.0f)) + ((TileSize) * static_cast<float>(i % 10));
		ground[i]->Wt.translation_.y = 0;
		ground[i]->Wt.translation_.z = ((AreaLimit / 2.0f) - (TileSize / 2.0f)) - ((TileSize) * static_cast<float>(i / 10));
	}

	camera = _camera;
}

void Field::Update()
{
	for (auto& Ground : ground)
	{
		Ground->Update(camera->getView());
	}
#ifdef _DEBUG
	ImGuiSet();
#endif


}

void Field::Draw()
{
	for (auto& Ground : ground)
	{
		Ground->Draw();
	}

}

float Field::GetArea()
{
	return AreaLimit;
}

float Field::GetUpArea()
{
	return UpAreaLimit;
}

void Field::ImGuiSet()
{
	//ImguI
	ImGui::SetNextWindowPos({ ImGui::GetMainViewport()->WorkPos.x, ImGui::GetMainViewport()->WorkPos.y + 10 }, ImGuiCond_Once);
	ImGui::SetNextWindowSize({ 400, 500 });

	ImGuiWindowFlags window_flags = 0;
	window_flags |= ImGuiWindowFlags_NoResize;
	ImGui::Begin("Field", NULL, window_flags);

	ImGui::Text("TileNum%d", ground.size());

	ImGui::End();
}


============================================================
File Path: SourceCode/App/Field.h
============================================================
#pragma once
#include"ObjModel.h"
#include"OBJ3D.h"
#include"Camera.h"

class Field 
{
public:

	void Init(Camera* _camera);

	void Update();

	void Draw();

	static float GetArea();

	float GetUpArea();

	/// <summary>
	/// ImGui関係
	/// </summary>
	void ImGuiSet();

private:

	Camera* camera;

	vector<std::unique_ptr<OBJ3D>> ground;
	std::unique_ptr<ObjModel> ground_model;

	const float UpAreaLimit = 100.0f;

	static const float AreaLimit;

	const size_t LaneTileNum = 10;

	const float TileSize = AreaLimit / static_cast<float>(LaneTileNum);

	const size_t TileNum = LaneTileNum * LaneTileNum;

};



============================================================
File Path: SourceCode/App/GameScene.cpp
============================================================
#include "GameScene.h"
#include"FbxLoader.h"
#include"StuructTransform.h"
#include"Input.h"
#include"Collision.h"
#include"Easing.h"
#include"DeathParticle.h"

using namespace SKNEngine;

void GameScene::Init(DirectXCommon* dxcommon)
{
	//spritecommon = new SpriteCommon();
	//spritecommon->Initialize(dxcommon);

	texturemanager = TextureManager::GetInstance();
	texturemanager->StaticInitialize(dxcommon);
	//light = LightGroup::Create();
	//OBJ3D::SetLight(light);
	//
	//camera.Initialize(dxcommon->GetDevice());
	////Object3D::SetCamera(camera.getView());
	//Draw3DLine::SetCamera(&camera);

	//StuructTransform::SetStruct(&camera, spritecommon, texturemanager);

	//テクスチャ読み込み
	skydome_model = ObjModel::LoadFromOBJ("skydome");
	DeathParticle::SetModel(ObjModel::LoadFromOBJ("boxobj"));
	
	//preTitleHandle = texturemanager->LoadTexture("Resources/title.png");
	//preTitleHandle2 = texturemanager->LoadTexture("Resources/title2.png");
	//SceneChaHandle = texturemanager->LoadTexture("Resources/scene.png");
	//clearScHandle = texturemanager->LoadTexture("Resources/clear.png");
	//GameOverScHandle = texturemanager->LoadTexture("Resources/GameOver.png");
	//

	////3Dモデル周り

	//
	//skydome = OBJ3D::Create();
	//skydome->SetModel(skydome_model);

	//field.Init(&camera);

	//boss.Init();
	//player.Init();

	//camera.setTarget(&player.prePlayer);
	////camera.setTarget(&player.St->Wt);

	//boss.SetPlayer(&player);
	//player.SetEnemy(&boss.St->Wt);


	////スプライト周り

	//preTitle = std::make_unique<Sprite2D>();
	//preTitle->Initialize(spritecommon, preTitleHandle);
	//preTitle->Wt.translation_ = { DxWindow::window_width / 2.0f,DxWindow::window_height / 4.5f ,0.0f };

	//preTitle2 = std::make_unique<Sprite2D>();
	//preTitle2->Initialize(spritecommon, preTitleHandle2);
	//preTitle2->Wt.translation_ = { DxWindow::window_width / 2.0f,(DxWindow::window_height / 2.0f) + 60.0f ,0.0f };

	//SceneCha = std::make_unique<Sprite2D>();
	//SceneCha->Initialize(spritecommon, SceneChaHandle);
	//SceneCha->Wt.translation_ = { DxWindow::window_width / 2.0f,(DxWindow::window_height / 2.0f) ,0.0f };

	//clearSc = std::make_unique<Sprite2D>();
	//clearSc->Initialize(spritecommon, clearScHandle);
	//clearSc->Wt.translation_ = { DxWindow::window_width / 2.0f,(DxWindow::window_height / 2.0f) ,0.0f };


	////パーティクル周り

	//float ambientColor[3] = { 1,1,1 };

	//float lightDir0[3] = { 0,0,-1 };
	//float lightColor0[3] = { 1,0,0 };

	//float litX = 0.0f;
	//float litY = 0.0f;
	//float litZ = 0.0f;

	//float pointLightPos[3] = { litX,litY,litZ };
	//float pointLightColor[3] = { 1,1,1 };

	//float pointLightAtten[3] = { 0.3f,0.1f,0.1f };

	//light->SetDirLightActive(0, true);
	//light->SetPointLightActive(0, false);


	//light->SetPointLightPos(0, Vector3(pointLightPos));
	//light->SetPointLightColor(0, Vector3(pointLightColor));
	//light->SetPointLightAtten(0, Vector3(pointLightAtten));

	////float a = 0.2f;

	////field->Wt->translation_.y = -5.0f;
	//player.Reset();
	//boss.Reset();
	//camera.Reset();
}

void GameScene::Update()
{
	
	switch (scene)
	{
	case SceneType::TITLE:
		TitleUpdate();
		if (Input::GetPadButtonDown(XINPUT_GAMEPAD_A) || Input::GetPressKey(DIK_END))
		{
			sceneChaflag = true;
		}

		if (sceneChaflag)
		{
			SceneChangeTimer++;
			if (SceneChangeTimer >= SceneChangeTime)
			{
				player.Reset();
				boss.Reset();
				camera.Reset();
				GameUpdate();
				//camera.setPos(boss.GetPos());
				camera.setTarget(&player.prePlayer);
				scene = SceneType::GAMESCENE;
				
			}
		}
		else
		{
			SceneChangeTimer = 0;
		}
		break;
	case SceneType::GAMESCENE:
		if (sceneChaflag)
		{
			StartUpdate();
			
		}
		else
		{
			GameUpdate();
		}
		if (player.GameEnd() || boss.GameEnd())
		{
			endSceneChaflag = true;
			
		}
		if (endSceneChaflag)
		{
			SceneChangeTimer++;
			if (SceneChangeTimer >= SceneChangeTime)
			{
				if (player.GameEnd())
				{
					scene = SceneType::GAMEOVER;
					clearSc->SetTexture(GameOverScHandle);
				}
				else if(boss.GameEnd())
				{
					scene = SceneType::CLEARSCENE;
					clearSc->SetTexture(clearScHandle);
				}
				
				player.Reset();
				camera.Reset();
				endSceneChaflag = false;
			}
		}
		break;

	case SceneType::CLEARSCENE:
		
		SceneChangeTimer--;

		if (SceneChangeTimer <= 0)
		{
			SceneChangeTimer = 0;
			scene = SceneType::TITLE;
			player.Reset();
			camera.Reset();
		}

		break;

	case SceneType::GAMEOVER:

		SceneChangeTimer--;

		if (SceneChangeTimer <= 0)
		{
			SceneChangeTimer = 0;
			scene = SceneType::TITLE;
			player.Reset();
			camera.Reset();
		}


		break;
	}

	SceneAlpha = easeOutSine(0, 255.0f, static_cast<float>(SceneChangeTimer), static_cast<float>(SceneChangeTime));
	SceneCha->Wt.color = { SceneAlpha / 255.0f ,SceneAlpha / 255.0f ,SceneAlpha / 255.0f ,SceneAlpha / 255.0f };
	SceneCha->Update();

	ImGuiView();

}

void GameScene::Draw(DirectXCommon* dxcommon)
{
	switch (scene)
	{
	case SceneType::TITLE:
		TitleDraw(dxcommon);
		break;
	case SceneType::GAMESCENE:
		GameDraw(dxcommon);
		break;
	case SceneType::CLEARSCENE:
		spritecommon->PreDraw();
		clearSc->Draw();
		break;
	case SceneType::GAMEOVER:
		spritecommon->PreDraw();
		clearSc->Draw();
		break;
	}
	
	spritecommon->PreDraw();
	SceneCha->Draw();

	
	
}

void GameScene::ALLCol()
{
	const std::list<std::unique_ptr<BulletManager>>& playerBullets = player.GetBullets();

	const std::list<std::unique_ptr<EnemyNormalBullet>>& enemyBullets = boss.GetBullets();

	const std::list<std::unique_ptr<EnemyMine>>& enemyMines = boss.GetMines();

	Sphere playerSp;
	Sphere bossSp;

	playerSp.center = player.GetPos();
	playerSp.radius = player.St->Wt.scale_.x;

	bossSp.center = boss.St->Wt.translation_;
	bossSp.radius = boss.St->Wt.scale_.x;
	hitcheck = false;
	if (Collision::CheckSphereToSphere(playerSp, bossSp))
	{
		hitcheck = true;
		if (boss.GetAtkPattern() == AtkPattern::CHARGE)
		{
			player.Damege(0.2f);
			player.HitParticle(player.GetPos() - boss.GetPos());
		}
	}
	for (const std::unique_ptr<EnemyNormalBullet>& bullet : enemyBullets)
	{
		Sphere bossBulletSp;
		bossBulletSp.center = bullet->GetWorldPosition();
		bossBulletSp.radius = bullet->GetScale().x;
		if (Collision::CheckSphereToSphere(playerSp, bossBulletSp))
		{
			
			player.Damege(1.0f);
			player.HitParticle(bullet->GetVec());
			bullet->OnCollision();
		}
		
	}
	for (const std::unique_ptr<EnemyMine>& mine : enemyMines)
	{
		Sphere bossMineSp;
		bossMineSp.center = mine->GetWorldPosition();
		bossMineSp.radius = mine->GetScale().x;
		if (Collision::CheckSphereToSphere(playerSp, bossMineSp)&&mine->IsHit())
		{

			player.Damege(5.0f);
			player.HitParticle(mine->GetVec());
			player.KnockBack(mine->GetVec());
			mine->OnCol();
			//mine->Destoroy();
		}

	}
	for (const std::unique_ptr<BulletManager>& p_bullet : playerBullets)
	{
		Sphere playerBulletSp;
		playerBulletSp.center =p_bullet->GetWorldPosition();
		playerBulletSp.radius = p_bullet->GetScale().x;
		if (Collision::CheckSphereToSphere(playerBulletSp, bossSp))
		{
			boss.Damege(2.0f);
			boss.HitParticle(p_bullet->GetVec());
			p_bullet->OnCollision();
		}
	}

}

void GameScene::TitleUpdate()
{
	if (tenmetu > 254.0f || tenmetu < 0.0f)
	{
		decri *= -1.0f;
	}

	tenmetu += decri;



	preTitle2->Wt.color = { tenmetu / 255.0f ,tenmetu / 255.0f ,tenmetu / 255.0f ,tenmetu / 255.0f };
	camera.Update();
	preTitle->Update();
	preTitle2->Update();
	player.TitleUpdate();
}

void GameScene::GameUpdate()
{


	ALLCol();

	light->Update();

	camera.Update();
	skydome->Update(camera.getView());
	field.Update();
	player.Update();
	boss.Update();
}

void GameScene::TitleDraw(DirectXCommon* dxcommon)
{
	OBJ3D::PreDraw(dxcommon->GetCommandList());
	/*skydome->Draw();
	field.Draw();*/
	player.Draw();
	spritecommon->PreDraw();

	preTitle->Draw();
	preTitle2->Draw();

	spritecommon->PostDraw();

}

void GameScene::GameDraw(DirectXCommon* dxcommon)
{
	OBJ3D::PreDraw(dxcommon->GetCommandList());

	skydome->Draw();
	field.Draw();

	player.Draw();
	boss.Draw();
	//ParticleManager::PreDraw(dxcommon->GetCommandList());

	// 3Dオブクジェクトの描画
	//particleMan->Draw();


	/// <summary>
	/// ここに3Dオブジェクトの描画処理を追加できる
	/// </summary>

	// 3Dオブジェクト描画後処理
	//ParticleManager::PostDraw();

	spritecommon->PreDraw();
	if (!sceneChaflag)
	{
		player.DrawUI();
		boss.DrawUI();
	}

	//sprite->Draw({ 0,0 });
	//sprite2->DrawClip({ 80.0f,180.0f }, { 200.0f,100.0f }, {});

	spritecommon->PostDraw();

}

void GameScene::StartUpdate()
{
	SceneChangeTimer--;
	//SceneCameraTimer++;

	

	if (SceneChangeTimer <= 0)
	{
		SceneChangeTimer = 0;
		//sceneChaflag = false;
	}
	//sceneCamera=

	//camera.setPos();
	if (SceneCameraTimer >= SceneCameraTime)
	{
		SceneCameraTimer = SceneCameraTime;
		//camera.setTarget(&player.St->Wt);
		
	}
	//camera.Update();
	camera.Update();
	skydome->Update(camera.getView());
	field.Update();
	player.StartUpdate();
	boss.Update(sceneChaflag);
	

	if (player.Start())
	{
		sceneChaflag = false;
	}
}

void GameScene::ImGuiView()
{
	//ImguI
	ImGui::SetNextWindowPos({ ImGui::GetMainViewport()->WorkPos.x + 400, ImGui::GetMainViewport()->WorkPos.y + 10 }, ImGuiCond_Once);
	ImGui::SetNextWindowSize({ 400, 500 });

	ImGuiWindowFlags window_flags = 0;
	window_flags |= ImGuiWindowFlags_NoResize;
	ImGui::Begin("Collsion", NULL, window_flags);

	ImGui::Checkbox("hit", &hitcheck);
	
	ImGui::End();
}




============================================================
File Path: SourceCode/App/GameScene.h
============================================================
#pragma once
#include"DirectXCommon.h"
#include"DxWindow.h"
#include"ViewProjection.h"
//#include"Object3D.h"
#include"ImGuiManager.h"
#include"TextureManager.h"
#include"SpriteCommon.h"
//#include"Model.h"
#include"Sprite2D.h"
#include"LightGroup.h"
#include"ParticleManager.h"
#include"CollisionPrimitive.h"
#include"Collision.h"
#include"OBJ3D.h"
#include"ObjModel.h"
#include"Camera.h"
#include"Player.h"
#include"BossEnemy.h"
#include"Draw3DLine.h"
#include"Field.h"
#include"DeathParticle.h"

enum struct SceneType
{
	TITLE,
	GAMESCENE,
	CLEARSCENE,
	GAMEOVER
};

class GameScene
{

private:
	SpriteCommon* spritecommon = nullptr;
	TextureManager* texturemanager;


public:

	void Init(SKNEngine::DirectXCommon* dxcommon);

	void Update();

	void Draw(SKNEngine::DirectXCommon* dxcommon);

	void ALLCol();

	void Finalize()
	{
		delete spritecommon;
		texturemanager->DeleteInstance();
		delete light;

		delete skydome_model;
		delete skydome;
	}

	

private:

private:
	/// <summary>
	/// タイトル更新
	/// </summary>
	void TitleUpdate();

	/// <summary>
	/// メイン更新
	/// </summary>
	void GameUpdate();

	/// <summary>
	/// タイトル描画
	/// </summary>
	void TitleDraw(SKNEngine::DirectXCommon* dxcommon);

	/// <summary>
	/// メイン描画
	/// </summary>
	void GameDraw(SKNEngine::DirectXCommon* dxcommon);

	void StartUpdate();

	/// <summary>
	/// ImGui関係
	/// </summary>
	void ImGuiView();

	Player player;
	BossEnemy boss;
	Field field;


	float cameraX = 0;
	float cameraZ = 0;
	float rotateX = 0;
	float rotateY = 0;

	float cameraRotateX = 0;
	float cameraRotateY = 9.45f;

	float cameraDPI = 0.05f;


private:
	Camera camera;
	LightGroup* light = nullptr;

	ObjModel* skydome_model = nullptr;
	OBJ3D* skydome = nullptr;


	Vector3 flontVec = { 0,0,1.0f };
	float cameraDistance = 20.0f;

	std::unique_ptr<Sprite2D> preTitle;
	uint32_t preTitleHandle;

	std::unique_ptr<Sprite2D> preTitle2;
	uint32_t preTitleHandle2;

	std::unique_ptr<Sprite2D> SceneCha;
	uint32_t SceneChaHandle;

	std::unique_ptr<Sprite2D> clearSc;
	uint32_t clearScHandle;
	uint32_t GameOverScHandle;

	bool sceneChaflag = false;
	bool endSceneChaflag = false;

	int SceneChangeTimer = 0;

	const int SceneChangeTime = 60;

	float tenmetu = 255.0f;

	float SceneAlpha = 255.0f;

	float SceneAlpha2 = 255.0f;

	float decri = 3.0f;


	SceneType scene = SceneType::TITLE;

	Vector3 sceneCamera = { 0,0,0 };

	int SceneCameraTimer = 0;

	const int SceneCameraTime = 120;

	int clearSceneTimer = 0;

	const int clearSceneTime = 60;

	bool hitcheck = false;



};



============================================================
File Path: SourceCode/App/Player/Player.cpp
============================================================
#include "Player.h"
#include "ImGuiManager.h"
#include "Math/Easing.h"
#include"Field.h"
#include"myMath.h"



void Player::Init()
{

	ModelInit("Player");
	

	prePP.reset(OBJ3D::Create());
	prePP->SetModel(model.get());
	PlayerBullet::SetModel(ObjModel::LoadFromOBJ("maru"));
	
	colBox.reset(OBJ3D::Create());
	colBox->SetModel(ObjModel::LoadFromOBJ("maru"));


	colBox->Wt.scale_ = St->Wt.scale_;
	colBox->Wt.color = { 1.0f,1.0f,1.0f,1.0f };
	
	
	
	reticleHandle = texMana->LoadTexture("Resources/Reticle.png");
	LockHandle = texMana->LoadTexture("Resources/Lock.png");
	HpBarHandle = texMana->LoadTexture("Resources/HpBar.png");
	St->Wt.scale_ = { 1.0f,1.0f,1.0f };
	St->Wt.translation_.y = 50.0f;

	prePP->Wt.scale_ = St->Wt.scale_;
	prePP->Wt.color = { 0,1.0f,0,1.0f };

	HP = MaxHP;

	KeyUI = std::make_unique<Sprite2D>();
	KeyUI->Initialize(spCommon, texMana->LoadTexture("Resources/preKeyUI.png"));

	sprite_HPbar = std::make_unique<Sprite2D>();
	sprite_HPbar->Initialize(spCommon, HpBarHandle);
	sprite_HPbar->Wt.translation_ = { 200.0f,680.0f,0.0f };
	sprite_HPbar->Wt.scale_.x = 10.0f;
	sprite_HPbar->Wt.color = { 0.0f,1.0f,0.0f,1.0f };

	sprite_CoverHPbar = std::make_unique<Sprite2D>();
	sprite_CoverHPbar->Initialize(spCommon,  HpBarHandle);
	sprite_CoverHPbar->Wt.translation_ = { 200.0f,680.0f,0.0f };
	sprite_CoverHPbar->Wt.scale_.x = 10.0f;
	sprite_CoverHPbar->Wt.color = { 0.15f,0.15f,0.15f,1.0f };

	sprite_ENGauge = std::make_unique<Sprite2D>();
	sprite_ENGauge->Initialize(spCommon, HpBarHandle);
	sprite_ENGauge->Wt.translation_ = { DxWindow::window_width / 2.0f,(DxWindow::window_height / 22.5f)*20.0f ,0.0f };
	sprite_ENGauge->Wt.scale_.x = ENGaugeSize * static_cast<float>(ENGauge) / static_cast<float>(ENMAXGauge);
	sprite_ENGauge->Wt.scale_.y *= 0.5f;
	sprite_ENGauge->Wt.color = { 0.0f,0.15f,0.75f,1.0f };

	sprite_CoverENGaugebar = std::make_unique<Sprite2D>();
	sprite_CoverENGaugebar->Initialize(spCommon, HpBarHandle);
	sprite_CoverENGaugebar->Wt.translation_ = { DxWindow::window_width / 2.0f,(DxWindow::window_height / 22.5f) * 20.0f ,0.0f };
	sprite_CoverENGaugebar->Wt.scale_.x = ENGaugeSize;
	sprite_CoverENGaugebar->Wt.scale_.y *= 0.5f;
	sprite_CoverENGaugebar->Wt.color = { 0.15f,0.15f,0.15f,1.0f };

	sprite_Reticle = std::make_unique<Sprite2D>();
	sprite_Reticle->Initialize(spCommon, reticleHandle);
	sprite_Reticle->Wt.translation_ = { DxWindow::window_width / 2.0f,DxWindow::window_height / 2.0f ,0.0f };
	sprite_Reticle->Wt.scale_={ 1.0f,1.0f,1.0f };

	sprite_Lock= std::make_unique<Sprite2D>();
	sprite_Lock->Initialize(spCommon, LockHandle);

	move_speed = 0.4f;

	ENGauge = ENMAXGauge;


	prePlayer = St->Wt;
}

void Player::Reset()
{
	HP = MaxHP;
	St->Wt.translation_ = { 0,50.0f,0 };
	St->Wt.scale_ = { 1.0f,1.0f,1.0f };
	const std::list<std::unique_ptr<BulletManager>>& Bullets = GetBullets();
	for (const std::unique_ptr<BulletManager>& p_bullet : Bullets)
	{
		
		p_bullet->OnCollision();
		
	}
	const std::list<std::unique_ptr<DeathParticle>>& Dps = GetDps();
	for (const std::unique_ptr<DeathParticle>& Dp : Dps)
	{

		Dp->Death();

	}
	bullets_.remove_if([](std::unique_ptr<BulletManager>& bullet)
		{
			return bullet->IsDead();
		});

	deathPaticles.remove_if([](std::unique_ptr<DeathParticle>& dp)
		{
			return dp->IsDead();
		});

	startFlag = false;
	SceneCameraTimer = 0;
	endFlag = false;
	DeathTimer = 0;

	rotaVec = { 0,0,1.0f };
	mae = { 0,0,0 };
	DpRate = 0;
	scale = 1.0f;
	hpBarShakeNum = 0;
	diff = 0;
	
}

void Player::Update()
{
	prePlayer.rotation_ = St->Wt.rotation_;
	sprite_HPbar->Wt.translation_.x = 200.0f-(8.0f * (MaxHP-HP));
	sprite_HPbar->Wt.scale_.x = (10.0f * HP / MaxHP);
	prePlayer.translation_ =lerp(prePlayer.translation_, St->Wt.translation_, 0.3f);

	sprite_ENGauge->Wt.scale_.x = ENGaugeSize * static_cast<float>(ENGauge) / static_cast<float>(ENMAXGauge);
	if (HP > MaxHP)
	{
		HP = MaxHP;
	}

	

	bullets_.remove_if([](std::unique_ptr<BulletManager>& bullet)
		{
			return bullet->IsDead();
		});


	deathPaticles.remove_if([](std::unique_ptr<DeathParticle>& dp)
		{
			return dp->IsDead();
		});

	if (!Death())
	{
		if (knockBack)
		{
			St->Wt.translation_ += knockVec * knockSpeed;
			knockSpeed -= 0.5f;
			if (knockSpeed <= 0)
			{
				knockBack = false;
			}
		}
		else
		{
			Move();
		}
		
	}
	else
	{
		DeathAnimetion();
	}
	
	
	if (Input::GetRTrigger()&& !Death())
	{
		if (latetime <= 0)
		{
			Attack(camera->getForwardVec());

			latetime = firelate;
		}
	}

	latetime--;

	for (std::unique_ptr<BulletManager>& bullet : bullets_)
	{
		bullet->Update();
	}

	for (std::unique_ptr<DeathParticle>& dp : deathPaticles)
	{
		dp->Update();
	}
	
	sprite_Lock->Wt.translation_ = { Lock2DPos.x,Lock2DPos.y,0.0f };

#ifdef _DEBUG
	ImGuiSet();
#endif

	LockOn();

	St->Update(camera->getView());
	prePlayer.UpdateMatrix(camera->getView());
	prePP->Update(camera->getView());
	sprite_Reticle->Update();
	colBox->Wt.translation_ = St->Wt.translation_;
	colBox->Wt.scale_ = St->Wt.scale_;
	colBox->Update(camera->getView());
	sprite_HPbar->Update();
	sprite_ENGauge->Update();
	sprite_CoverENGaugebar->Update();
	sprite_CoverHPbar->Update();
	sprite_Lock->Update();
}

void Player::Damege(float dmg)
{
	HP -= dmg * static_cast<float>(1 - Muteki);

}

void Player::HitParticle(Vector3 vec)
{
	if (!Death())
	{
		for (size_t i = 0; i < 4; i++)
		{
			std::unique_ptr <DeathParticle> newBullet = std::make_unique<DeathParticle>();
			newBullet->CreateHitParticle(St->Wt.translation_, St->Wt.rotation_, vec, 0.5f, { 0,0.3f,1.0f,1.0f });

			deathPaticles.push_back(std::move(newBullet));
		}
	}
	
}

void Player::KnockBack(Vector3 vec)
{
	knockBack = true;
	knockVec = vec;
	knockVec.y = 0;
	knockVec.normalize();
	knockSpeed = knockSpeedNum;

}

void Player::Attack(Vector3 flont)
{
	const float kBulletSpeed = 5.0f;
	
	Vector3 velocity = flont;

	if (Locked)
	{
		velocity = boss->translation_ - GetPos();
	}

	velocity.normalize();

	/*velocity = VectorMat(velocity,player->Wt->matWorld_);
	normalize(velocity);*/

	Vector3 BulletStart = St->Wt.translation_ ;
	velocity *= kBulletSpeed;


	std::unique_ptr <BulletManager> newBullet = std::make_unique<PlayerBullet>();
	newBullet->Initlize(BulletStart, St->Wt.rotation_, velocity);

	bullets_.push_back(std::move(newBullet));

	
}

void Player::Move()
{
	EN();

	

	rotaVec = mae;
	moveVec = { 0,0,0 };
	Vector3 Flont = camera->getForwardVec();
	Flont.y = 0;

	playerPredictionPoint = St->Wt.translation_;
	
	
	Vector2 inputnum = Input::GetLStick(true, true);

	moveVec.x += (float)inputnum.x / SHRT_MAX;
	moveVec.z += (float)inputnum.y / SHRT_MAX;


	float p_pos = atan2(moveVec.x, moveVec.z);
	float c_vec = atan2(Flont.x, Flont.z);




	mae = { 0,0,0 };

	if ((moveVec.x != 0 || moveVec.z != 0))
	{
		mae = { 0,0,1.0f };
		diff = p_pos+c_vec;
		/*St->Wt.rotation_.y = (p_pos + c_vec);*/	
	}
	St->Wt.rotation_.y = myMath::LerpShortAngle(St->Wt.rotation_.y, diff, 0.5f);

	mae *= St->Wt.matWorld_;

	mae.normalize();

	
	
	Jump(mae);

	if ((moveVec.x == 0 && moveVec.z == 0))
	{
		mae = rotaVec;
	}
	Dash(mae);

	if (Input::GetPadButtonDown(XINPUT_GAMEPAD_B))
	{
		BoostMode = !BoostMode;
	}


	if (!DashFlag&& (moveVec.x != 0 || moveVec.z != 0))
	{
		St->Wt.translation_ += mae * (move_speed + (move_speed * BoostMode));
		/*playerPredictionPoint = St->Wt.translation_ + mae * (move_speed + (move_speed * BoostMode));
		playerPredictionPoint.y = 1.5f;*/
	}
	
	if ((moveVec.x == 0 && moveVec.z == 0))
	{
		BoostMode = false;
	}

	//St->Wt.translation_.y -= 0.5f;

	if (St->Wt.translation_.y - (St->Wt.scale_.y * 1.5f) < 0.0f)
	{
		St->Wt.translation_.y = (St->Wt.scale_.y * 1.5f);
		OnGround = true;
	}
	else
	{
		OnGround = false;
	}

	if (St->Wt.translation_.x + St->Wt.scale_.x > Field::GetArea() || St->Wt.translation_.x - St->Wt.scale_.x < -Field::GetArea())
	{
		St->Wt.translation_.x = Field::GetArea() - St->Wt.scale_.x * (abs(St->Wt.translation_.x) / St->Wt.translation_.x);
	}
	if (St->Wt.translation_.z + St->Wt.scale_.z >= Field::GetArea() || St->Wt.translation_.z - St->Wt.scale_.z <= -Field::GetArea())
	{
		St->Wt.translation_.z = Field::GetArea() - St->Wt.scale_.z * (abs(St->Wt.translation_.z) / St->Wt.translation_.z);
	}
	
	prePP->Wt.translation_ = prePlayer.translation_;

}

void Player::Jump(Vector3 front)
{
	if (!OverHeat)
	{
		if (Input::GetPadButtonDown(XINPUT_GAMEPAD_A) && !DashFlag && OnGround)
		{
			JumpFlag = true;
			JumpTimer = 0;
			JumpVec = front;
			UseEN = true;
			ENGauge -= JumpUseGauge;
		}
		if (Input::GetPadButton(XINPUT_GAMEPAD_A) && !DashFlag && !JumpFlag)
		{
			JumpTimer = 0;
			St->Wt.translation_.y += AirUpSpead;
			ENGauge -= AirUseGauge;
		}
	}

	

	if (JumpFlag)
	{
		JumpTimer++;

		Upspeed = easeInSine(UpSpeadNum, 0.0f, static_cast<float>(JumpTimer), static_cast<float>(JumpTime));

		St->Wt.translation_ += JumpVec * Upspeed;

		if (JumpTimer >= JumpTime)
		{
			JumpFlag = false;
			JumpTimer = 0;
		}
	}
	else
	{
		if (!DashFlag)
		{
			JumpTimer++;
			Upspeed = easeOutSine(0.0f, -UpSpeadNum, static_cast<float>(JumpTimer), static_cast<float>(JumpTime));
		}
		if (JumpTimer >= JumpTime)
		{
			JumpTimer = JumpTime;
		}
	}

	St->Wt.translation_.y += Upspeed;

}

void Player::Dash(Vector3 front)
{
	if (Input::GetPadButtonDown(XINPUT_GAMEPAD_X) && !DashFlag&&!OverHeat)
	{
		DashFlag = true;
		DashVec = front;
		DashTimer = 0;
		ENGauge -= DashUseGauge;
		UseEN = true;
		JumpTimer = 0;
		JumpFlag = false;
		Upspeed = 0;
		BoostMode = true;
	}

	if (DashFlag)
	{
		DashTimer++;

		dashspeed = easeInQuint(DashSpeadNum, 0.0f, static_cast<float>(DashTimer), static_cast<float>(DashTime));

		St->Wt.translation_ += DashVec * dashspeed;

		if (DashTimer >= DashTime)
		{
			DashFlag = false;
			BoostMode = true;
		}
	}
}

void Player::EN()
{
	if (InfEN)
	{
		ENGauge = ENMAXGauge;
	}

	if (UseEN)
	{
		RegenENCoolTimer = RegenENCoolTime;
		UseEN = false;
	}

	if (ENGauge <= 0&&!OverHeat)
	{
		OverHeat = true;
		OverHeatENCoolTimer = OverHeatENCoolTime;
	}

	if (OverHeat)
	{
		OverHeatENCoolTimer--;
		RegenENCoolTimer = 0;
		ENGauge += RecoveryENGauge;
		if (OverHeatENCoolTimer <= 0)
		{
			OverHeat = false;
		}
	}
	

	if (RegenENCoolTimer > 0)
	{
		RegenENCoolTimer--;
	}
	else
	{
		ENGauge+=RegenEN;
	}

	if (ENGauge >= ENMAXGauge)
	{
		ENGauge = ENMAXGauge;
	}

	

}

void Player::LockOn()
{
	
	if (ScLock(boss))
	{

		Lock2DPos = WorldToMonitor(boss->translation_);
		sprite_Reticle->Wt.translation_ = { Lock2DPos.x,Lock2DPos.y ,0.0f };
		Locked = true;
	}
	else
	{
		Lock2DPos = { DxWindow::window_width / 2.0f,DxWindow::window_height / 2.0f };
		sprite_Reticle->Wt.translation_ = { DxWindow::window_width / 2.0f,DxWindow::window_height / 2.0f ,0.0f };
		Locked = false;
	}
}

bool Player::ScLock(WorldTransform* prewt)
{
	Matrix4 Pos = prewt->matWorld_;
	Pos *= camera->getView()->GetMAtView();
	Pos *= camera->getView()->GetMatProjection();

	float objZ = Pos.GetTranslation().z;

	Vector2 scr_pos = WorldToMonitor(prewt->translation_);

	if (0 < scr_pos.x && (DxWindow::window_width)  > scr_pos.x && 
		0 < scr_pos.y &&(DxWindow::window_height)> scr_pos.y && objZ > 0)
	{
		return true;
	}

	else
	{
		return false;
	}
}

void Player::DeathAnimetion()
{
	DpRate++;
	DeathTimer++;

	scale = easeInSine(1.0f, 0, static_cast<float>(DeathTimer), static_cast<float>(DeathTime));

	St->Wt.scale_ = { scale,scale,scale };

	if (DpRate >= DpRateNum)
	{

		std::unique_ptr <DeathParticle> newBullet = std::make_unique<DeathParticle>();
		newBullet->CreateDeathParticle(St->Wt.translation_, St->Wt.rotation_, -rotaVec,scale/3.0f, { 0,0.3f,1.0f,1.0f });

		deathPaticles.push_back(std::move(newBullet));
		DpRate = 0;
	}
	if (DeathTimer >= DeathTime)
	{
		endFlag = true;
		DeathTimer = DeathTime;
	}
	
}

Vector2 Player::WorldToMonitor(Vector3 pos)
{
	Vector3 positionReticle = pos;

	Matrix4 matViewport = Matrix4::Viewport(0, 0, static_cast<float>(DxWindow::window_width), static_cast<float>(DxWindow::window_height), 0, 1.0f);

	//ビュー行列とプロジェクション行列、ビューポート行列を合成する
	Matrix4 matViewProjectionViewport = camera->getView()->GetMAtView() * camera->getView()->GetMatProjection() * matViewport;
	//ワールド→スクリーン座標変換(ここで3Dから2Dになる)
	positionReticle = Matrix4::ProjectionDivW(positionReticle,matViewProjectionViewport);

	//スプライトのレティクルに座標設定
	return Vector2(positionReticle.x, positionReticle.y);
}

void Player::ImGuiSet()
{
	//ImguI
	ImGui::SetNextWindowPos({ ImGui::GetMainViewport()->WorkPos.x + 800, ImGui::GetMainViewport()->WorkPos.y + 10 }, ImGuiCond_Once);
	ImGui::SetNextWindowSize({ 400, 500 });

	ImGuiWindowFlags window_flags = 0;
	window_flags |= ImGuiWindowFlags_NoResize;
	ImGui::Begin("Player", NULL, window_flags);

	ImGui::Text("Position");
	ImGui::DragFloat("X", &St->Wt.translation_.x, 0.5f);
	ImGui::DragFloat("Y", &prePP->Wt.translation_.y, 0.5f);
	ImGui::DragFloat("Z", &St->Wt.translation_.z, 0.5f);
	ImGui::NewLine();
	ImGui::Text("HP::%5.2f", HP);
	ImGui::DragFloat("HP", &HP, 0.2f);
	ImGui::DragFloat("HPposX", &sprite_HPbar->Wt.translation_.x, 0.5f);
	ImGui::DragFloat("HPposY", &sprite_HPbar->Wt.translation_.y, 0.5f);
	ImGui::DragFloat("HPSizeX", &sprite_HPbar->Wt.scale_.x, 0.5f);
	ImGui::DragFloat("HPSizeY", &sprite_HPbar->Wt.scale_.y, 0.5f);
	ImGui::NewLine();
	ImGui::Text("ENGauge::%d", ENGauge);
	ImGui::Text("OverHeat::%d", OverHeat);
	ImGui::NewLine();
	ImGui::Text("BoostMode::%d", BoostMode);
	ImGui::Checkbox("InfEN", &InfEN);
	ImGui::Checkbox("Muteki", &Muteki);
	ImGui::Checkbox("colLock", &colLock);


	ImGui::End();

}

void Player::Draw()
{
	for (std::unique_ptr<BulletManager>& bullet : bullets_)
	{
		bullet->Draw();
	}
	for (std::unique_ptr<DeathParticle>& dp : deathPaticles)
	{
		dp->Draw();
	}

	St->Draw();
	if (colLock)
	{
		colBox->Draw();
	}
	//prePP->Draw();
}

void Player::DrawUI()
{
	if (OverHeat)
	{
		sprite_ENGauge->Wt.color = { 1.0f,0,0,1.0f };
	}
	else
	{
		sprite_ENGauge->Wt.color = { 0.0f, 0.15f, 0.75f, 1.0f };
	}

	sprite_Reticle->Draw();
	sprite_Lock->Draw();
	sprite_CoverHPbar->Draw();
	sprite_CoverENGaugebar->Draw();
	KeyUI->Draw(1280.0f-64.0f, 720.0f-128.0f, 1280.0f, 720.0f);
	if (ENGauge > 0)
	{
		sprite_ENGauge->Draw();
	}
	if (HP > 0)
	{
		sprite_HPbar->Draw();
	}
	

	
}

void Player::TitleUpdate()
{

	St->Wt.rotation_.y += 0.05f;

#ifdef _DEBUG
	ImGuiSet();
#endif
	St->Update(camera->getView());
}

void Player::StartUpdate()
{
	SceneCameraTimer++;
	St->Wt.translation_.y = easeOutQuint(50.0f, 1.5f, static_cast<float>(SceneCameraTimer), static_cast<float>(SceneCameraTime));

	if (SceneCameraTimer >= SceneCameraTime)
	{
		SceneCameraTimer = SceneCameraTime;
		startFlag = true;
	}
	prePlayer.translation_ = St->Wt.translation_;
#ifdef _DEBUG
	ImGuiSet();
#endif
	St->Update(camera->getView());
}




============================================================
File Path: SourceCode/App/Player/Player.h
============================================================
#pragma once
#include"Input.h"
#include"PlayerBullet.h"
#include"BulletManager.h"
#include"StuructTransform.h"
#include"ParticleManager.h"
#include"DeathParticle.h"


class Player : public StuructTransform
{
public:
	void SetEnemy(WorldTransform* enemy)
	{
		boss = enemy;
	}

	void Init();

	void Reset();

	void Update();

	void Damege(float dmg);

	void HitParticle(Vector3 vec);

	void KnockBack(Vector3 vec);

	void Draw();

	void DrawUI();

	/// <summary>
	/// 仮タイトル用更新
	/// </summary>
	void TitleUpdate();

	void StartUpdate();

	bool Start()
	{
		return startFlag;
	}

	bool Death()
	{
		if (HP <= 0)
		{
			return true;
		}
		else
		{
			return false;
		}
	}

	bool GameEnd()
	{
		return endFlag;
	}

	Vector3 GetPos()
	{
		return St->Wt.translation_;
	}

	WorldTransform GetPre() 
	{
		return prePlayer;
	}
	Vector3 GetUnderPos()
	{
		Vector3 UnderPos = GetPos();
		UnderPos.y -= St->Wt.scale_.y;
		return UnderPos;
	}

	Vector3 GetPredictionPoint() { return playerPredictionPoint; }

	const std::list<std::unique_ptr<BulletManager>>& GetBullets() { return bullets_; };

	const std::list<std::unique_ptr<DeathParticle>>& GetDps() { return deathPaticles; };

	WorldTransform prePlayer;
private:

	/// <summary>
	/// 攻撃
	/// </summary>
	void Attack(Vector3 flont);

	void Move();

	void Jump(Vector3 front);

	void Dash(Vector3 front);

	void EN();

	void LockOn();

	bool ScLock(WorldTransform* prewt);

	void DeathAnimetion();

	Vector2 WorldToMonitor(Vector3 pos);


	void ImGuiSet();

	
	

private:
	WorldTransform* boss;

	std::unique_ptr<OBJ3D> prePP;

	std::unique_ptr<OBJ3D> colBox;
	bool colLock = false;

	
	float move_speed;

	bool BoostMode = false;

	Vector3 moveVec;

	Vector3 playerPredictionPoint;

	Vector3 rotaVec = { 0,0,0 };

	Vector3 mae = { 0,0,0 };

	//HUD周り----------
	std::unique_ptr<Sprite2D> sprite_Reticle;
	std::unique_ptr<Sprite2D> sprite_Lock;
	std::unique_ptr<Sprite2D> sprite_HPbar;
	std::unique_ptr<Sprite2D> sprite_CoverHPbar;
	std::unique_ptr<Sprite2D> sprite_ENGauge;
	std::unique_ptr<Sprite2D> sprite_CoverENGaugebar;

	std::unique_ptr<Sprite2D> KeyUI;

	uint32_t reticleHandle;
	uint32_t LockHandle;
	uint32_t HpBarHandle;


	Vector2 hpBarShakePos = {0,0};

	float hpBarShakeNum = 0;

	//----------------

	Vector2 Lock2DPos = { 0,0 };

	float scale = 1.0f;
	int DpRate = 0;
	const int DpRateNum = 1;

	//弾関連
	std::list<std::unique_ptr<BulletManager>> bullets_;

	std::list<std::unique_ptr<DeathParticle>> deathPaticles;

	const float MaxHP = 20.0f;
	float HP = 0.0f;


	int bulletCT = 0;

	const int MAXBulletCT = 5;

	const int firelate = 15;

	int latetime;

	bool Locked = false;

	//クイックダッシュ周り

	float dashspeed = 0.0f;

	const float DashSpeadNum = 5.0f;

	Vector3 DashVec = { 0,0,0 };

	bool DashFlag = false;

	int DashTimer = 0;
	const int DashTime = 20;

	//ジャンプand空中周り

	bool OnGround = false;

	float Upspeed = 0.0f;

	Vector3 JumpVec = { 0,0,0 };

	const float AirUpSpead = 0.5f;

	const float UpSpeadNum = 2.0f;

	bool JumpFlag = false;

	int JumpTimer = 0;
	const int JumpTime = 20;

	//ブーストゲージ的な何か-------
	const float ENGaugeSize = 15.0f;

	int ENGauge = 0;

	const int ENMAXGauge = 1000;

	const int DashUseGauge = 200;

	const int JumpUseGauge = 100;

	const int AirUseGauge = 7;

	bool UseEN = false;

	int RegenENCoolTimer = 0;

	const int RegenENCoolTime = 60;

	const int RegenEN = 3;

	const int RecoveryENGauge = 1;

	bool OverHeat = false;

	int OverHeatENCoolTimer = 0;

	const int OverHeatENCoolTime = 250;

	bool InfEN = false;

	bool Muteki = false;



	//--------

	int DeathTimer = 0;

	const int DeathTime = 120;

	int SceneCameraTimer = 0;

	const int SceneCameraTime = 120;

	bool startFlag = false;

	bool endFlag = false;

	
	float diff = 0;

	//ノックバック
	bool knockBack = false;
	Vector3 knockVec = { 0,0,0 };
	float knockSpeed = 0;
	const float knockSpeedNum = 5.0f;
	

};




============================================================
File Path: SourceCode/App/Player/PlayerBullet.cpp
============================================================
#include "PlayerBullet.h"

std::unique_ptr<ObjModel> PlayerBullet::Premodel;

PlayerBullet::PlayerBullet()
{
	ModelInit(Premodel.get());
	Velocity_ = { 0,0,0 };
}

PlayerBullet::~PlayerBullet()
{
}

void PlayerBullet::SetModel(ObjModel* model)
{
	Premodel.reset(model);
}

void PlayerBullet::Initlize(const Vector3& position, const Vector3& rota, const Vector3& velocity)
{
	St->Wt.translation_ = position;
	St->Wt.rotation_ = rota;
	St->Wt.scale_ = { 0.5f,0.5f,0.5f };
	
	Velocity_ = velocity;
}

void PlayerBullet::Update()
{
	St->Wt.translation_ = St->Wt.translation_ + Velocity_;

	St->Update(camera->getView());

	//デスタイマーをひいて0以下になったらフラグを立てる
	if (--deathTimer_ <= 0)
	{
		isDead_ = true;
	}
}

void PlayerBullet::Draw()
{
	//bullet.Draw();
	St->Draw();
}




============================================================
File Path: SourceCode/App/Player/PlayerBullet.h
============================================================
#pragma once
#include "BulletManager.h"
using namespace DirectX;
class PlayerBullet:public BulletManager
{
public:
	PlayerBullet();
	~PlayerBullet();

	static void SetModel(ObjModel* model);

	/// <summary>
	/// 初期化
	/// </summary>
	/// <param name="model">モデル</param>
	/// <param name="position">初期座標</param>
	/// <param name="velocity">速度</param>
	void Initlize(const Vector3& position, const Vector3& rota, const Vector3& velocity) override;

	/// <summary>
	/// 更新
	/// </summary>
	void Update() override;

	/// <summary>
	/// 描画
	/// </summary>
	/// <param name="viewProjection">ビュープロジェクション</param>
	void Draw() override;

	
private:

	static std::unique_ptr<ObjModel> Premodel;

	//モデル
	//StuructTransform bullet;
	

	//テクスチャハンドル


	//速度
	Vector3 Velocity_;

	//寿命<frm>
	static const int32_t kLifeTime = 60 * 5;

	//デスタイマー
	int32_t deathTimer_ = kLifeTime;

	//デスフラグ
	bool isDead_ = false;

};
